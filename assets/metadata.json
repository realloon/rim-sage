[
  {
    "id": "P:CWF.Controllers.ConflictAnalysisResult.HasConflict",
    "name": "HasConflict",
    "fullName": "CWF.Controllers.ConflictAnalysisResult.HasConflict",
    "type": "Property",
    "baseType": null,
    "codeBody": "public bool HasConflict => !ModulesToRemove.NullOrEmpty();",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 252,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.GenList.NullOrEmpty``1"],
    "calledBy": []
  },
  {
    "id": "P:CWF.Controllers.ConflictAnalysisResult.ModulesToRemove",
    "name": "ModulesToRemove",
    "fullName": "CWF.Controllers.ConflictAnalysisResult.ModulesToRemove",
    "type": "Property",
    "baseType": null,
    "codeBody": "public List<WeaponTraitDef> ModulesToRemove { get; } = [];",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 250,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.Controllers.ConflictAnalysisResult",
    "name": "ConflictAnalysisResult",
    "fullName": "CWF.Controllers.ConflictAnalysisResult",
    "type": "Class",
    "baseType": null,
    "codeBody": "public class ConflictAnalysisResult {\n    public List<WeaponTraitDef> ModulesToRemove { get; } = [];\n\n    public bool HasConflict => !ModulesToRemove.NullOrEmpty();\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 249,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.Controllers.InteractionController.GetCompatibleModuleDefsFor(CWF.PartDef)",
    "name": "GetCompatibleModuleDefsFor",
    "fullName": "CWF.Controllers.InteractionController.GetCompatibleModuleDefsFor(CWF.PartDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private IEnumerable<ThingDef> GetCompatibleModuleDefsFor(PartDef part) {\n        return ModuleDatabase.AllModuleDefs\n            .Where(moduleDef => moduleDef.GetModExtension<TraitModuleExtension>().part == part)\n            .Where(moduleDef => moduleDef.IsCompatibleWith(weapon.def));\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 240,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:Verse.Def.GetModExtension``1",
      "M:CWF.ModuleDatabase.IsCompatibleWith(Verse.ThingDef)"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.BuildInstallOptions(CWF.PartDef,System.Collections.Generic.List{Verse.FloatMenuOption})"
    ]
  },
  {
    "id": "M:CWF.Controllers.InteractionController.ShowConfirmationDialog(System.String,System.String,System.Action)",
    "name": "ShowConfirmationDialog",
    "fullName": "CWF.Controllers.InteractionController.ShowConfirmationDialog(string, string, System.Action)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static void ShowConfirmationDialog(string title, string text, Action onConfirm) {\n        var dialog = new Dialog_MessageBox(\n            text,\n            \"Confirm\".Translate(), onConfirm,\n            \"Cancel\".Translate(), null,\n            title,\n            true, onConfirm\n        );\n        Find.WindowStack.Add(dialog);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 229,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Translator.Translate",
      "M:Verse.WindowStack.Add(Verse.Window)",
      "M:Verse.Dialog_MessageBox.#ctor(Verse.TaggedString,System.String,System.Action,System.String,System.Action,System.String,System.Boolean,System.Action,System.Action,Verse.WindowLayer)"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.CreateInstallAction(CWF.PartDef,RimWorld.WeaponTraitDef)",
      "M:CWF.Controllers.InteractionController.BuildUninstallOption(CWF.PartDef,System.Collections.Generic.List{Verse.FloatMenuOption},RimWorld.WeaponTraitDef)"
    ]
  },
  {
    "id": "M:CWF.Controllers.InteractionController.CalculateFutureAvailableParts(System.Collections.Generic.IEnumerable{RimWorld.WeaponTraitDef})",
    "name": "CalculateFutureAvailableParts",
    "fullName": "CWF.Controllers.InteractionController.CalculateFutureAvailableParts(System.Collections.Generic.IEnumerable<RimWorld.WeaponTraitDef>)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private HashSet<PartDef> CalculateFutureAvailableParts(IEnumerable<WeaponTraitDef> futureTraits) {\n        if (weapon.TryGetComp<CompDynamicTraits>()?.props is not CompProperties_DynamicTraits props) return [];\n\n        var availableParts = new HashSet<PartDef>(props.supportParts);\n\n        foreach (var traitDef in futureTraits) {\n            if (!traitDef.TryGetModuleDef(out var moduleDef)) continue;\n\n            var ext = moduleDef.GetModExtension<TraitModuleExtension>();\n            if (ext?.conditionalPartModifiers == null) continue;\n\n            foreach (var rule in ext.conditionalPartModifiers) {\n                if (rule.matcher == null || !rule.matcher.IsMatch(weapon.def)) continue;\n\n                availableParts.UnionWith(rule.enablesParts);\n                availableParts.ExceptWith(rule.disablesParts);\n            }\n        }\n\n        return availableParts;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 207,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:CWF.ModuleDatabase.TryGetModuleDef(Verse.ThingDef@)",
      "M:Verse.Def.GetModExtension``1",
      "M:CWF.WeaponMatcher.IsMatch(Verse.ThingDef)",
      "M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})",
      "M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})",
      "M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.AnalyzeUninstallConflict(CWF.PartDef)"
    ]
  },
  {
    "id": "M:CWF.Controllers.InteractionController.AnalyzeUninstallConflict(CWF.PartDef)",
    "name": "AnalyzeUninstallConflict",
    "fullName": "CWF.Controllers.InteractionController.AnalyzeUninstallConflict(CWF.PartDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private ConflictAnalysisResult AnalyzeUninstallConflict(PartDef partToUninstall) {\n        var result = new ConflictAnalysisResult();\n        var currentTraits = _compDynamicTraits.InstalledTraits;\n\n        if (!currentTraits.Remove(partToUninstall)) return result;\n\n        var futureAvailableParts = CalculateFutureAvailableParts(currentTraits.Values);\n\n        foreach (var (part, trait) in currentTraits) {\n            if (futureAvailableParts.Contains(part)) continue;\n\n            result.ModulesToRemove.Add(trait);\n        }\n\n        return result;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 190,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Collections.Generic.Dictionary`2.Remove(`0)",
      "M:CWF.Controllers.InteractionController.CalculateFutureAvailableParts(System.Collections.Generic.IEnumerable{RimWorld.WeaponTraitDef})",
      "M:System.Collections.Generic.HashSet`1.Contains(`0)",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:CWF.Controllers.ConflictAnalysisResult.#ctor"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.BuildUninstallOption(CWF.PartDef,System.Collections.Generic.List{Verse.FloatMenuOption},RimWorld.WeaponTraitDef)"
    ]
  },
  {
    "id": "M:CWF.Controllers.InteractionController.AnalyzeInstallConflict(Verse.ThingDef)",
    "name": "AnalyzeInstallConflict",
    "fullName": "CWF.Controllers.InteractionController.AnalyzeInstallConflict(Verse.ThingDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private ConflictAnalysisResult AnalyzeInstallConflict(ThingDef moduleToInstall) {\n        var result = new ConflictAnalysisResult();\n        var ext = moduleToInstall.GetModExtension<TraitModuleExtension>();\n        if (ext?.conditionalPartModifiers == null) return result;\n\n        var partsToDisable = new HashSet<PartDef>();\n        foreach (var rule in ext.conditionalPartModifiers) {\n            if (rule.matcher != null && rule.matcher.IsMatch(weapon.def)) {\n                partsToDisable.UnionWith(rule.disablesParts);\n            }\n        }\n\n        foreach (var part in partsToDisable) {\n            var conflictingTrait = _compDynamicTraits.GetInstalledTraitFor(part);\n            if (conflictingTrait != null) {\n                result.ModulesToRemove.Add(conflictingTrait);\n            }\n        }\n\n        return result;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 168,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Def.GetModExtension``1",
      "M:CWF.WeaponMatcher.IsMatch(Verse.ThingDef)",
      "M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})",
      "M:CWF.CompDynamicTraits.GetInstalledTraitFor(CWF.PartDef)",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:CWF.Controllers.ConflictAnalysisResult.#ctor",
      "M:System.Collections.Generic.HashSet`1.#ctor"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.CreateInstallAction(CWF.PartDef,RimWorld.WeaponTraitDef)"
    ]
  },
  {
    "id": "M:CWF.Controllers.InteractionController.CreateInstallAction(CWF.PartDef,RimWorld.WeaponTraitDef)",
    "name": "CreateInstallAction",
    "fullName": "CWF.Controllers.InteractionController.CreateInstallAction(CWF.PartDef, RimWorld.WeaponTraitDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private Action CreateInstallAction(PartDef part, WeaponTraitDef traitToInstall) {\n        return () => {\n            if (!traitToInstall.TryGetModuleDef(out var moduleDef)) {\n                DoInstall(part, traitToInstall);\n                return;\n            }\n\n            var analysis = AnalyzeInstallConflict(moduleDef);\n            if (!analysis.HasConflict) {\n                DoInstall(part, traitToInstall);\n                return;\n            }\n\n            ShowConfirmationDialog(\n                \"CWF_UI_ConfirmInstallTitle\".Translate(),\n                \"CWF_UI_ConfirmInstallBody\".Translate(\n                    traitToInstall.LabelCap.Named(\"MODULE\"),\n                    analysis.ModulesToRemove\n                        .Select(t => \" - \" + t.LabelCap.ToString()).ToLineList()\n                        .Named(\"CONFLICTS\")\n                ),\n                () => {\n                    foreach (var conflictTrait in analysis.ModulesToRemove) {\n                        if (conflictTrait.TryGetPart(out var conflictPart)) {\n                            DoUninstall(conflictPart);\n                        }\n                    }\n\n                    DoInstall(part, traitToInstall);\n                }\n            );\n        };\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 134,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.ModuleDatabase.TryGetModuleDef(Verse.ThingDef@)",
      "M:CWF.Controllers.InteractionController.DoInstall(CWF.PartDef,RimWorld.WeaponTraitDef)",
      "M:CWF.Controllers.InteractionController.AnalyzeInstallConflict(Verse.ThingDef)",
      "M:CWF.Controllers.InteractionController.ShowConfirmationDialog(System.String,System.String,System.Action)",
      "M:Verse.Translator.Translate",
      "M:Verse.TranslatorFormattedStringExtensions.Translate(Verse.NamedArgument,Verse.NamedArgument)",
      "M:Verse.NamedArgumentUtility.Named(System.String)",
      "M:Verse.GenText.ToLineList(System.String,System.Boolean)",
      "M:System.Linq.Enumerable.Select``2(System.Func{``0,``1})",
      "M:Verse.TaggedString.ToString",
      "M:CWF.ModuleDatabase.TryGetPart(CWF.PartDef@)",
      "M:CWF.Controllers.InteractionController.DoUninstall(CWF.PartDef)"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.BuildInstallOptions(CWF.PartDef,System.Collections.Generic.List{Verse.FloatMenuOption})"
    ]
  },
  {
    "id": "M:CWF.Controllers.InteractionController.DoUninstall(CWF.PartDef)",
    "name": "DoUninstall",
    "fullName": "CWF.Controllers.InteractionController.DoUninstall(CWF.PartDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void DoUninstall(PartDef part) {\n        var traitToUninstall = _compDynamicTraits.GetInstalledTraitFor(part);\n        if (traitToUninstall != null) {\n            _stagedUninstalls.Add(traitToUninstall);\n        }\n\n        _compDynamicTraits.UninstallTrait(part);\n        SoundDefOf.Tick_High.PlayOneShotOnCamera();\n        OnDataChanged();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 121,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.CompDynamicTraits.GetInstalledTraitFor(CWF.PartDef)",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:CWF.CompDynamicTraits.UninstallTrait(CWF.PartDef)",
      "M:Verse.Sound.SoundStarter.PlayOneShotOnCamera(Verse.Map)",
      "M:System.Action.Invoke"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.CreateInstallAction(CWF.PartDef,RimWorld.WeaponTraitDef)",
      "M:CWF.Controllers.InteractionController.BuildUninstallOption(CWF.PartDef,System.Collections.Generic.List{Verse.FloatMenuOption},RimWorld.WeaponTraitDef)"
    ]
  },
  {
    "id": "M:CWF.Controllers.InteractionController.DoInstall(CWF.PartDef,RimWorld.WeaponTraitDef)",
    "name": "DoInstall",
    "fullName": "CWF.Controllers.InteractionController.DoInstall(CWF.PartDef, RimWorld.WeaponTraitDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void DoInstall(PartDef part, WeaponTraitDef traitToInstall) {\n        _stagedUninstalls.Remove(traitToInstall);\n\n        _compDynamicTraits.InstallTrait(part, traitToInstall);\n        SoundDefOf.Tick_High.PlayOneShotOnCamera();\n        OnDataChanged();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 113,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Collections.Generic.List`1.Remove(`0)",
      "M:CWF.CompDynamicTraits.InstallTrait(CWF.PartDef,RimWorld.WeaponTraitDef)",
      "M:Verse.Sound.SoundStarter.PlayOneShotOnCamera(Verse.Map)",
      "M:System.Action.Invoke"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.CreateInstallAction(CWF.PartDef,RimWorld.WeaponTraitDef)"
    ]
  },
  {
    "id": "M:CWF.Controllers.InteractionController.BuildUninstallOption(CWF.PartDef,System.Collections.Generic.List{Verse.FloatMenuOption},RimWorld.WeaponTraitDef)",
    "name": "BuildUninstallOption",
    "fullName": "CWF.Controllers.InteractionController.BuildUninstallOption(CWF.PartDef, System.Collections.Generic.List<Verse.FloatMenuOption>, RimWorld.WeaponTraitDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void BuildUninstallOption(PartDef part, List<FloatMenuOption> options, WeaponTraitDef installedTrait) {\n        options.Add(new FloatMenuOption(\"CWF_UI_Uninstall\".Translate(installedTrait.LabelCap), () => {\n            var analysis = AnalyzeUninstallConflict(part);\n            if (!analysis.HasConflict) {\n                DoUninstall(part);\n            } else {\n                ShowConfirmationDialog(\n                    \"CWF_UI_ConfirmUninstallTitle\".Translate(),\n                    \"CWF_UI_ConfirmUninstallBody\".Translate(\n                        installedTrait.LabelCap.Named(\"MODULE\"),\n                        analysis.ModulesToRemove\n                            .Select(t => \" - \" + t.LabelCap.ToString()).ToLineList()\n                            .Named(\"DEPENDENCIES\")\n                    ),\n                    () => {\n                        foreach (var dependencyTrait in analysis.ModulesToRemove) {\n                            if (dependencyTrait.TryGetPart(out var dependencyPart)) {\n                                DoUninstall(dependencyPart);\n                            }\n                        }\n\n                        DoUninstall(part);\n                    }\n                );\n            }\n        }));\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 85,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:Verse.TranslatorFormattedStringExtensions.Translate(Verse.NamedArgument)",
      "M:CWF.Controllers.InteractionController.AnalyzeUninstallConflict(CWF.PartDef)",
      "M:CWF.Controllers.InteractionController.DoUninstall(CWF.PartDef)",
      "M:CWF.Controllers.InteractionController.ShowConfirmationDialog(System.String,System.String,System.Action)",
      "M:Verse.Translator.Translate",
      "M:Verse.TranslatorFormattedStringExtensions.Translate(Verse.NamedArgument,Verse.NamedArgument)",
      "M:Verse.NamedArgumentUtility.Named(System.String)",
      "M:Verse.GenText.ToLineList(System.String,System.Boolean)",
      "M:System.Linq.Enumerable.Select``2(System.Func{``0,``1})",
      "M:Verse.TaggedString.ToString",
      "M:CWF.ModuleDatabase.TryGetPart(CWF.PartDef@)",
      "M:Verse.FloatMenuOption.#ctor(System.String,System.Action,Verse.MenuOptionPriority,System.Action{UnityEngine.Rect},Verse.Thing,System.Single,System.Func{UnityEngine.Rect,System.Boolean},RimWorld.Planet.WorldObject,System.Boolean,System.Int32)"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.HandleSlotClick(CWF.PartDef,RimWorld.WeaponTraitDef)"
    ]
  },
  {
    "id": "M:CWF.Controllers.InteractionController.BuildInstallOptions(CWF.PartDef,System.Collections.Generic.List{Verse.FloatMenuOption})",
    "name": "BuildInstallOptions",
    "fullName": "CWF.Controllers.InteractionController.BuildInstallOptions(CWF.PartDef, System.Collections.Generic.List<Verse.FloatMenuOption>)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void BuildInstallOptions(PartDef part, List<FloatMenuOption> options) {\n        var installCandidates = new Dictionary<WeaponTraitDef, ThingDef>();\n\n        var compatibleModuleDefs = new HashSet<ThingDef>(GetCompatibleModuleDefsFor(part));\n\n        var ownerPawn = weapon.ParentHolder switch {\n            Pawn_EquipmentTracker equipment => equipment.pawn,\n            Pawn_InventoryTracker inventory => inventory.pawn,\n            _ => null\n        };\n\n        // from inventory or map\n        if (compatibleModuleDefs.Any()) {\n            var searchScope = ownerPawn != null\n                ? ownerPawn.inventory.innerContainer\n                : weapon.Map?.listerThings.AllThings ?? Enumerable.Empty<Thing>();\n\n            var availableModules = searchScope.Where(t =>\n                compatibleModuleDefs.Contains(t.def) &&\n                (ownerPawn != null || !t.IsForbidden(Faction.OfPlayer))\n            );\n\n            foreach (var module in availableModules) {\n                var trait = module.def.GetModExtension<TraitModuleExtension>().weaponTraitDef; // todo: fixme\n                installCandidates.TryAdd(trait, module.def);\n            }\n        }\n\n        // from stack\n        var stagedCompatibleTraits = _stagedUninstalls\n            .Where(trait => trait.TryGetPart(out var p) && p == part);\n        foreach (var trait in stagedCompatibleTraits) {\n            if (trait.TryGetModuleDef(out var moduleDef)) {\n                installCandidates.TryAdd(trait, moduleDef);\n            }\n        }\n\n        if (!installCandidates.Any()) {\n            options.Add(new FloatMenuOption(FailureReason, null));\n            return;\n        }\n\n        foreach (var (traitToInstall, _) in installCandidates) {\n            var installAction = CreateInstallAction(part, traitToInstall);\n            options.Add(new FloatMenuOption(traitToInstall.LabelCap, installAction));\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 36,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.Controllers.InteractionController.GetCompatibleModuleDefsFor(CWF.PartDef)",
      "M:Verse.GenCollection.Any``1",
      "M:System.Linq.Enumerable.Empty``1",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:System.Collections.Generic.HashSet`1.Contains(`0)",
      "M:RimWorld.ForbidUtility.IsForbidden(RimWorld.Faction)",
      "M:Verse.Def.GetModExtension``1",
      "M:System.Collections.Generic.Dictionary`2.TryAdd(`0,`1)",
      "M:CWF.ModuleDatabase.TryGetPart(CWF.PartDef@)",
      "M:CWF.ModuleDatabase.TryGetModuleDef(Verse.ThingDef@)",
      "M:System.Linq.Enumerable.Any``1",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:CWF.Controllers.InteractionController.CreateInstallAction(CWF.PartDef,RimWorld.WeaponTraitDef)",
      "M:System.Collections.Generic.Dictionary`2.#ctor",
      "M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})",
      "M:Verse.FloatMenuOption.#ctor(System.String,System.Action,Verse.MenuOptionPriority,System.Action{UnityEngine.Rect},Verse.Thing,System.Single,System.Func{UnityEngine.Rect,System.Boolean},RimWorld.Planet.WorldObject,System.Boolean,System.Int32)"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.HandleSlotClick(CWF.PartDef,RimWorld.WeaponTraitDef)"
    ]
  },
  {
    "id": "M:CWF.Controllers.InteractionController.HandleSlotClick(CWF.PartDef,RimWorld.WeaponTraitDef)",
    "name": "HandleSlotClick",
    "fullName": "CWF.Controllers.InteractionController.HandleSlotClick(CWF.PartDef, RimWorld.WeaponTraitDef?)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void HandleSlotClick(PartDef part, WeaponTraitDef? installedTrait) {\n        var options = new List<FloatMenuOption>();\n\n        if (installedTrait == null) {\n            BuildInstallOptions(part, options);\n        } else {\n            BuildUninstallOption(part, options, installedTrait);\n        }\n\n        if (Enumerable.Any(options)) {\n            Find.WindowStack.Add(new FloatMenu(options));\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 22,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.Controllers.InteractionController.BuildInstallOptions(CWF.PartDef,System.Collections.Generic.List{Verse.FloatMenuOption})",
      "M:CWF.Controllers.InteractionController.BuildUninstallOption(CWF.PartDef,System.Collections.Generic.List{Verse.FloatMenuOption},RimWorld.WeaponTraitDef)",
      "M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})",
      "M:Verse.WindowStack.Add(Verse.Window)",
      "M:System.Collections.Generic.List`1.#ctor",
      "M:Verse.FloatMenu.#ctor(System.Collections.Generic.List{Verse.FloatMenuOption})"
    ],
    "calledBy": []
  },
  {
    "id": "P:CWF.Controllers.InteractionController.FailureReason",
    "name": "FailureReason",
    "fullName": "CWF.Controllers.InteractionController.FailureReason",
    "type": "Property",
    "baseType": null,
    "codeBody": "private string FailureReason => weapon.ParentHolder is Pawn_EquipmentTracker\n        ? \"CWF_UI_NoCompatibleModulesInInventory\".Translate()\n        : \"CWF_UI_NoCompatibleModulesOnMap\".Translate();",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 14,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.Translator.Translate"],
    "calledBy": []
  },
  {
    "id": "T:CWF.Controllers.InteractionController",
    "name": "InteractionController",
    "fullName": "CWF.Controllers.InteractionController",
    "type": "Class",
    "baseType": null,
    "codeBody": "public class InteractionController(Thing weapon) {\n    private readonly CompDynamicTraits _compDynamicTraits = weapon.TryGetComp<CompDynamicTraits>();\n\n    private readonly List<WeaponTraitDef> _stagedUninstalls = [];\n\n    public event Action OnDataChanged = delegate { };\n\n    private string FailureReason => weapon.ParentHolder is Pawn_EquipmentTracker\n        ? \"CWF_UI_NoCompatibleModulesInInventory\".Translate()\n        : \"CWF_UI_NoCompatibleModulesOnMap\".Translate();\n\n    /// <summary>\n    /// Opens a float-menu for the clicked slot.  \n    /// If installedTrait is null, lists traits to install; otherwise offers to uninstall the installed trait.\n    /// </summary>\n    public void HandleSlotClick(PartDef part, WeaponTraitDef? installedTrait) {\n        var options = new List<FloatMenuOption>();\n\n        if (installedTrait == null) {\n            BuildInstallOptions(part, options);\n        } else {\n            BuildUninstallOption(part, options, installedTrait);\n        }\n\n        if (Enumerable.Any(options)) {\n            Find.WindowStack.Add(new FloatMenu(options));\n        }\n    }\n\n    private void BuildInstallOptions(PartDef part, List<FloatMenuOption> options) {\n        var installCandidates = new Dictionary<WeaponTraitDef, ThingDef>();\n\n        var compatibleModuleDefs = new HashSet<ThingDef>(GetCompatibleModuleDefsFor(part));\n\n        var ownerPawn = weapon.ParentHolder switch {\n            Pawn_EquipmentTracker equipment => equipment.pawn,\n            Pawn_InventoryTracker inventory => inventory.pawn,\n            _ => null\n        };\n\n        // from inventory or map\n        if (compatibleModuleDefs.Any()) {\n            var searchScope = ownerPawn != null\n                ? ownerPawn.inventory.innerContainer\n                : weapon.Map?.listerThings.AllThings ?? Enumerable.Empty<Thing>();\n\n            var availableModules = searchScope.Where(t =>\n                compatibleModuleDefs.Contains(t.def) &&\n                (ownerPawn != null || !t.IsForbidden(Faction.OfPlayer))\n            );\n\n            foreach (var module in availableModules) {\n                var trait = module.def.GetModExtension<TraitModuleExtension>().weaponTraitDef; // todo: fixme\n                installCandidates.TryAdd(trait, module.def);\n            }\n        }\n\n        // from stack\n        var stagedCompatibleTraits = _stagedUninstalls\n            .Where(trait => trait.TryGetPart(out var p) && p == part);\n        foreach (var trait in stagedCompatibleTraits) {\n            if (trait.TryGetModuleDef(out var moduleDef)) {\n                installCandidates.TryAdd(trait, moduleDef);\n            }\n        }\n\n        if (!installCandidates.Any()) {\n            options.Add(new FloatMenuOption(FailureReason, null));\n            return;\n        }\n\n        foreach (var (traitToInstall, _) in installCandidates) {\n            var installAction = CreateInstallAction(part, traitToInstall);\n            options.Add(new FloatMenuOption(traitToInstall.LabelCap, installAction));\n        }\n    }\n\n\n    private void BuildUninstallOption(PartDef part, List<FloatMenuOption> options, WeaponTraitDef installedTrait) {\n        options.Add(new FloatMenuOption(\"CWF_UI_Uninstall\".Translate(installedTrait.LabelCap), () => {\n            var analysis = AnalyzeUninstallConflict(part);\n            if (!analysis.HasConflict) {\n                DoUninstall(part);\n            } else {\n                ShowConfirmationDialog(\n                    \"CWF_UI_ConfirmUninstallTitle\".Translate(),\n                    \"CWF_UI_ConfirmUninstallBody\".Translate(\n                        installedTrait.LabelCap.Named(\"MODULE\"),\n                        analysis.ModulesToRemove\n                            .Select(t => \" - \" + t.LabelCap.ToString()).ToLineList()\n                            .Named(\"DEPENDENCIES\")\n                    ),\n                    () => {\n                        foreach (var dependencyTrait in analysis.ModulesToRemove) {\n                            if (dependencyTrait.TryGetPart(out var dependencyPart)) {\n                                DoUninstall(dependencyPart);\n                            }\n                        }\n\n                        DoUninstall(part);\n                    }\n                );\n            }\n        }));\n    }\n\n    private void DoInstall(PartDef part, WeaponTraitDef traitToInstall) {\n        _stagedUninstalls.Remove(traitToInstall);\n\n        _compDynamicTraits.InstallTrait(part, traitToInstall);\n        SoundDefOf.Tick_High.PlayOneShotOnCamera();\n        OnDataChanged();\n    }\n\n    private void DoUninstall(PartDef part) {\n        var traitToUninstall = _compDynamicTraits.GetInstalledTraitFor(part);\n        if (traitToUninstall != null) {\n            _stagedUninstalls.Add(traitToUninstall);\n        }\n\n        _compDynamicTraits.UninstallTrait(part);\n        SoundDefOf.Tick_High.PlayOneShotOnCamera();\n        OnDataChanged();\n    }\n\n    #region Helpers\n\n    private Action CreateInstallAction(PartDef part, WeaponTraitDef traitToInstall) {\n        return () => {\n            if (!traitToInstall.TryGetModuleDef(out var moduleDef)) {\n                DoInstall(part, traitToInstall);\n                return;\n            }\n\n            var analysis = AnalyzeInstallConflict(moduleDef);\n            if (!analysis.HasConflict) {\n                DoInstall(part, traitToInstall);\n                return;\n            }\n\n            ShowConfirmationDialog(\n                \"CWF_UI_ConfirmInstallTitle\".Translate(),\n                \"CWF_UI_ConfirmInstallBody\".Translate(\n                    traitToInstall.LabelCap.Named(\"MODULE\"),\n                    analysis.ModulesToRemove\n                        .Select(t => \" - \" + t.LabelCap.ToString()).ToLineList()\n                        .Named(\"CONFLICTS\")\n                ),\n                () => {\n                    foreach (var conflictTrait in analysis.ModulesToRemove) {\n                        if (conflictTrait.TryGetPart(out var conflictPart)) {\n                            DoUninstall(conflictPart);\n                        }\n                    }\n\n                    DoInstall(part, traitToInstall);\n                }\n            );\n        };\n    }\n\n    private ConflictAnalysisResult AnalyzeInstallConflict(ThingDef moduleToInstall) {\n        var result = new ConflictAnalysisResult();\n        var ext = moduleToInstall.GetModExtension<TraitModuleExtension>();\n        if (ext?.conditionalPartModifiers == null) return result;\n\n        var partsToDisable = new HashSet<PartDef>();\n        foreach (var rule in ext.conditionalPartModifiers) {\n            if (rule.matcher != null && rule.matcher.IsMatch(weapon.def)) {\n                partsToDisable.UnionWith(rule.disablesParts);\n            }\n        }\n\n        foreach (var part in partsToDisable) {\n            var conflictingTrait = _compDynamicTraits.GetInstalledTraitFor(part);\n            if (conflictingTrait != null) {\n                result.ModulesToRemove.Add(conflictingTrait);\n            }\n        }\n\n        return result;\n    }\n\n    private ConflictAnalysisResult AnalyzeUninstallConflict(PartDef partToUninstall) {\n        var result = new ConflictAnalysisResult();\n        var currentTraits = _compDynamicTraits.InstalledTraits;\n\n        if (!currentTraits.Remove(partToUninstall)) return result;\n\n        var futureAvailableParts = CalculateFutureAvailableParts(currentTraits.Values);\n\n        foreach (var (part, trait) in currentTraits) {\n            if (futureAvailableParts.Contains(part)) continue;\n\n            result.ModulesToRemove.Add(trait);\n        }\n\n        return result;\n    }\n\n    private HashSet<PartDef> CalculateFutureAvailableParts(IEnumerable<WeaponTraitDef> futureTraits) {\n        if (weapon.TryGetComp<CompDynamicTraits>()?.props is not CompProperties_DynamicTraits props) return [];\n\n        var availableParts = new HashSet<PartDef>(props.supportParts);\n\n        foreach (var traitDef in futureTraits) {\n            if (!traitDef.TryGetModuleDef(out var moduleDef)) continue;\n\n            var ext = moduleDef.GetModExtension<TraitModuleExtension>();\n            if (ext?.conditionalPartModifiers == null) continue;\n\n            foreach (var rule in ext.conditionalPartModifiers) {\n                if (rule.matcher == null || !rule.matcher.IsMatch(weapon.def)) continue;\n\n                availableParts.UnionWith(rule.enablesParts);\n                availableParts.ExceptWith(rule.disablesParts);\n            }\n        }\n\n        return availableParts;\n    }\n\n    private static void ShowConfirmationDialog(string title, string text, Action onConfirm) {\n        var dialog = new Dialog_MessageBox(\n            text,\n            \"Confirm\".Translate(), onConfirm,\n            \"Cancel\".Translate(), null,\n            title,\n            true, onConfirm\n        );\n        Find.WindowStack.Add(dialog);\n    }\n\n    private IEnumerable<ThingDef> GetCompatibleModuleDefsFor(PartDef part) {\n        return ModuleDatabase.AllModuleDefs\n            .Where(moduleDef => moduleDef.GetModExtension<TraitModuleExtension>().part == part)\n            .Where(moduleDef => moduleDef.IsCompatibleWith(weapon.def));\n    }\n\n    #endregion\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/InteractionController.cs",
    "startLine": 7,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.ViewDrawers.MainDrawer.DrawPartSlot(UnityEngine.Rect@,System.String)",
    "name": "DrawPartSlot",
    "fullName": "CWF.ViewDrawers.MainDrawer.DrawPartSlot(in UnityEngine.Rect, string)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static bool DrawPartSlot(in Rect rect, string label) {\n        Widgets.DrawOptionBackground(rect, Mouse.IsOver(rect));\n\n        // render label\n        var labelRect = new Rect(rect.x + 4f, rect.y + 2f, rect.width - 8f, rect.height - 3f);\n        UIKit.WithStyle(() => Widgets.Label(labelRect, label), GameFont.Tiny, Color.gray, TextAnchor.LowerLeft);\n\n        // render '+'\n        var inRect = rect;\n        UIKit.WithStyle(() => Widgets.Label(inRect, \"+\"), GameFont.Medium, anchor: TextAnchor.MiddleCenter);\n\n        return Widgets.ButtonInvisible(rect);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/MainDrawer.cs",
    "startLine": 151,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Widgets.DrawOptionBackground(UnityEngine.Rect,System.Boolean)",
      "M:Verse.Mouse.IsOver(UnityEngine.Rect)",
      "M:CWF.UIKit.WithStyle(System.Action,Verse.GameFont,System.Nullable{UnityEngine.Color},UnityEngine.TextAnchor)",
      "M:Verse.Widgets.Label(UnityEngine.Rect,System.String)",
      "M:Verse.Widgets.ButtonInvisible(UnityEngine.Rect,System.Boolean)",
      "M:UnityEngine.Rect.#ctor(System.Single,System.Single,System.Single,System.Single)"
    ],
    "calledBy": [
      "M:CWF.ViewDrawers.MainDrawer.TryDrawSlot(CWF.PartDef,UnityEngine.Rect@)"
    ]
  },
  {
    "id": "M:CWF.ViewDrawers.MainDrawer.DrawModuleTexture(UnityEngine.Rect@,CWF.ModuleGraphicData)",
    "name": "DrawModuleTexture",
    "fullName": "CWF.ViewDrawers.MainDrawer.DrawModuleTexture(in UnityEngine.Rect, CWF.ModuleGraphicData)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static void DrawModuleTexture(in Rect rect, ModuleGraphicData moduleGraphicData) {\n        // Outline\n        var outlineTexture = CompDynamicGraphic.GetOutlineTexture(moduleGraphicData);\n        if (outlineTexture != null) {\n            Widgets.DrawTextureFitted(rect, outlineTexture, 1f);\n        }\n\n        // module\n        var mainTexture = ContentFinder<Texture2D>.Get(moduleGraphicData.texturePath);\n        if (mainTexture != null) {\n            Widgets.DrawTextureFitted(rect, mainTexture, 1f);\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/MainDrawer.cs",
    "startLine": 136,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.CompDynamicGraphic.GetOutlineTexture(CWF.ModuleGraphicData)",
      "M:Verse.Widgets.DrawTextureFitted(UnityEngine.Rect,UnityEngine.Texture,System.Single,System.Single)",
      "M:Verse.ContentFinder`1.Get(System.String,System.Boolean)"
    ],
    "calledBy": [
      "M:CWF.ViewDrawers.MainDrawer.TryDrawSlot(CWF.PartDef,UnityEngine.Rect@)"
    ]
  },
  {
    "id": "M:CWF.ViewDrawers.MainDrawer.TryDrawSlot(CWF.PartDef,UnityEngine.Rect@)",
    "name": "TryDrawSlot",
    "fullName": "CWF.ViewDrawers.MainDrawer.TryDrawSlot(CWF.PartDef, in UnityEngine.Rect)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void TryDrawSlot(PartDef part, in Rect rect) {\n        if (_compDynamicTraits == null || !_compDynamicTraits.AvailableParts.Contains(part)) return;\n\n        var installedTrait = _compDynamicTraits.GetInstalledTraitFor(part);\n        bool clicked;\n\n        if (installedTrait != null) {\n            Widgets.DrawOptionBackground(rect, Mouse.IsOver(rect));\n\n            var moduleGraphicData = weapon.TryGetComp<CompDynamicGraphic>()?.GetGraphicDataFor(installedTrait);\n\n            if (moduleGraphicData != null && !moduleGraphicData.texturePath.IsNullOrEmpty()) {\n                DrawModuleTexture(in rect, moduleGraphicData);\n            } else {\n                var inRect = rect;\n                UIKit.WithStyle(() => Widgets.Label(inRect, installedTrait.LabelCap),\n                    GameFont.Tiny, anchor: TextAnchor.MiddleCenter);\n            }\n\n            var tipSb = new StringBuilder();\n            tipSb.AppendLine($\"<b>{installedTrait.LabelCap}</b>\");\n            tipSb.AppendLine(installedTrait.description);\n            tipSb.AppendInNewLine(installedTrait.GetTraitEffect());\n\n            TooltipHandler.TipRegion(rect, tipSb.ToString());\n\n            clicked = Widgets.ButtonInvisible(rect);\n        } else {\n            clicked = DrawPartSlot(in rect, part.LabelCap);\n        }\n\n        if (clicked) onSlotClick.Invoke(part, installedTrait);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/MainDrawer.cs",
    "startLine": 102,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.Contains``1(``0)",
      "M:CWF.CompDynamicTraits.GetInstalledTraitFor(CWF.PartDef)",
      "M:Verse.Widgets.DrawOptionBackground(UnityEngine.Rect,System.Boolean)",
      "M:Verse.Mouse.IsOver(UnityEngine.Rect)",
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:CWF.CompDynamicGraphic.GetGraphicDataFor(RimWorld.WeaponTraitDef)",
      "M:CWF.Extensions.Extensions.IsNullOrEmpty",
      "M:CWF.ViewDrawers.MainDrawer.DrawModuleTexture(UnityEngine.Rect@,CWF.ModuleGraphicData)",
      "M:CWF.UIKit.WithStyle(System.Action,Verse.GameFont,System.Nullable{UnityEngine.Color},UnityEngine.TextAnchor)",
      "M:Verse.Widgets.Label(UnityEngine.Rect,Verse.TaggedString)",
      "M:System.Text.StringBuilder.AppendLine(System.String)",
      "M:Verse.GenText.AppendInNewLine(System.String)",
      "M:CWF.ModuleDatabase.GetTraitEffect",
      "M:Verse.TooltipHandler.TipRegion(UnityEngine.Rect,Verse.TipSignal)",
      "M:System.Text.StringBuilder.ToString",
      "M:Verse.Widgets.ButtonInvisible(UnityEngine.Rect,System.Boolean)",
      "M:CWF.ViewDrawers.MainDrawer.DrawPartSlot(UnityEngine.Rect@,System.String)",
      "M:System.Action`2.Invoke(`0,`1)",
      "M:System.Text.StringBuilder.#ctor"
    ],
    "calledBy": [
      "M:CWF.ViewDrawers.MainDrawer.DrawPartGroup(UnityEngine.Rect@,System.Collections.Generic.List{CWF.PartDef},CWF.ViewDrawers.MainDrawer.Direction)"
    ]
  },
  {
    "id": "M:CWF.ViewDrawers.MainDrawer.DrawPartGroup(UnityEngine.Rect@,System.Collections.Generic.List{CWF.PartDef},CWF.ViewDrawers.MainDrawer.Direction)",
    "name": "DrawPartGroup",
    "fullName": "CWF.ViewDrawers.MainDrawer.DrawPartGroup(in UnityEngine.Rect, System.Collections.Generic.List<CWF.PartDef>, CWF.ViewDrawers.MainDrawer.Direction)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void DrawPartGroup(in Rect container, List<PartDef> groupParts, Direction direction) {\n        if (groupParts.Empty()) return;\n\n        var count = groupParts.Count;\n\n        if (direction == Direction.Horizontal) {\n            var totalWidth = count * SlotSize + Math.Max(0, count - 1) * SlotPadding;\n            var startX = container.center.x - totalWidth / 2f;\n            var startY = container.center.y - SlotSize / 2f;\n\n            for (var i = 0; i < count; i++) {\n                var part = groupParts[i];\n                var slotRect = new Rect(startX + i * (SlotSize + SlotPadding), startY, SlotSize, SlotSize);\n                TryDrawSlot(part, in slotRect);\n            }\n        } else {\n            // Vertical\n            var totalHeight = count * SlotSize + Math.Max(0, count - 1) * SlotPadding;\n            var startX = container.center.x - SlotSize / 2f;\n            var startY = container.center.y - totalHeight / 2f;\n\n            for (var i = 0; i < count; i++) {\n                var part = groupParts[i];\n                var slotRect = new Rect(startX, startY + i * (SlotSize + SlotPadding), SlotSize, SlotSize);\n                TryDrawSlot(part, in slotRect);\n            }\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/MainDrawer.cs",
    "startLine": 73,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.GenCollection.Empty``1",
      "M:System.Math.Max(System.Int32,System.Int32)",
      "M:CWF.ViewDrawers.MainDrawer.TryDrawSlot(CWF.PartDef,UnityEngine.Rect@)",
      "M:UnityEngine.Rect.#ctor(System.Single,System.Single,System.Single,System.Single)"
    ],
    "calledBy": ["M:CWF.ViewDrawers.MainDrawer.Draw(UnityEngine.Rect@)"]
  },
  {
    "id": "M:CWF.ViewDrawers.MainDrawer.Draw(UnityEngine.Rect@)",
    "name": "Draw",
    "fullName": "CWF.ViewDrawers.MainDrawer.Draw(in UnityEngine.Rect)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void Draw(in Rect rect) {\n        if (_compDynamicTraits == null) return;\n\n        // define gird row Height\n        const float topRowHeight = SlotSize + SlotPadding;\n        const float bottomRowHeight = SlotSize + SlotPadding;\n        var middleRowHeight = rect.height - topRowHeight - bottomRowHeight;\n\n        // define gird col with\n        const float leftColWidth = SlotSize + SlotPadding;\n        const float rightColWidth = SlotSize + SlotPadding;\n        var middleColWidth = rect.width - leftColWidth - rightColWidth;\n\n        if (middleRowHeight <= 0 || middleColWidth <= 0) return;\n\n        // define gird cell\n        var topCenterRect = new Rect(rect.x + leftColWidth, rect.y, middleColWidth, topRowHeight);\n        var middleLeftRect = new Rect(rect.x, rect.y + topRowHeight, leftColWidth, middleRowHeight);\n        var middleCenterRect =\n            new Rect(rect.x + leftColWidth, rect.y + topRowHeight, middleColWidth, middleRowHeight);\n        var middleRightRect = new Rect(rect.x + leftColWidth + middleColWidth, rect.y + topRowHeight, rightColWidth,\n            middleRowHeight);\n        var bottomCenterRect = new Rect(rect.x + leftColWidth, rect.y + topRowHeight + middleRowHeight,\n            middleColWidth, bottomRowHeight);\n\n        // define weapon icon\n        var weaponGraphic = weapon.Graphic;\n        var weaponAspect = weaponGraphic.drawSize.x / weaponGraphic.drawSize.y;\n        var iconWidth = middleCenterRect.width;\n        var iconHeight = middleCenterRect.height;\n        iconWidth = iconWidth / weaponAspect > iconHeight ? iconHeight * weaponAspect : iconWidth / weaponAspect;\n\n        // render weapon icon\n        var weaponIconRect = new Rect(middleCenterRect.center.x - iconWidth / 2f,\n            middleCenterRect.center.y - iconHeight / 2f, iconWidth, iconHeight);\n        Widgets.ThingIcon(weaponIconRect, weapon);\n\n        var availableParts = _compDynamicTraits.AvailableParts;\n\n        var topParts = availableParts.Where(p => p.group == PartGroup.Top).OrderBy(p => p.order).ToList();\n        var bottomParts = availableParts.Where(p => p.group == PartGroup.Bottom).OrderBy(p => p.order).ToList();\n        var leftParts = availableParts.Where(p => p.group == PartGroup.Left).OrderBy(p => p.order).ToList();\n        var rightParts = availableParts.Where(p => p.group == PartGroup.Right).OrderBy(p => p.order).ToList();\n\n        DrawPartGroup(in topCenterRect, topParts, Direction.Horizontal);\n        DrawPartGroup(in bottomCenterRect, bottomParts, Direction.Horizontal);\n        DrawPartGroup(in middleLeftRect, leftParts, Direction.Horizontal);\n        DrawPartGroup(in middleRightRect, rightParts, Direction.Vertical);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/MainDrawer.cs",
    "startLine": 22,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Widgets.ThingIcon(UnityEngine.Rect,Verse.Thing,System.Single,System.Nullable{Verse.Rot4},System.Boolean,System.Single,System.Boolean)",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.OrderBy``2(System.Func{``0,``1})",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:CWF.ViewDrawers.MainDrawer.DrawPartGroup(UnityEngine.Rect@,System.Collections.Generic.List{CWF.PartDef},CWF.ViewDrawers.MainDrawer.Direction)",
      "M:UnityEngine.Rect.#ctor(System.Single,System.Single,System.Single,System.Single)"
    ],
    "calledBy": ["M:CWF.WeaponWindow.DoWindowContents(UnityEngine.Rect)"]
  },
  {
    "id": "T:CWF.ViewDrawers.MainDrawer.Direction",
    "name": "Direction",
    "fullName": "CWF.ViewDrawers.MainDrawer.Direction",
    "type": "Enum",
    "baseType": null,
    "codeBody": "private enum Direction {\n        Horizontal,\n        Vertical\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/MainDrawer.cs",
    "startLine": 17,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.ViewDrawers.MainDrawer",
    "name": "MainDrawer",
    "fullName": "CWF.ViewDrawers.MainDrawer",
    "type": "Class",
    "baseType": null,
    "codeBody": "public class MainDrawer(Thing weapon, Action<PartDef, WeaponTraitDef?> onSlotClick) {\n    // Data source\n    private readonly CompDynamicTraits? _compDynamicTraits = weapon.TryGetComp<CompDynamicTraits>();\n\n    // private readonly Thing _weapon = weapon;\n    private const float SlotSize = 56f;\n    private const float SlotPadding = 12f;\n\n    private enum Direction {\n        Horizontal,\n        Vertical\n    }\n\n    public void Draw(in Rect rect) {\n        if (_compDynamicTraits == null) return;\n\n        // define gird row Height\n        const float topRowHeight = SlotSize + SlotPadding;\n        const float bottomRowHeight = SlotSize + SlotPadding;\n        var middleRowHeight = rect.height - topRowHeight - bottomRowHeight;\n\n        // define gird col with\n        const float leftColWidth = SlotSize + SlotPadding;\n        const float rightColWidth = SlotSize + SlotPadding;\n        var middleColWidth = rect.width - leftColWidth - rightColWidth;\n\n        if (middleRowHeight <= 0 || middleColWidth <= 0) return;\n\n        // define gird cell\n        var topCenterRect = new Rect(rect.x + leftColWidth, rect.y, middleColWidth, topRowHeight);\n        var middleLeftRect = new Rect(rect.x, rect.y + topRowHeight, leftColWidth, middleRowHeight);\n        var middleCenterRect =\n            new Rect(rect.x + leftColWidth, rect.y + topRowHeight, middleColWidth, middleRowHeight);\n        var middleRightRect = new Rect(rect.x + leftColWidth + middleColWidth, rect.y + topRowHeight, rightColWidth,\n            middleRowHeight);\n        var bottomCenterRect = new Rect(rect.x + leftColWidth, rect.y + topRowHeight + middleRowHeight,\n            middleColWidth, bottomRowHeight);\n\n        // define weapon icon\n        var weaponGraphic = weapon.Graphic;\n        var weaponAspect = weaponGraphic.drawSize.x / weaponGraphic.drawSize.y;\n        var iconWidth = middleCenterRect.width;\n        var iconHeight = middleCenterRect.height;\n        iconWidth = iconWidth / weaponAspect > iconHeight ? iconHeight * weaponAspect : iconWidth / weaponAspect;\n\n        // render weapon icon\n        var weaponIconRect = new Rect(middleCenterRect.center.x - iconWidth / 2f,\n            middleCenterRect.center.y - iconHeight / 2f, iconWidth, iconHeight);\n        Widgets.ThingIcon(weaponIconRect, weapon);\n\n        var availableParts = _compDynamicTraits.AvailableParts;\n\n        var topParts = availableParts.Where(p => p.group == PartGroup.Top).OrderBy(p => p.order).ToList();\n        var bottomParts = availableParts.Where(p => p.group == PartGroup.Bottom).OrderBy(p => p.order).ToList();\n        var leftParts = availableParts.Where(p => p.group == PartGroup.Left).OrderBy(p => p.order).ToList();\n        var rightParts = availableParts.Where(p => p.group == PartGroup.Right).OrderBy(p => p.order).ToList();\n\n        DrawPartGroup(in topCenterRect, topParts, Direction.Horizontal);\n        DrawPartGroup(in bottomCenterRect, bottomParts, Direction.Horizontal);\n        DrawPartGroup(in middleLeftRect, leftParts, Direction.Horizontal);\n        DrawPartGroup(in middleRightRect, rightParts, Direction.Vertical);\n    }\n\n    // === Helper ===\n    private void DrawPartGroup(in Rect container, List<PartDef> groupParts, Direction direction) {\n        if (groupParts.Empty()) return;\n\n        var count = groupParts.Count;\n\n        if (direction == Direction.Horizontal) {\n            var totalWidth = count * SlotSize + Math.Max(0, count - 1) * SlotPadding;\n            var startX = container.center.x - totalWidth / 2f;\n            var startY = container.center.y - SlotSize / 2f;\n\n            for (var i = 0; i < count; i++) {\n                var part = groupParts[i];\n                var slotRect = new Rect(startX + i * (SlotSize + SlotPadding), startY, SlotSize, SlotSize);\n                TryDrawSlot(part, in slotRect);\n            }\n        } else {\n            // Vertical\n            var totalHeight = count * SlotSize + Math.Max(0, count - 1) * SlotPadding;\n            var startX = container.center.x - SlotSize / 2f;\n            var startY = container.center.y - totalHeight / 2f;\n\n            for (var i = 0; i < count; i++) {\n                var part = groupParts[i];\n                var slotRect = new Rect(startX, startY + i * (SlotSize + SlotPadding), SlotSize, SlotSize);\n                TryDrawSlot(part, in slotRect);\n            }\n        }\n    }\n\n    private void TryDrawSlot(PartDef part, in Rect rect) {\n        if (_compDynamicTraits == null || !_compDynamicTraits.AvailableParts.Contains(part)) return;\n\n        var installedTrait = _compDynamicTraits.GetInstalledTraitFor(part);\n        bool clicked;\n\n        if (installedTrait != null) {\n            Widgets.DrawOptionBackground(rect, Mouse.IsOver(rect));\n\n            var moduleGraphicData = weapon.TryGetComp<CompDynamicGraphic>()?.GetGraphicDataFor(installedTrait);\n\n            if (moduleGraphicData != null && !moduleGraphicData.texturePath.IsNullOrEmpty()) {\n                DrawModuleTexture(in rect, moduleGraphicData);\n            } else {\n                var inRect = rect;\n                UIKit.WithStyle(() => Widgets.Label(inRect, installedTrait.LabelCap),\n                    GameFont.Tiny, anchor: TextAnchor.MiddleCenter);\n            }\n\n            var tipSb = new StringBuilder();\n            tipSb.AppendLine($\"<b>{installedTrait.LabelCap}</b>\");\n            tipSb.AppendLine(installedTrait.description);\n            tipSb.AppendInNewLine(installedTrait.GetTraitEffect());\n\n            TooltipHandler.TipRegion(rect, tipSb.ToString());\n\n            clicked = Widgets.ButtonInvisible(rect);\n        } else {\n            clicked = DrawPartSlot(in rect, part.LabelCap);\n        }\n\n        if (clicked) onSlotClick.Invoke(part, installedTrait);\n    }\n\n    private static void DrawModuleTexture(in Rect rect, ModuleGraphicData moduleGraphicData) {\n        // Outline\n        var outlineTexture = CompDynamicGraphic.GetOutlineTexture(moduleGraphicData);\n        if (outlineTexture != null) {\n            Widgets.DrawTextureFitted(rect, outlineTexture, 1f);\n        }\n\n        // module\n        var mainTexture = ContentFinder<Texture2D>.Get(moduleGraphicData.texturePath);\n        if (mainTexture != null) {\n            Widgets.DrawTextureFitted(rect, mainTexture, 1f);\n        }\n    }\n\n    /// Returns a boolean indicating whether the element was clicked.\n    private static bool DrawPartSlot(in Rect rect, string label) {\n        Widgets.DrawOptionBackground(rect, Mouse.IsOver(rect));\n\n        // render label\n        var labelRect = new Rect(rect.x + 4f, rect.y + 2f, rect.width - 8f, rect.height - 3f);\n        UIKit.WithStyle(() => Widgets.Label(labelRect, label), GameFont.Tiny, Color.gray, TextAnchor.LowerLeft);\n\n        // render '+'\n        var inRect = rect;\n        UIKit.WithStyle(() => Widgets.Label(inRect, \"+\"), GameFont.Medium, anchor: TextAnchor.MiddleCenter);\n\n        return Widgets.ButtonInvisible(rect);\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/MainDrawer.cs",
    "startLine": 9,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.Controllers.JobDispatcher.FindBestPawnForJob(Verse.IntVec3,Verse.Map)",
    "name": "FindBestPawnForJob",
    "fullName": "CWF.Controllers.JobDispatcher.FindBestPawnForJob(Verse.IntVec3, Verse.Map)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static Pawn? FindBestPawnForJob(IntVec3 jobLocation, Map map) {\n        return map.mapPawns.FreeColonistsSpawned\n            .Where(p => !p.Downed && !p.Drafted && p.workSettings.WorkIsActive(WorkTypeDefOf.Crafting) &&\n                        p.health.capacities.CanBeAwake)\n            .OrderBy(p => p.Position.DistanceToSquared(jobLocation))\n            .FirstOrFallback();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/JobDispatcher.cs",
    "startLine": 145,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.GenCollection.FirstOrFallback``1(``0)",
      "M:System.Linq.Enumerable.OrderBy``2(System.Func{``0,``1})",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:RimWorld.Pawn_WorkSettings.WorkIsActive(Verse.WorkTypeDef)",
      "M:Verse.IntVec3Utility.DistanceToSquared(Verse.IntVec3)"
    ],
    "calledBy": [
      "M:CWF.Controllers.JobDispatcher.DispatchHaulModificationJob(System.Collections.Generic.List{CWF.ModificationData})"
    ]
  },
  {
    "id": "M:CWF.Controllers.JobDispatcher.FindBestAvailableModuleFor(CWF.ModificationData,Verse.Pawn)",
    "name": "FindBestAvailableModuleFor",
    "fullName": "CWF.Controllers.JobDispatcher.FindBestAvailableModuleFor(CWF.ModificationData, Verse.Pawn)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private Thing? FindBestAvailableModuleFor(ModificationData change, Pawn pawn) {\n        if (change.Type != ModificationType.Install) return null;\n\n        return GenClosest.ClosestThingReachable(\n            _weapon.Position,\n            _weapon.Map,\n            ThingRequest.ForDef(change.ModuleDef),\n            PathEndMode.ClosestTouch,\n            TraverseParms.For(pawn),\n            validator: t => !t.IsForbidden(pawn) && !t.IsBurning() && pawn.CanReserve(t)\n        );\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/JobDispatcher.cs",
    "startLine": 132,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.GenClosest.ClosestThingReachable(Verse.IntVec3,Verse.Map,Verse.ThingRequest,Verse.AI.PathEndMode,Verse.TraverseParms,System.Single,System.Predicate{Verse.Thing},System.Collections.Generic.IEnumerable{Verse.Thing},System.Int32,System.Int32,System.Boolean,Verse.RegionType,System.Boolean,System.Boolean)",
      "M:Verse.ThingRequest.ForDef(Verse.ThingDef)",
      "M:Verse.TraverseParms.For(Verse.Pawn,Verse.Danger,Verse.TraverseMode,System.Boolean,System.Boolean,System.Boolean,System.Boolean)",
      "M:RimWorld.ForbidUtility.IsForbidden(Verse.Pawn)",
      "M:RimWorld.FireUtility.IsBurning",
      "M:Verse.AI.ReservationUtility.CanReserve(Verse.LocalTargetInfo,System.Int32,System.Int32,Verse.ReservationLayerDef,System.Boolean)"
    ],
    "calledBy": [
      "M:CWF.Controllers.JobDispatcher.DispatchHaulModificationJob(System.Collections.Generic.List{CWF.ModificationData})"
    ]
  },
  {
    "id": "M:CWF.Controllers.JobDispatcher.CalculateNetChanges(System.Collections.Generic.Dictionary{CWF.PartDef,RimWorld.WeaponTraitDef},System.Collections.Generic.Dictionary{CWF.PartDef,RimWorld.WeaponTraitDef})",
    "name": "CalculateNetChanges",
    "fullName": "CWF.Controllers.JobDispatcher.CalculateNetChanges(System.Collections.Generic.Dictionary<CWF.PartDef, RimWorld.WeaponTraitDef>, System.Collections.Generic.Dictionary<CWF.PartDef, RimWorld.WeaponTraitDef>)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static List<ModificationData> CalculateNetChanges(Dictionary<PartDef, WeaponTraitDef> initial,\n        Dictionary<PartDef, WeaponTraitDef> final) {\n        var changes = new List<ModificationData>();\n        var allParts = DefDatabase<PartDef>.AllDefs;\n        \n        foreach (var part in allParts) {\n            initial.TryGetValue(part, out var initialTrait);\n            final.TryGetValue(part, out var finalTrait);\n            if (initialTrait == finalTrait) continue;\n\n            if (initialTrait != null && initialTrait.TryGetModuleDef(out var uninstallModule)) {\n                changes.Add(new ModificationData {\n                    Type = ModificationType.Uninstall,\n                    Part = part,\n                    Trait = initialTrait,\n                    ModuleDef = uninstallModule\n                });\n            }\n\n            if (finalTrait != null && finalTrait.TryGetModuleDef(out var installModule)) {\n                changes.Add(new ModificationData {\n                    Type = ModificationType.Install,\n                    Part = part,\n                    Trait = finalTrait,\n                    ModuleDef = installModule\n                });\n            }\n        }\n\n        return changes.OrderBy(c => c.Type).ToList();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/JobDispatcher.cs",
    "startLine": 100,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)",
      "M:CWF.ModuleDatabase.TryGetModuleDef(Verse.ThingDef@)",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.OrderBy``2(System.Func{``0,``1})",
      "M:System.Collections.Generic.List`1.#ctor",
      "M:CWF.ModificationData.#ctor"
    ],
    "calledBy": ["M:CWF.Controllers.JobDispatcher.CommitChangesAndDispatchJobs"]
  },
  {
    "id": "M:CWF.Controllers.JobDispatcher.DispatchHaulModificationJob(System.Collections.Generic.List{CWF.ModificationData})",
    "name": "DispatchHaulModificationJob",
    "fullName": "CWF.Controllers.JobDispatcher.DispatchHaulModificationJob(System.Collections.Generic.List<CWF.ModificationData>)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void DispatchHaulModificationJob(List<ModificationData> netChanges) {\n        var bestPawn = FindBestPawnForJob(_weapon.Position, _weapon.Map);\n        if (bestPawn == null) {\n            Messages.Message(\"CWF_Message_NoColonistToModifyWeapon\".Translate(), MessageTypeDefOf.NeutralEvent, false);\n            return;\n        }\n\n        var modulesToHaul = new List<Thing>();\n        var installChanges = netChanges\n            .Where(c => c.Type == ModificationType.Install)\n            .ToList();\n\n        foreach (var change in installChanges) {\n            var module = FindBestAvailableModuleFor(change, bestPawn);\n            if (module == null) {\n                Messages.Message(\"CWF_Message_CannotFindModuleForModification\"\n                        .Translate(change.ModuleDef.Named(\"MODULE\")),\n                    MessageTypeDefOf.RejectInput, false);\n                return;\n            }\n\n            modulesToHaul.Add(module);\n        }\n\n        // create a big job merged all modification\n        var job = JobMaker.MakeJob(DefDatabase<JobDef>.GetNamed(\"CWF_ModifyWeaponHaul\"), _weapon);\n\n        // fill queue only when it needs haul\n        if (Enumerable.Any(modulesToHaul)) {\n            job.targetQueueB = modulesToHaul.Select(t => new LocalTargetInfo(t)).ToList();\n        }\n\n        // Package all modification data into the job source\n        job.source = new JobGiver_ModifyWeapon { ModDataList = netChanges };\n\n        bestPawn.jobs.jobQueue.EnqueueLast(job, JobTag.Misc);\n\n        // gracefully end the current job.\n        if (bestPawn.CurJob != null && bestPawn.CurJob.def != JobDefOf.Wait_Wander) {\n            bestPawn.jobs.EndCurrentJob(JobCondition.InterruptForced);\n        }\n\n        Messages.Message(\"CWF_Message_ModificationJobDispatched\"\n                .Translate(bestPawn.Named(\"PAWN\"), _weapon.Named(\"WEAPON\")),\n            new LookTargets(bestPawn, _weapon), MessageTypeDefOf.PositiveEvent);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/JobDispatcher.cs",
    "startLine": 53,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.Controllers.JobDispatcher.FindBestPawnForJob(Verse.IntVec3,Verse.Map)",
      "M:Verse.Messages.Message(System.String,Verse.MessageTypeDef,System.Boolean)",
      "M:Verse.Translator.Translate",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:CWF.Controllers.JobDispatcher.FindBestAvailableModuleFor(CWF.ModificationData,Verse.Pawn)",
      "M:Verse.TranslatorFormattedStringExtensions.Translate(Verse.NamedArgument)",
      "M:Verse.NamedArgumentUtility.Named(System.String)",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:Verse.JobMaker.MakeJob(Verse.JobDef,Verse.LocalTargetInfo)",
      "M:Verse.DefDatabase`1.GetNamed(System.String,System.Boolean)",
      "M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})",
      "M:System.Linq.Enumerable.Select``2(System.Func{``0,``1})",
      "M:Verse.AI.JobQueue.EnqueueLast(Verse.AI.Job,System.Nullable{Verse.AI.JobTag})",
      "M:Verse.AI.Pawn_JobTracker.EndCurrentJob(Verse.AI.JobCondition,System.Boolean,System.Boolean)",
      "M:Verse.Messages.Message(System.String,Verse.LookTargets,Verse.MessageTypeDef,System.Boolean)",
      "M:Verse.TranslatorFormattedStringExtensions.Translate(Verse.NamedArgument,Verse.NamedArgument)",
      "M:System.Collections.Generic.List`1.#ctor",
      "M:Verse.LocalTargetInfo.#ctor(Verse.Thing)",
      "M:CWF.JobGiver_ModifyWeapon.#ctor",
      "M:Verse.LookTargets.#ctor(Verse.TargetInfo[])"
    ],
    "calledBy": ["M:CWF.Controllers.JobDispatcher.CommitChangesAndDispatchJobs"]
  },
  {
    "id": "M:CWF.Controllers.JobDispatcher.DispatchFieldModificationJobs(Verse.Pawn,System.Collections.Generic.List{CWF.ModificationData})",
    "name": "DispatchFieldModificationJobs",
    "fullName": "CWF.Controllers.JobDispatcher.DispatchFieldModificationJobs(Verse.Pawn, System.Collections.Generic.List<CWF.ModificationData>)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void DispatchFieldModificationJobs(Pawn ownerPawn, List<ModificationData> netChanges) {\n        foreach (var change in netChanges) {\n            var job = JobMaker.MakeJob(DefDatabase<JobDef>.GetNamed(\"CWF_ModifyWeaponSelf\"), _weapon);\n            job.source = new JobGiver_ModifyWeapon { ModDataList = [change] };\n            ownerPawn.jobs.jobQueue.EnqueueLast(job, JobTag.Misc);\n        }\n\n        if (ownerPawn.CurJob == null) return;\n\n        ownerPawn.jobs.EndCurrentJob(JobCondition.InterruptForced);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/JobDispatcher.cs",
    "startLine": 41,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.JobMaker.MakeJob(Verse.JobDef,Verse.LocalTargetInfo)",
      "M:Verse.DefDatabase`1.GetNamed(System.String,System.Boolean)",
      "M:Verse.AI.JobQueue.EnqueueLast(Verse.AI.Job,System.Nullable{Verse.AI.JobTag})",
      "M:Verse.AI.Pawn_JobTracker.EndCurrentJob(Verse.AI.JobCondition,System.Boolean,System.Boolean)",
      "M:CWF.JobGiver_ModifyWeapon.#ctor"
    ],
    "calledBy": ["M:CWF.Controllers.JobDispatcher.CommitChangesAndDispatchJobs"]
  },
  {
    "id": "M:CWF.Controllers.JobDispatcher.CommitChangesAndDispatchJobs",
    "name": "CommitChangesAndDispatchJobs",
    "fullName": "CWF.Controllers.JobDispatcher.CommitChangesAndDispatchJobs()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void CommitChangesAndDispatchJobs() {\n        var finalTraitsState = _compDynamicTraits.InstalledTraits;\n        _compDynamicTraits.InstalledTraits = _initialTraitsState; // revert traits state, before commit\n\n        var netChanges = CalculateNetChanges(_initialTraitsState, finalTraitsState);\n        if (!Enumerable.Any(netChanges)) return;\n\n        var ownerPawn = _weapon.ParentHolder switch {\n            Pawn_EquipmentTracker equipment => equipment.pawn,\n            Pawn_InventoryTracker inventory => inventory.pawn,\n            _ => null\n        };\n\n        if (ownerPawn != null) {\n            // Equip\n            DispatchFieldModificationJobs(ownerPawn, netChanges);\n        } else {\n            // Ground\n            DispatchHaulModificationJob(netChanges);\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/JobDispatcher.cs",
    "startLine": 18,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.Controllers.JobDispatcher.CalculateNetChanges(System.Collections.Generic.Dictionary{CWF.PartDef,RimWorld.WeaponTraitDef},System.Collections.Generic.Dictionary{CWF.PartDef,RimWorld.WeaponTraitDef})",
      "M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})",
      "M:CWF.Controllers.JobDispatcher.DispatchFieldModificationJobs(Verse.Pawn,System.Collections.Generic.List{CWF.ModificationData})",
      "M:CWF.Controllers.JobDispatcher.DispatchHaulModificationJob(System.Collections.Generic.List{CWF.ModificationData})"
    ],
    "calledBy": ["M:CWF.WeaponWindow.PostClose"]
  },
  {
    "id": "M:CWF.Controllers.JobDispatcher.#ctor(Verse.Thing)",
    "name": ".ctor",
    "fullName": "CWF.Controllers.JobDispatcher.JobDispatcher(Verse.Thing)",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public JobDispatcher(Thing weapon) {\n        _weapon = weapon;\n        _compDynamicTraits = weapon.TryGetComp<CompDynamicTraits>();\n        _initialTraitsState = _compDynamicTraits.InstalledTraits;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/JobDispatcher.cs",
    "startLine": 12,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.ThingCompUtility.TryGetComp``1"],
    "calledBy": ["M:CWF.WeaponWindow.#ctor(Verse.Thing)"]
  },
  {
    "id": "T:CWF.Controllers.JobDispatcher",
    "name": "JobDispatcher",
    "fullName": "CWF.Controllers.JobDispatcher",
    "type": "Class",
    "baseType": null,
    "codeBody": "public class JobDispatcher {\n    private readonly Thing _weapon;\n    private readonly CompDynamicTraits _compDynamicTraits;\n    private readonly Dictionary<PartDef, WeaponTraitDef> _initialTraitsState;\n\n    public JobDispatcher(Thing weapon) {\n        _weapon = weapon;\n        _compDynamicTraits = weapon.TryGetComp<CompDynamicTraits>();\n        _initialTraitsState = _compDynamicTraits.InstalledTraits;\n    }\n\n    public void CommitChangesAndDispatchJobs() {\n        var finalTraitsState = _compDynamicTraits.InstalledTraits;\n        _compDynamicTraits.InstalledTraits = _initialTraitsState; // revert traits state, before commit\n\n        var netChanges = CalculateNetChanges(_initialTraitsState, finalTraitsState);\n        if (!Enumerable.Any(netChanges)) return;\n\n        var ownerPawn = _weapon.ParentHolder switch {\n            Pawn_EquipmentTracker equipment => equipment.pawn,\n            Pawn_InventoryTracker inventory => inventory.pawn,\n            _ => null\n        };\n\n        if (ownerPawn != null) {\n            // Equip\n            DispatchFieldModificationJobs(ownerPawn, netChanges);\n        } else {\n            // Ground\n            DispatchHaulModificationJob(netChanges);\n        }\n    }\n\n    // === Helper ===\n    private void DispatchFieldModificationJobs(Pawn ownerPawn, List<ModificationData> netChanges) {\n        foreach (var change in netChanges) {\n            var job = JobMaker.MakeJob(DefDatabase<JobDef>.GetNamed(\"CWF_ModifyWeaponSelf\"), _weapon);\n            job.source = new JobGiver_ModifyWeapon { ModDataList = [change] };\n            ownerPawn.jobs.jobQueue.EnqueueLast(job, JobTag.Misc);\n        }\n\n        if (ownerPawn.CurJob == null) return;\n\n        ownerPawn.jobs.EndCurrentJob(JobCondition.InterruptForced);\n    }\n\n    private void DispatchHaulModificationJob(List<ModificationData> netChanges) {\n        var bestPawn = FindBestPawnForJob(_weapon.Position, _weapon.Map);\n        if (bestPawn == null) {\n            Messages.Message(\"CWF_Message_NoColonistToModifyWeapon\".Translate(), MessageTypeDefOf.NeutralEvent, false);\n            return;\n        }\n\n        var modulesToHaul = new List<Thing>();\n        var installChanges = netChanges\n            .Where(c => c.Type == ModificationType.Install)\n            .ToList();\n\n        foreach (var change in installChanges) {\n            var module = FindBestAvailableModuleFor(change, bestPawn);\n            if (module == null) {\n                Messages.Message(\"CWF_Message_CannotFindModuleForModification\"\n                        .Translate(change.ModuleDef.Named(\"MODULE\")),\n                    MessageTypeDefOf.RejectInput, false);\n                return;\n            }\n\n            modulesToHaul.Add(module);\n        }\n\n        // create a big job merged all modification\n        var job = JobMaker.MakeJob(DefDatabase<JobDef>.GetNamed(\"CWF_ModifyWeaponHaul\"), _weapon);\n\n        // fill queue only when it needs haul\n        if (Enumerable.Any(modulesToHaul)) {\n            job.targetQueueB = modulesToHaul.Select(t => new LocalTargetInfo(t)).ToList();\n        }\n\n        // Package all modification data into the job source\n        job.source = new JobGiver_ModifyWeapon { ModDataList = netChanges };\n\n        bestPawn.jobs.jobQueue.EnqueueLast(job, JobTag.Misc);\n\n        // gracefully end the current job.\n        if (bestPawn.CurJob != null && bestPawn.CurJob.def != JobDefOf.Wait_Wander) {\n            bestPawn.jobs.EndCurrentJob(JobCondition.InterruptForced);\n        }\n\n        Messages.Message(\"CWF_Message_ModificationJobDispatched\"\n                .Translate(bestPawn.Named(\"PAWN\"), _weapon.Named(\"WEAPON\")),\n            new LookTargets(bestPawn, _weapon), MessageTypeDefOf.PositiveEvent);\n    }\n\n    private static List<ModificationData> CalculateNetChanges(Dictionary<PartDef, WeaponTraitDef> initial,\n        Dictionary<PartDef, WeaponTraitDef> final) {\n        var changes = new List<ModificationData>();\n        var allParts = DefDatabase<PartDef>.AllDefs;\n        \n        foreach (var part in allParts) {\n            initial.TryGetValue(part, out var initialTrait);\n            final.TryGetValue(part, out var finalTrait);\n            if (initialTrait == finalTrait) continue;\n\n            if (initialTrait != null && initialTrait.TryGetModuleDef(out var uninstallModule)) {\n                changes.Add(new ModificationData {\n                    Type = ModificationType.Uninstall,\n                    Part = part,\n                    Trait = initialTrait,\n                    ModuleDef = uninstallModule\n                });\n            }\n\n            if (finalTrait != null && finalTrait.TryGetModuleDef(out var installModule)) {\n                changes.Add(new ModificationData {\n                    Type = ModificationType.Install,\n                    Part = part,\n                    Trait = finalTrait,\n                    ModuleDef = installModule\n                });\n            }\n        }\n\n        return changes.OrderBy(c => c.Type).ToList();\n    }\n\n    private Thing? FindBestAvailableModuleFor(ModificationData change, Pawn pawn) {\n        if (change.Type != ModificationType.Install) return null;\n\n        return GenClosest.ClosestThingReachable(\n            _weapon.Position,\n            _weapon.Map,\n            ThingRequest.ForDef(change.ModuleDef),\n            PathEndMode.ClosestTouch,\n            TraverseParms.For(pawn),\n            validator: t => !t.IsForbidden(pawn) && !t.IsBurning() && pawn.CanReserve(t)\n        );\n    }\n\n    private static Pawn? FindBestPawnForJob(IntVec3 jobLocation, Map map) {\n        return map.mapPawns.FreeColonistsSpawned\n            .Where(p => !p.Downed && !p.Drafted && p.workSettings.WorkIsActive(WorkTypeDefOf.Crafting) &&\n                        p.health.capacities.CanBeAwake)\n            .OrderBy(p => p.Position.DistanceToSquared(jobLocation))\n            .FirstOrFallback();\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Controllers/JobDispatcher.cs",
    "startLine": 7,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.AbilityState.ExposeData",
    "name": "ExposeData",
    "fullName": "CWF.AbilityState.ExposeData()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void ExposeData() {\n        Scribe_Values.Look(ref defName, \"defName\");\n        Scribe_Values.Look(ref remainingCharges, \"remainingCharges\", -1);\n        Scribe_Values.Look(ref cooldownTicksRemaining, \"cooldownTicksRemaining\");\n        Scribe_Values.Look(ref cooldownTicksTotal, \"cooldownTicksTotal\");\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 269,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Scribe_Values.Look``1(``0@,System.String,``0,System.Boolean)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.AbilityState.#ctor(RimWorld.Ability)",
    "name": ".ctor",
    "fullName": "CWF.AbilityState.AbilityState(RimWorld.Ability)",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public AbilityState(Ability ability) {\n        defName = ability.def.defName;\n        remainingCharges = ability.RemainingCharges;\n        cooldownTicksRemaining = ability.CooldownTicksRemaining;\n        cooldownTicksTotal = ability.CooldownTicksTotal;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 262,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": ["M:CWF.CompAbilityProvider.PostExposeData"]
  },
  {
    "id": "M:CWF.AbilityState.#ctor",
    "name": ".ctor",
    "fullName": "CWF.AbilityState.AbilityState()",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public AbilityState() { }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 260,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.AbilityState",
    "name": "AbilityState",
    "fullName": "CWF.AbilityState",
    "type": "Class",
    "baseType": null,
    "codeBody": "public class AbilityState : IExposable {\n    public string? defName;\n    public int remainingCharges;\n    public int cooldownTicksRemaining;\n    public int cooldownTicksTotal;\n\n    public AbilityState() { }\n\n    public AbilityState(Ability ability) {\n        defName = ability.def.defName;\n        remainingCharges = ability.RemainingCharges;\n        cooldownTicksRemaining = ability.CooldownTicksRemaining;\n        cooldownTicksTotal = ability.CooldownTicksTotal;\n    }\n\n    public void ExposeData() {\n        Scribe_Values.Look(ref defName, \"defName\");\n        Scribe_Values.Look(ref remainingCharges, \"remainingCharges\", -1);\n        Scribe_Values.Look(ref cooldownTicksRemaining, \"cooldownTicksRemaining\");\n        Scribe_Values.Look(ref cooldownTicksTotal, \"cooldownTicksTotal\");\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 254,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": ["IExposable"],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompAbilityProvider.CanBeReloadedWith(Verse.ThingDef)",
    "name": "CanBeReloadedWith",
    "fullName": "CWF.CompAbilityProvider.CanBeReloadedWith(Verse.ThingDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public bool CanBeReloadedWith(ThingDef ammoDef) {\n        return _managedAbilities.Keys.Any(ability => {\n            var abilityProps = _managedAbilities[ability] as CompProperties_EquippableAbilityReloadable;\n            return abilityProps?.ammoDef == ammoDef && ability.RemainingCharges < ability.maxCharges;\n        });\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 246,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.Any``1(System.Func{``0,System.Boolean})"
    ],
    "calledBy": [
      "M:CWF.HarmonyPatches.Postfix_FloatMenuOptionProvider_Reload_GetReloadablesUsingAmmo.Postfix(System.Collections.Generic.IEnumerable{RimWorld.Utility.IReloadableComp},Verse.Pawn,Verse.Thing)"
    ]
  },
  {
    "id": "M:CWF.CompAbilityProvider.DisabledReason(System.Int32,System.Int32)",
    "name": "DisabledReason",
    "fullName": "CWF.CompAbilityProvider.DisabledReason(int, int)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public string DisabledReason(int minNeeded, int maxNeeded) {\n        return AmmoDef == null\n            // Caller guarantees non-null context by checking FirstReloadableAbility first.\n            ? \"CommandReload_NoCharges\".Translate(ReloadableProps!.ChargeNounArgument)\n            : \"CommandReload_NoAmmo\".Translate(ReloadableProps!.ChargeNounArgument, AmmoDef.Named(\"AMMO\"),\n                minNeeded.Named(\"COUNT\"));\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 235,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.TranslatorFormattedStringExtensions.Translate(Verse.NamedArgument)",
      "M:Verse.TranslatorFormattedStringExtensions.Translate(Verse.NamedArgument,Verse.NamedArgument,Verse.NamedArgument)",
      "M:Verse.NamedArgumentUtility.Named(System.String)"
    ],
    "calledBy": ["M:CWF.CompAbilityProvider.CanBeUsed(System.String@)"]
  },
  {
    "id": "M:CWF.CompAbilityProvider.MaxAmmoAmount",
    "name": "MaxAmmoAmount",
    "fullName": "CWF.CompAbilityProvider.MaxAmmoAmount()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public int MaxAmmoAmount() {\n        var totalMaxAmmo = 0;\n\n        foreach (var ability in _managedAbilities.Keys) {\n            if (_managedAbilities[ability] is CompProperties_EquippableAbilityReloadable abilityProps) {\n                totalMaxAmmo += ability.maxCharges * abilityProps.ammoCountPerCharge;\n            }\n        }\n\n        return totalMaxAmmo;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 223,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompAbilityProvider.MaxAmmoNeeded(System.Boolean)",
    "name": "MaxAmmoNeeded",
    "fullName": "CWF.CompAbilityProvider.MaxAmmoNeeded(bool)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public int MaxAmmoNeeded(bool allowForcedReload) {\n        if (!NeedsReload(allowForcedReload)) return 0;\n\n        var totalAmmoNeeded = 0;\n        foreach (var ability in _managedAbilities.Keys) {\n            if (_managedAbilities[ability] is CompProperties_EquippableAbilityReloadable abilityProps &&\n                ability.RemainingCharges < ability.maxCharges) {\n                totalAmmoNeeded += (ability.maxCharges - ability.RemainingCharges) * abilityProps.ammoCountPerCharge;\n            }\n        }\n\n        return totalAmmoNeeded;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 209,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:CWF.CompAbilityProvider.NeedsReload(System.Boolean)"],
    "calledBy": ["M:CWF.CompAbilityProvider.CanBeUsed(System.String@)"]
  },
  {
    "id": "M:CWF.CompAbilityProvider.MinAmmoNeeded(System.Boolean)",
    "name": "MinAmmoNeeded",
    "fullName": "CWF.CompAbilityProvider.MinAmmoNeeded(bool)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public int MinAmmoNeeded(bool allowForcedReload) {\n        if (!NeedsReload(allowForcedReload)) return 0;\n\n        var ability = _managedAbilities.Keys.FirstOrDefault(a => a.RemainingCharges < a.maxCharges);\n        var abilityProps = ability != null\n            ? _managedAbilities[ability] as CompProperties_EquippableAbilityReloadable\n            : null;\n        return abilityProps?.ammoCountPerCharge ?? 0;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 199,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.CompAbilityProvider.NeedsReload(System.Boolean)",
      "M:System.Linq.Enumerable.FirstOrDefault``1(System.Func{``0,System.Boolean})"
    ],
    "calledBy": ["M:CWF.CompAbilityProvider.CanBeUsed(System.String@)"]
  },
  {
    "id": "M:CWF.CompAbilityProvider.ReloadFrom(Verse.Thing)",
    "name": "ReloadFrom",
    "fullName": "CWF.CompAbilityProvider.ReloadFrom(Verse.Thing)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void ReloadFrom(Thing ammo) {\n        var abilityToReload = _managedAbilities.Keys.FirstOrDefault(a => {\n            var targetProps = _managedAbilities[a] as CompProperties_EquippableAbilityReloadable;\n            return targetProps?.ammoDef == ammo.def && a.RemainingCharges < a.maxCharges;\n        });\n\n        if (abilityToReload == null) return;\n        if (_managedAbilities[abilityToReload] is not CompProperties_EquippableAbilityReloadable abilityProps) return;\n\n        var chargesToRefill = abilityToReload.maxCharges - abilityToReload.RemainingCharges;\n        var ammoPerCharge = abilityProps.ammoCountPerCharge;\n        if (ammoPerCharge <= 0) return;\n\n        var ammoNeeded = chargesToRefill * ammoPerCharge;\n        var ammoToConsume = Mathf.Min(ammo.stackCount, ammoNeeded);\n\n        var chargesGained = ammoToConsume / ammoPerCharge;\n        if (chargesGained <= 0) return;\n\n        ammo.SplitOff(chargesGained * ammoPerCharge).Destroy();\n        abilityToReload.RemainingCharges += chargesGained;\n        abilityProps.soundReload?.PlayOneShot(new TargetInfo(parent.Position, parent.Map));\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 175,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.FirstOrDefault``1(System.Func{``0,System.Boolean})",
      "M:UnityEngine.Mathf.Min(System.Int32,System.Int32)",
      "M:Verse.Thing.Destroy(Verse.DestroyMode)",
      "M:Verse.Thing.SplitOff(System.Int32)",
      "M:Verse.Sound.SoundStarter.PlayOneShot(Verse.Sound.SoundInfo)",
      "M:Verse.TargetInfo.#ctor(Verse.IntVec3,Verse.Map,System.Boolean)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompAbilityProvider.NeedsReload(System.Boolean)",
    "name": "NeedsReload",
    "fullName": "CWF.CompAbilityProvider.NeedsReload(bool)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public bool NeedsReload(bool allowForcedReload) {\n        return _managedAbilities.Keys.Any(a => {\n            if (_managedAbilities[a] is not CompProperties_EquippableAbilityReloadable) return false;\n            return allowForcedReload\n                ? a.RemainingCharges < a.maxCharges\n                : a.RemainingCharges <= 0;\n        });\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 166,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.Any``1(System.Func{``0,System.Boolean})"
    ],
    "calledBy": [
      "M:CWF.CompAbilityProvider.MaxAmmoNeeded(System.Boolean)",
      "M:CWF.CompAbilityProvider.MinAmmoNeeded(System.Boolean)"
    ]
  },
  {
    "id": "M:CWF.CompAbilityProvider.CanBeUsed(System.String@)",
    "name": "CanBeUsed",
    "fullName": "CWF.CompAbilityProvider.CanBeUsed(out string?)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public bool CanBeUsed(out string? reason) {\n        reason = null;\n        var ability = FirstReloadableAbility;\n        if (ability == null || ability.RemainingCharges > 0) return true;\n        reason = DisabledReason(MinAmmoNeeded(false), MaxAmmoNeeded(false));\n        return false;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 158,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.CompAbilityProvider.DisabledReason(System.Int32,System.Int32)",
      "M:CWF.CompAbilityProvider.MinAmmoNeeded(System.Boolean)",
      "M:CWF.CompAbilityProvider.MaxAmmoNeeded(System.Boolean)"
    ],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompAbilityProvider.LabelRemaining",
    "name": "LabelRemaining",
    "fullName": "CWF.CompAbilityProvider.LabelRemaining",
    "type": "Property",
    "baseType": null,
    "codeBody": "public string LabelRemaining => $\"{RemainingCharges} / {MaxCharges}\";",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 156,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompAbilityProvider.MaxCharges",
    "name": "MaxCharges",
    "fullName": "CWF.CompAbilityProvider.MaxCharges",
    "type": "Property",
    "baseType": null,
    "codeBody": "public int MaxCharges => FirstReloadableAbility?.maxCharges ?? 0;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 155,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompAbilityProvider.RemainingCharges",
    "name": "RemainingCharges",
    "fullName": "CWF.CompAbilityProvider.RemainingCharges",
    "type": "Property",
    "baseType": null,
    "codeBody": "public int RemainingCharges => FirstReloadableAbility?.RemainingCharges ?? 0;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 154,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompAbilityProvider.BaseReloadTicks",
    "name": "BaseReloadTicks",
    "fullName": "CWF.CompAbilityProvider.BaseReloadTicks",
    "type": "Property",
    "baseType": null,
    "codeBody": "public int BaseReloadTicks => ReloadableProps?.baseReloadTicks ?? 60;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 153,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompAbilityProvider.AmmoDef",
    "name": "AmmoDef",
    "fullName": "CWF.CompAbilityProvider.AmmoDef",
    "type": "Property",
    "baseType": null,
    "codeBody": "public ThingDef? AmmoDef => ReloadableProps?.ammoDef;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 152,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompAbilityProvider.ReloadableThing",
    "name": "ReloadableThing",
    "fullName": "CWF.CompAbilityProvider.ReloadableThing",
    "type": "Property",
    "baseType": null,
    "codeBody": "public Thing ReloadableThing => parent;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 151,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompAbilityProvider.ReloadableProps",
    "name": "ReloadableProps",
    "fullName": "CWF.CompAbilityProvider.ReloadableProps",
    "type": "Property",
    "baseType": null,
    "codeBody": "private CompProperties_EquippableAbilityReloadable? ReloadableProps =>\n        _managedAbilities.Values.OfType<CompProperties_EquippableAbilityReloadable>().FirstOrFallback();",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 148,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.GenCollection.FirstOrFallback``1(``0)",
      "M:System.Linq.Enumerable.OfType``1"
    ],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompAbilityProvider.FirstReloadableAbility",
    "name": "FirstReloadableAbility",
    "fullName": "CWF.CompAbilityProvider.FirstReloadableAbility",
    "type": "Property",
    "baseType": null,
    "codeBody": "private Ability? FirstReloadableAbility =>\n        _managedAbilities.Keys.FirstOrDefault(a =>\n            a.UsesCharges && _managedAbilities[a] is CompProperties_EquippableAbilityReloadable);",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 144,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.FirstOrDefault``1(System.Func{``0,System.Boolean})"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompAbilityProvider.PostExposeData",
    "name": "PostExposeData",
    "fullName": "CWF.CompAbilityProvider.PostExposeData()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void PostExposeData() {\n        base.PostExposeData();\n        Scribe_References.Look(ref _holder, \"holder\");\n\n        if (Scribe.mode is LoadSaveMode.Saving) {\n            var defNameList = _abilityPropsToManage\n                .Select(p => p.abilityDef.defName).ToList();\n            Scribe_Collections.Look(ref defNameList, \"abilityPropsToManageDefNames\", LookMode.Value);\n        }\n\n        if (Scribe.mode is LoadSaveMode.LoadingVars) {\n            List<string>? defNameList = null;\n            Scribe_Collections.Look(ref defNameList, \"abilityPropsToManageDefNames\", LookMode.Value);\n            if (defNameList != null) {\n                _abilityPropsToManage = [];\n                foreach (var defName in defNameList) {\n                    var trait = DefDatabase<WeaponTraitDef>.AllDefs\n                        .FirstOrFallback(t => t?.abilityProps?.abilityDef.defName == defName);\n                    if (trait != null) {\n                        _abilityPropsToManage.Add(trait.abilityProps);\n                    }\n                }\n            }\n        }\n\n        if (Scribe.mode is LoadSaveMode.Saving) {\n            var abilityStates = _managedAbilities.Keys.Select(ability => new AbilityState(ability)).ToList();\n            Scribe_Collections.Look(ref abilityStates, \"abilityStates\", LookMode.Deep);\n        }\n\n        if (Scribe.mode is LoadSaveMode.LoadingVars) {\n            Scribe_Collections.Look(ref _savedAbilityStates, \"abilityStates\", LookMode.Deep);\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 107,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingComp.PostExposeData",
      "M:Verse.Scribe_References.Look``1(``0@,System.String,System.Boolean)",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.Select``2(System.Func{``0,``1})",
      "M:Verse.Scribe_Collections.Look``1(System.Collections.Generic.List{``0}@,System.String,Verse.LookMode,System.Object[])",
      "M:Verse.GenCollection.FirstOrFallback``1(System.Func{``0,System.Boolean},``0)",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:CWF.AbilityState.#ctor(RimWorld.Ability)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompAbilityProvider.ApplyAbilityChanges(System.Boolean)",
    "name": "ApplyAbilityChanges",
    "fullName": "CWF.CompAbilityProvider.ApplyAbilityChanges(bool)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void ApplyAbilityChanges(bool isPostLoad) {\n        if (_holder == null) return;\n\n        var propsToAdd = new List<CompProperties_EquippableAbility>(_abilityPropsToManage);\n        var abilitiesToRemove = new List<Ability>();\n\n        foreach (var kvp in _managedAbilities) {\n            if (!_abilityPropsToManage.Contains(kvp.Value)) {\n                abilitiesToRemove.Add(kvp.Key);\n            } else {\n                propsToAdd.Remove(kvp.Value);\n            }\n        }\n\n        foreach (var ability in abilitiesToRemove) {\n            _holder.abilities.RemoveAbility(ability.def);\n            _managedAbilities.Remove(ability);\n        }\n\n        foreach (var abilityProps in propsToAdd) {\n            _holder.abilities.GainAbility(abilityProps.abilityDef);\n            var newAbility = _holder.abilities.GetAbility(abilityProps.abilityDef);\n            if (newAbility == null) continue;\n\n            _managedAbilities.Add(newAbility, abilityProps);\n\n            if (abilityProps is not CompProperties_EquippableAbilityReloadable reloadableProps) continue;\n\n            newAbility.maxCharges = reloadableProps.maxCharges;\n            var savedState = _savedAbilityStates?\n                .FirstOrFallback(s => s?.defName == newAbility.def.defName);\n\n            if (savedState != null) {\n                newAbility.RemainingCharges = savedState.remainingCharges;\n\n                if (savedState.cooldownTicksRemaining > 0) {\n                    var inCooldownField = AccessTools.Field(typeof(Ability), \"inCooldown\");\n                    var cooldownEndTickField = AccessTools.Field(typeof(Ability), \"cooldownEndTick\");\n                    var cooldownDurationField = AccessTools.Field(typeof(Ability), \"cooldownDuration\");\n\n                    inCooldownField.SetValue(newAbility, true);\n                    cooldownEndTickField.SetValue(newAbility, GenTicks.TicksGame + savedState.cooldownTicksRemaining);\n                    cooldownDurationField.SetValue(newAbility, savedState.cooldownTicksTotal);\n                }\n\n                _savedAbilityStates?.Remove(savedState);\n            } else if (!isPostLoad) {\n                newAbility.RemainingCharges = newAbility.maxCharges;\n            }\n        }\n\n        if (abilitiesToRemove.Any() || propsToAdd.Any()) {\n            _holder.abilities.Notify_TemporaryAbilitiesChanged();\n        }\n\n        if (isPostLoad) {\n            _savedAbilityStates = null;\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 47,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Collections.Generic.List`1.Contains(`0)",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:System.Collections.Generic.List`1.Remove(`0)",
      "M:RimWorld.Pawn_AbilityTracker.RemoveAbility(RimWorld.AbilityDef)",
      "M:System.Collections.Generic.Dictionary`2.Remove(`0)",
      "M:RimWorld.Pawn_AbilityTracker.GainAbility(RimWorld.AbilityDef)",
      "M:RimWorld.Pawn_AbilityTracker.GetAbility(RimWorld.AbilityDef,System.Boolean)",
      "M:System.Collections.Generic.Dictionary`2.Add(`0,`1)",
      "M:Verse.GenCollection.FirstOrFallback``1(System.Func{``0,System.Boolean},``0)",
      "M:HarmonyLib.AccessTools.Field(System.Type,System.String)",
      "M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)",
      "M:Verse.GenCollection.Any``1",
      "M:RimWorld.Pawn_AbilityTracker.Notify_TemporaryAbilitiesChanged",
      "M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})",
      "M:System.Collections.Generic.List`1.#ctor"
    ],
    "calledBy": [
      "M:CWF.CompAbilityProvider.OnEquipped(Verse.Pawn)",
      "M:CWF.CompAbilityProvider.SetOrUpdateAbilities(System.Collections.Generic.List{RimWorld.CompProperties_EquippableAbilityReloadable},System.Boolean)"
    ]
  },
  {
    "id": "M:CWF.CompAbilityProvider.OnUnequipped(Verse.Pawn)",
    "name": "OnUnequipped",
    "fullName": "CWF.CompAbilityProvider.OnUnequipped(Verse.Pawn)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void OnUnequipped(Pawn _) {\n        if (_holder == null) return;\n\n        foreach (var ability in _managedAbilities.Keys) {\n            _holder.abilities.RemoveAbility(ability.def);\n        }\n\n        _holder.abilities.Notify_TemporaryAbilitiesChanged();\n\n        _managedAbilities.Clear();\n        _holder = null;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 34,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:RimWorld.Pawn_AbilityTracker.RemoveAbility(RimWorld.AbilityDef)",
      "M:RimWorld.Pawn_AbilityTracker.Notify_TemporaryAbilitiesChanged",
      "M:System.Collections.Generic.Dictionary`2.Clear"
    ],
    "calledBy": [
      "M:CWF.HarmonyPatches.Postfix_ThingComp_Notify_Unequipped.Postfix(Verse.ThingComp,Verse.Pawn)"
    ]
  },
  {
    "id": "M:CWF.CompAbilityProvider.OnEquipped(Verse.Pawn)",
    "name": "OnEquipped",
    "fullName": "CWF.CompAbilityProvider.OnEquipped(Verse.Pawn?)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void OnEquipped(Pawn? pawn) {\n        if (pawn == null) return;\n\n        _holder = pawn;\n        _managedAbilities = new Dictionary<Ability, CompProperties_EquippableAbility>();\n        ApplyAbilityChanges(false);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 26,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.CompAbilityProvider.ApplyAbilityChanges(System.Boolean)",
      "M:System.Collections.Generic.Dictionary`2.#ctor"
    ],
    "calledBy": [
      "M:CWF.HarmonyPatches.Postfix_ThingComp_Notify_Equipped.Postfix(Verse.ThingComp,Verse.Pawn)"
    ]
  },
  {
    "id": "M:CWF.CompAbilityProvider.SetOrUpdateAbilities(System.Collections.Generic.List{RimWorld.CompProperties_EquippableAbilityReloadable},System.Boolean)",
    "name": "SetOrUpdateAbilities",
    "fullName": "CWF.CompAbilityProvider.SetOrUpdateAbilities(System.Collections.Generic.List<RimWorld.CompProperties_EquippableAbilityReloadable>, bool)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void SetOrUpdateAbilities(List<CompProperties_EquippableAbilityReloadable> newPropsList, bool isPostLoad) {\n        _abilityPropsToManage = newPropsList\n            .Cast<CompProperties_EquippableAbility>()\n            .ToList();\n\n        if (_holder != null) {\n            ApplyAbilityChanges(isPostLoad);\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 16,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.Cast``1",
      "M:CWF.CompAbilityProvider.ApplyAbilityChanges(System.Boolean)"
    ],
    "calledBy": ["M:CWF.CompDynamicTraits.SetupAbility(System.Boolean)"]
  },
  {
    "id": "T:CWF.CompAbilityProvider",
    "name": "CompAbilityProvider",
    "fullName": "CWF.CompAbilityProvider",
    "type": "Class",
    "baseType": "Verse.ThingComp",
    "codeBody": "public class CompAbilityProvider : ThingComp, IReloadableComp {\n    private Pawn? _holder;\n    private List<CompProperties_EquippableAbility> _abilityPropsToManage = [];\n    private Dictionary<Ability, CompProperties_EquippableAbility> _managedAbilities = new();\n    private List<AbilityState>? _savedAbilityStates = [];\n\n    public void SetOrUpdateAbilities(List<CompProperties_EquippableAbilityReloadable> newPropsList, bool isPostLoad) {\n        _abilityPropsToManage = newPropsList\n            .Cast<CompProperties_EquippableAbility>()\n            .ToList();\n\n        if (_holder != null) {\n            ApplyAbilityChanges(isPostLoad);\n        }\n    }\n\n    public void OnEquipped(Pawn? pawn) {\n        if (pawn == null) return;\n\n        _holder = pawn;\n        _managedAbilities = new Dictionary<Ability, CompProperties_EquippableAbility>();\n        ApplyAbilityChanges(false);\n    }\n\n    public void OnUnequipped(Pawn _) {\n        if (_holder == null) return;\n\n        foreach (var ability in _managedAbilities.Keys) {\n            _holder.abilities.RemoveAbility(ability.def);\n        }\n\n        _holder.abilities.Notify_TemporaryAbilitiesChanged();\n\n        _managedAbilities.Clear();\n        _holder = null;\n    }\n\n    private void ApplyAbilityChanges(bool isPostLoad) {\n        if (_holder == null) return;\n\n        var propsToAdd = new List<CompProperties_EquippableAbility>(_abilityPropsToManage);\n        var abilitiesToRemove = new List<Ability>();\n\n        foreach (var kvp in _managedAbilities) {\n            if (!_abilityPropsToManage.Contains(kvp.Value)) {\n                abilitiesToRemove.Add(kvp.Key);\n            } else {\n                propsToAdd.Remove(kvp.Value);\n            }\n        }\n\n        foreach (var ability in abilitiesToRemove) {\n            _holder.abilities.RemoveAbility(ability.def);\n            _managedAbilities.Remove(ability);\n        }\n\n        foreach (var abilityProps in propsToAdd) {\n            _holder.abilities.GainAbility(abilityProps.abilityDef);\n            var newAbility = _holder.abilities.GetAbility(abilityProps.abilityDef);\n            if (newAbility == null) continue;\n\n            _managedAbilities.Add(newAbility, abilityProps);\n\n            if (abilityProps is not CompProperties_EquippableAbilityReloadable reloadableProps) continue;\n\n            newAbility.maxCharges = reloadableProps.maxCharges;\n            var savedState = _savedAbilityStates?\n                .FirstOrFallback(s => s?.defName == newAbility.def.defName);\n\n            if (savedState != null) {\n                newAbility.RemainingCharges = savedState.remainingCharges;\n\n                if (savedState.cooldownTicksRemaining > 0) {\n                    var inCooldownField = AccessTools.Field(typeof(Ability), \"inCooldown\");\n                    var cooldownEndTickField = AccessTools.Field(typeof(Ability), \"cooldownEndTick\");\n                    var cooldownDurationField = AccessTools.Field(typeof(Ability), \"cooldownDuration\");\n\n                    inCooldownField.SetValue(newAbility, true);\n                    cooldownEndTickField.SetValue(newAbility, GenTicks.TicksGame + savedState.cooldownTicksRemaining);\n                    cooldownDurationField.SetValue(newAbility, savedState.cooldownTicksTotal);\n                }\n\n                _savedAbilityStates?.Remove(savedState);\n            } else if (!isPostLoad) {\n                newAbility.RemainingCharges = newAbility.maxCharges;\n            }\n        }\n\n        if (abilitiesToRemove.Any() || propsToAdd.Any()) {\n            _holder.abilities.Notify_TemporaryAbilitiesChanged();\n        }\n\n        if (isPostLoad) {\n            _savedAbilityStates = null;\n        }\n    }\n\n    public override void PostExposeData() {\n        base.PostExposeData();\n        Scribe_References.Look(ref _holder, \"holder\");\n\n        if (Scribe.mode is LoadSaveMode.Saving) {\n            var defNameList = _abilityPropsToManage\n                .Select(p => p.abilityDef.defName).ToList();\n            Scribe_Collections.Look(ref defNameList, \"abilityPropsToManageDefNames\", LookMode.Value);\n        }\n\n        if (Scribe.mode is LoadSaveMode.LoadingVars) {\n            List<string>? defNameList = null;\n            Scribe_Collections.Look(ref defNameList, \"abilityPropsToManageDefNames\", LookMode.Value);\n            if (defNameList != null) {\n                _abilityPropsToManage = [];\n                foreach (var defName in defNameList) {\n                    var trait = DefDatabase<WeaponTraitDef>.AllDefs\n                        .FirstOrFallback(t => t?.abilityProps?.abilityDef.defName == defName);\n                    if (trait != null) {\n                        _abilityPropsToManage.Add(trait.abilityProps);\n                    }\n                }\n            }\n        }\n\n        if (Scribe.mode is LoadSaveMode.Saving) {\n            var abilityStates = _managedAbilities.Keys.Select(ability => new AbilityState(ability)).ToList();\n            Scribe_Collections.Look(ref abilityStates, \"abilityStates\", LookMode.Deep);\n        }\n\n        if (Scribe.mode is LoadSaveMode.LoadingVars) {\n            Scribe_Collections.Look(ref _savedAbilityStates, \"abilityStates\", LookMode.Deep);\n        }\n    }\n\n    #region impl IReloadableComp\n\n    private Ability? FirstReloadableAbility =>\n        _managedAbilities.Keys.FirstOrDefault(a =>\n            a.UsesCharges && _managedAbilities[a] is CompProperties_EquippableAbilityReloadable);\n\n    private CompProperties_EquippableAbilityReloadable? ReloadableProps =>\n        _managedAbilities.Values.OfType<CompProperties_EquippableAbilityReloadable>().FirstOrFallback();\n\n    public Thing ReloadableThing => parent;\n    public ThingDef? AmmoDef => ReloadableProps?.ammoDef;\n    public int BaseReloadTicks => ReloadableProps?.baseReloadTicks ?? 60;\n    public int RemainingCharges => FirstReloadableAbility?.RemainingCharges ?? 0;\n    public int MaxCharges => FirstReloadableAbility?.maxCharges ?? 0;\n    public string LabelRemaining => $\"{RemainingCharges} / {MaxCharges}\";\n\n    public bool CanBeUsed(out string? reason) {\n        reason = null;\n        var ability = FirstReloadableAbility;\n        if (ability == null || ability.RemainingCharges > 0) return true;\n        reason = DisabledReason(MinAmmoNeeded(false), MaxAmmoNeeded(false));\n        return false;\n    }\n\n    public bool NeedsReload(bool allowForcedReload) {\n        return _managedAbilities.Keys.Any(a => {\n            if (_managedAbilities[a] is not CompProperties_EquippableAbilityReloadable) return false;\n            return allowForcedReload\n                ? a.RemainingCharges < a.maxCharges\n                : a.RemainingCharges <= 0;\n        });\n    }\n\n    public void ReloadFrom(Thing ammo) {\n        var abilityToReload = _managedAbilities.Keys.FirstOrDefault(a => {\n            var targetProps = _managedAbilities[a] as CompProperties_EquippableAbilityReloadable;\n            return targetProps?.ammoDef == ammo.def && a.RemainingCharges < a.maxCharges;\n        });\n\n        if (abilityToReload == null) return;\n        if (_managedAbilities[abilityToReload] is not CompProperties_EquippableAbilityReloadable abilityProps) return;\n\n        var chargesToRefill = abilityToReload.maxCharges - abilityToReload.RemainingCharges;\n        var ammoPerCharge = abilityProps.ammoCountPerCharge;\n        if (ammoPerCharge <= 0) return;\n\n        var ammoNeeded = chargesToRefill * ammoPerCharge;\n        var ammoToConsume = Mathf.Min(ammo.stackCount, ammoNeeded);\n\n        var chargesGained = ammoToConsume / ammoPerCharge;\n        if (chargesGained <= 0) return;\n\n        ammo.SplitOff(chargesGained * ammoPerCharge).Destroy();\n        abilityToReload.RemainingCharges += chargesGained;\n        abilityProps.soundReload?.PlayOneShot(new TargetInfo(parent.Position, parent.Map));\n    }\n\n    public int MinAmmoNeeded(bool allowForcedReload) {\n        if (!NeedsReload(allowForcedReload)) return 0;\n\n        var ability = _managedAbilities.Keys.FirstOrDefault(a => a.RemainingCharges < a.maxCharges);\n        var abilityProps = ability != null\n            ? _managedAbilities[ability] as CompProperties_EquippableAbilityReloadable\n            : null;\n        return abilityProps?.ammoCountPerCharge ?? 0;\n    }\n\n    public int MaxAmmoNeeded(bool allowForcedReload) {\n        if (!NeedsReload(allowForcedReload)) return 0;\n\n        var totalAmmoNeeded = 0;\n        foreach (var ability in _managedAbilities.Keys) {\n            if (_managedAbilities[ability] is CompProperties_EquippableAbilityReloadable abilityProps &&\n                ability.RemainingCharges < ability.maxCharges) {\n                totalAmmoNeeded += (ability.maxCharges - ability.RemainingCharges) * abilityProps.ammoCountPerCharge;\n            }\n        }\n\n        return totalAmmoNeeded;\n    }\n\n    public int MaxAmmoAmount() {\n        var totalMaxAmmo = 0;\n\n        foreach (var ability in _managedAbilities.Keys) {\n            if (_managedAbilities[ability] is CompProperties_EquippableAbilityReloadable abilityProps) {\n                totalMaxAmmo += ability.maxCharges * abilityProps.ammoCountPerCharge;\n            }\n        }\n\n        return totalMaxAmmo;\n    }\n\n    public string DisabledReason(int minNeeded, int maxNeeded) {\n        return AmmoDef == null\n            // Caller guarantees non-null context by checking FirstReloadableAbility first.\n            ? \"CommandReload_NoCharges\".Translate(ReloadableProps!.ChargeNounArgument)\n            : \"CommandReload_NoAmmo\".Translate(ReloadableProps!.ChargeNounArgument, AmmoDef.Named(\"AMMO\"),\n                minNeeded.Named(\"COUNT\"));\n    }\n\n    #endregion\n\n    // Helper\n    public bool CanBeReloadedWith(ThingDef ammoDef) {\n        return _managedAbilities.Keys.Any(ability => {\n            var abilityProps = _managedAbilities[ability] as CompProperties_EquippableAbilityReloadable;\n            return abilityProps?.ammoDef == ammoDef && ability.RemainingCharges < ability.maxCharges;\n        });\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompAbilityProvider.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": ["IReloadableComp"],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.ModuleDatabase.GetCompatibleWeaponDefsFor(Verse.ThingDef)",
    "name": "GetCompatibleWeaponDefsFor",
    "fullName": "CWF.ModuleDatabase.GetCompatibleWeaponDefsFor(Verse.ThingDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static IEnumerable<ThingDef> GetCompatibleWeaponDefsFor(ThingDef moduleDef) {\n        var ext = moduleDef.GetModExtension<TraitModuleExtension>();\n        if (ext == null) yield break;\n\n        var results = new HashSet<ThingDef>();\n\n        if (!ext.requiredWeaponDefs.IsNullOrEmpty()) {\n            results.AddRange(ext.requiredWeaponDefs);\n        }\n\n        if (!ext.requiredWeaponTags.IsNullOrEmpty()) {\n            foreach (var tag in ext.requiredWeaponTags) {\n                if (WeaponsByTag.TryGetValue(tag, out var weapons)) {\n                    results.AddRange(weapons);\n                }\n            }\n        }\n\n        if (!ext.excludeWeaponDefs.IsNullOrEmpty()) {\n            results.ExceptWith(ext.excludeWeaponDefs);\n        }\n\n        if (!ext.excludeWeaponTags.IsNullOrEmpty()) {\n            foreach (var tag in ext.excludeWeaponTags) {\n                if (WeaponsByTag.TryGetValue(tag, out var weaponsToExclude)) {\n                    results.ExceptWith(weaponsToExclude);\n                }\n            }\n        }\n\n        foreach (var weaponDef in results) {\n            yield return weaponDef;\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/ModuleDatabase.cs",
    "startLine": 152,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Def.GetModExtension``1",
      "M:CWF.Extensions.Extensions.IsNullOrEmpty``1",
      "M:Verse.GenCollection.AddRange``1(System.Collections.Generic.List{``0})",
      "M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)",
      "M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})",
      "M:System.Collections.Generic.HashSet`1.#ctor"
    ],
    "calledBy": ["M:CWF.ModuleDatabase.BuildCacheAndInject"]
  },
  {
    "id": "M:CWF.ModuleDatabase.IsCompatibleWith(Verse.ThingDef,Verse.ThingDef)",
    "name": "IsCompatibleWith",
    "fullName": "CWF.ModuleDatabase.IsCompatibleWith(Verse.ThingDef, Verse.ThingDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "internal static bool IsCompatibleWith(this ThingDef moduleDef, ThingDef weaponDef) {\n        var ext = moduleDef.GetModExtension<TraitModuleExtension>();\n        if (ext == null) return false;\n\n        // exclude first \n        if (ext.excludeWeaponDefs != null && ext.excludeWeaponDefs.Contains(weaponDef)) {\n            return false;\n        }\n\n        if (!ext.excludeWeaponTags.IsNullOrEmpty() && !weaponDef.weaponTags.IsNullOrEmpty() &&\n            ext.excludeWeaponTags.Any(t => weaponDef.weaponTags.Contains(t))) {\n            return false;\n        }\n\n        // defs\n        if (!ext.requiredWeaponDefs.IsNullOrEmpty() && ext.requiredWeaponDefs.Contains(weaponDef)) {\n            return true;\n        }\n\n        // tags\n        if (!ext.requiredWeaponTags.IsNullOrEmpty() && !weaponDef.weaponTags.IsNullOrEmpty() &&\n            ext.requiredWeaponTags.Any(tag => weaponDef.weaponTags.Contains(tag))) {\n            return true;\n        }\n\n        return ext.requiredWeaponDefs.IsNullOrEmpty() && ext.requiredWeaponTags.IsNullOrEmpty();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/ModuleDatabase.cs",
    "startLine": 122,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Def.GetModExtension``1",
      "M:System.Collections.Generic.List`1.Contains(`0)",
      "M:CWF.Extensions.Extensions.IsNullOrEmpty``1",
      "M:Verse.GenCollection.Any``1(System.Predicate{``0})"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.ModuleDatabase.TryGetModuleDef(RimWorld.WeaponTraitDef,Verse.ThingDef@)",
    "name": "TryGetModuleDef",
    "fullName": "CWF.ModuleDatabase.TryGetModuleDef(RimWorld.WeaponTraitDef, out Verse.ThingDef?)",
    "type": "Method",
    "baseType": null,
    "codeBody": "internal static bool TryGetModuleDef(this WeaponTraitDef traitDef, [NotNullWhen(true)] out ThingDef? moduleDef) {\n        return TraitToModule.TryGetValue(traitDef, out moduleDef);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/ModuleDatabase.cs",
    "startLine": 118,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)"],
    "calledBy": []
  },
  {
    "id": "M:CWF.ModuleDatabase.TryGetPart(RimWorld.WeaponTraitDef,CWF.PartDef@)",
    "name": "TryGetPart",
    "fullName": "CWF.ModuleDatabase.TryGetPart(RimWorld.WeaponTraitDef, out CWF.PartDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "internal static bool TryGetPart(this WeaponTraitDef traitDef, out PartDef part) {\n        return TraitToPart.TryGetValue(traitDef, out part);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/ModuleDatabase.cs",
    "startLine": 114,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)"],
    "calledBy": []
  },
  {
    "id": "M:CWF.ModuleDatabase.BuildCacheAndInject",
    "name": "BuildCacheAndInject",
    "fullName": "CWF.ModuleDatabase.BuildCacheAndInject()",
    "type": "Method",
    "baseType": null,
    "codeBody": "internal static void BuildCacheAndInject() {\n        foreach (var thingDef in DefDatabase<ThingDef>.AllDefs) {\n            // fill weapon caches\n            if (thingDef.IsWeapon && !thingDef.weaponTags.IsNullOrEmpty() && thingDef.race == null &&\n                !thingDef.IsCorpse) {\n                foreach (var tag in thingDef.weaponTags) {\n                    if (!WeaponsByTag.ContainsKey(tag)) {\n                        WeaponsByTag[tag] = [];\n                    }\n\n                    WeaponsByTag[tag].Add(thingDef);\n                }\n            }\n\n            var ext = thingDef.GetModExtension<TraitModuleExtension>();\n            if (ext?.weaponTraitDef == null) continue;\n\n            // fill trait caches\n            if (TraitToPart.ContainsKey(ext.weaponTraitDef)) {\n                Log.Warning(\n                    $\"[CWF] Cache building warning: WeaponTraitDef '{ext.weaponTraitDef.defName}' is defined by multiple TraitModules. \" +\n                    $\"The one in '{thingDef.defName}' will overwrite previous entries. This may cause unpredictable behavior when uninstalling parts.\");\n            }\n\n            TraitToPart[ext.weaponTraitDef] = ext.part;\n            TraitToModule[ext.weaponTraitDef] = thingDef;\n        }\n\n        foreach (var moduleDef in TraitToModule.Values) {\n            // inject description\n            var traitDef = moduleDef.GetModExtension<TraitModuleExtension>()?.weaponTraitDef;\n            if (traitDef?.description != null) {\n                moduleDef.description = traitDef.description;\n            }\n\n            // inject hyperlinks\n            var weaponDefs = GetCompatibleWeaponDefsFor(moduleDef).ToList();\n            if (weaponDefs.Empty()) continue;\n\n            moduleDef.descriptionHyperlinks ??= [];\n            foreach (var weaponDef in weaponDefs) {\n                if (moduleDef.descriptionHyperlinks.Any(h => h.def == weaponDef)) continue;\n\n                moduleDef.descriptionHyperlinks.Add(new DefHyperlink(weaponDef));\n            }\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/ModuleDatabase.cs",
    "startLine": 66,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.Extensions.Extensions.IsNullOrEmpty``1",
      "M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:Verse.Def.GetModExtension``1",
      "M:Verse.Log.Warning(System.String)",
      "M:System.Linq.Enumerable.ToList``1",
      "M:CWF.ModuleDatabase.GetCompatibleWeaponDefsFor(Verse.ThingDef)",
      "M:Verse.GenCollection.Empty``1",
      "M:Verse.GenCollection.Any``1(System.Predicate{``0})",
      "M:Verse.DefHyperlink.#ctor(Verse.Def)"
    ],
    "calledBy": ["M:CWF.CustomizeWeaponFramework.#cctor"]
  },
  {
    "id": "M:CWF.ModuleDatabase.GetTraitEffect(RimWorld.WeaponTraitDef)",
    "name": "GetTraitEffect",
    "fullName": "CWF.ModuleDatabase.GetTraitEffect(RimWorld.WeaponTraitDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "internal static string GetTraitEffect(this WeaponTraitDef traitDef) {\n        var sb = new StringBuilder();\n\n        // offset\n        if (!traitDef.statOffsets.IsNullOrEmpty()) {\n            foreach (var modifier in traitDef.statOffsets) {\n                if (modifier.stat == StatDefOf.MarketValue || modifier.stat == StatDefOf.Mass) continue;\n\n                sb.AppendLine($\" - {modifier.stat.LabelCap}: \" +\n                              modifier.stat.Worker.ValueToString(modifier.value, false, ToStringNumberSense.Offset));\n            }\n        }\n\n        // factor\n        if (!traitDef.statFactors.IsNullOrEmpty()) {\n            foreach (var modifier in traitDef.statFactors) {\n                sb.AppendLine($\" - {modifier.stat.LabelCap}: \" +\n                              modifier.stat.Worker.ValueToString(modifier.value, false, ToStringNumberSense.Factor));\n            }\n        }\n\n        if (!Mathf.Approximately(traitDef.burstShotCountMultiplier, 1f)) {\n            sb.AppendLine($\" - {\"CWF_UI_BurstShotCountMultiplier\".Translate()}: \" +\n                          traitDef.burstShotCountMultiplier.ToStringByStyle(ToStringStyle.PercentZero,\n                              ToStringNumberSense.Factor));\n        }\n\n        if (!Mathf.Approximately(traitDef.burstShotSpeedMultiplier, 1f)) {\n            sb.AppendLine($\" - {\"CWF_UI_BurstShotSpeedMultiplier\".Translate()}: \" +\n                          traitDef.burstShotSpeedMultiplier.ToStringByStyle(ToStringStyle.PercentZero,\n                              ToStringNumberSense.Factor));\n        }\n\n        if (!Mathf.Approximately(traitDef.additionalStoppingPower, 0.0f)) {\n            sb.AppendLine($\" - {\"CWF_UI_AdditionalStoppingPower\".Translate()}: \" +\n                          traitDef.additionalStoppingPower.ToStringByStyle(ToStringStyle.FloatOne,\n                              ToStringNumberSense.Offset));\n        }\n\n        // equippedStat\n        if (!traitDef.equippedStatOffsets.IsNullOrEmpty()) {\n            foreach (var modifier in traitDef.equippedStatOffsets) {\n                sb.AppendLine($\" - {modifier.stat.LabelCap}: {modifier.stat.ValueToString(modifier.value)}\");\n            }\n        }\n\n        return sb.ToString();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/ModuleDatabase.cs",
    "startLine": 17,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.Extensions.Extensions.IsNullOrEmpty``1",
      "M:System.Text.StringBuilder.AppendLine(System.String)",
      "M:RimWorld.StatWorker.ValueToString(System.Single,System.Boolean,Verse.ToStringNumberSense)",
      "M:UnityEngine.Mathf.Approximately(System.Single,System.Single)",
      "M:Verse.Translator.Translate",
      "M:Verse.GenText.ToStringByStyle(Verse.ToStringStyle,Verse.ToStringNumberSense)",
      "M:RimWorld.StatDef.ValueToString(System.Single,Verse.ToStringNumberSense,System.Boolean)",
      "M:System.Text.StringBuilder.ToString",
      "M:System.Text.StringBuilder.#ctor"
    ],
    "calledBy": []
  },
  {
    "id": "P:CWF.ModuleDatabase.AllModuleDefs",
    "name": "AllModuleDefs",
    "fullName": "CWF.ModuleDatabase.AllModuleDefs",
    "type": "Property",
    "baseType": null,
    "codeBody": "public static IEnumerable<ThingDef> AllModuleDefs => TraitToModule.Values;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/ModuleDatabase.cs",
    "startLine": 15,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.ModuleDatabase",
    "name": "ModuleDatabase",
    "fullName": "CWF.ModuleDatabase",
    "type": "Class",
    "baseType": null,
    "codeBody": "public static class ModuleDatabase {\n    private static readonly Dictionary<WeaponTraitDef, PartDef> TraitToPart = new();\n    private static readonly Dictionary<WeaponTraitDef, ThingDef> TraitToModule = new();\n    private static readonly Dictionary<string, List<ThingDef>> WeaponsByTag = new();\n\n    public static IEnumerable<ThingDef> AllModuleDefs => TraitToModule.Values;\n\n    internal static string GetTraitEffect(this WeaponTraitDef traitDef) {\n        var sb = new StringBuilder();\n\n        // offset\n        if (!traitDef.statOffsets.IsNullOrEmpty()) {\n            foreach (var modifier in traitDef.statOffsets) {\n                if (modifier.stat == StatDefOf.MarketValue || modifier.stat == StatDefOf.Mass) continue;\n\n                sb.AppendLine($\" - {modifier.stat.LabelCap}: \" +\n                              modifier.stat.Worker.ValueToString(modifier.value, false, ToStringNumberSense.Offset));\n            }\n        }\n\n        // factor\n        if (!traitDef.statFactors.IsNullOrEmpty()) {\n            foreach (var modifier in traitDef.statFactors) {\n                sb.AppendLine($\" - {modifier.stat.LabelCap}: \" +\n                              modifier.stat.Worker.ValueToString(modifier.value, false, ToStringNumberSense.Factor));\n            }\n        }\n\n        if (!Mathf.Approximately(traitDef.burstShotCountMultiplier, 1f)) {\n            sb.AppendLine($\" - {\"CWF_UI_BurstShotCountMultiplier\".Translate()}: \" +\n                          traitDef.burstShotCountMultiplier.ToStringByStyle(ToStringStyle.PercentZero,\n                              ToStringNumberSense.Factor));\n        }\n\n        if (!Mathf.Approximately(traitDef.burstShotSpeedMultiplier, 1f)) {\n            sb.AppendLine($\" - {\"CWF_UI_BurstShotSpeedMultiplier\".Translate()}: \" +\n                          traitDef.burstShotSpeedMultiplier.ToStringByStyle(ToStringStyle.PercentZero,\n                              ToStringNumberSense.Factor));\n        }\n\n        if (!Mathf.Approximately(traitDef.additionalStoppingPower, 0.0f)) {\n            sb.AppendLine($\" - {\"CWF_UI_AdditionalStoppingPower\".Translate()}: \" +\n                          traitDef.additionalStoppingPower.ToStringByStyle(ToStringStyle.FloatOne,\n                              ToStringNumberSense.Offset));\n        }\n\n        // equippedStat\n        if (!traitDef.equippedStatOffsets.IsNullOrEmpty()) {\n            foreach (var modifier in traitDef.equippedStatOffsets) {\n                sb.AppendLine($\" - {modifier.stat.LabelCap}: {modifier.stat.ValueToString(modifier.value)}\");\n            }\n        }\n\n        return sb.ToString();\n    }\n\n    internal static void BuildCacheAndInject() {\n        foreach (var thingDef in DefDatabase<ThingDef>.AllDefs) {\n            // fill weapon caches\n            if (thingDef.IsWeapon && !thingDef.weaponTags.IsNullOrEmpty() && thingDef.race == null &&\n                !thingDef.IsCorpse) {\n                foreach (var tag in thingDef.weaponTags) {\n                    if (!WeaponsByTag.ContainsKey(tag)) {\n                        WeaponsByTag[tag] = [];\n                    }\n\n                    WeaponsByTag[tag].Add(thingDef);\n                }\n            }\n\n            var ext = thingDef.GetModExtension<TraitModuleExtension>();\n            if (ext?.weaponTraitDef == null) continue;\n\n            // fill trait caches\n            if (TraitToPart.ContainsKey(ext.weaponTraitDef)) {\n                Log.Warning(\n                    $\"[CWF] Cache building warning: WeaponTraitDef '{ext.weaponTraitDef.defName}' is defined by multiple TraitModules. \" +\n                    $\"The one in '{thingDef.defName}' will overwrite previous entries. This may cause unpredictable behavior when uninstalling parts.\");\n            }\n\n            TraitToPart[ext.weaponTraitDef] = ext.part;\n            TraitToModule[ext.weaponTraitDef] = thingDef;\n        }\n\n        foreach (var moduleDef in TraitToModule.Values) {\n            // inject description\n            var traitDef = moduleDef.GetModExtension<TraitModuleExtension>()?.weaponTraitDef;\n            if (traitDef?.description != null) {\n                moduleDef.description = traitDef.description;\n            }\n\n            // inject hyperlinks\n            var weaponDefs = GetCompatibleWeaponDefsFor(moduleDef).ToList();\n            if (weaponDefs.Empty()) continue;\n\n            moduleDef.descriptionHyperlinks ??= [];\n            foreach (var weaponDef in weaponDefs) {\n                if (moduleDef.descriptionHyperlinks.Any(h => h.def == weaponDef)) continue;\n\n                moduleDef.descriptionHyperlinks.Add(new DefHyperlink(weaponDef));\n            }\n        }\n    }\n\n    internal static bool TryGetPart(this WeaponTraitDef traitDef, out PartDef part) {\n        return TraitToPart.TryGetValue(traitDef, out part);\n    }\n\n    internal static bool TryGetModuleDef(this WeaponTraitDef traitDef, [NotNullWhen(true)] out ThingDef? moduleDef) {\n        return TraitToModule.TryGetValue(traitDef, out moduleDef);\n    }\n\n    internal static bool IsCompatibleWith(this ThingDef moduleDef, ThingDef weaponDef) {\n        var ext = moduleDef.GetModExtension<TraitModuleExtension>();\n        if (ext == null) return false;\n\n        // exclude first \n        if (ext.excludeWeaponDefs != null && ext.excludeWeaponDefs.Contains(weaponDef)) {\n            return false;\n        }\n\n        if (!ext.excludeWeaponTags.IsNullOrEmpty() && !weaponDef.weaponTags.IsNullOrEmpty() &&\n            ext.excludeWeaponTags.Any(t => weaponDef.weaponTags.Contains(t))) {\n            return false;\n        }\n\n        // defs\n        if (!ext.requiredWeaponDefs.IsNullOrEmpty() && ext.requiredWeaponDefs.Contains(weaponDef)) {\n            return true;\n        }\n\n        // tags\n        if (!ext.requiredWeaponTags.IsNullOrEmpty() && !weaponDef.weaponTags.IsNullOrEmpty() &&\n            ext.requiredWeaponTags.Any(tag => weaponDef.weaponTags.Contains(tag))) {\n            return true;\n        }\n\n        return ext.requiredWeaponDefs.IsNullOrEmpty() && ext.requiredWeaponTags.IsNullOrEmpty();\n    }\n\n    #region Helpers\n\n    private static IEnumerable<ThingDef> GetCompatibleWeaponDefsFor(ThingDef moduleDef) {\n        var ext = moduleDef.GetModExtension<TraitModuleExtension>();\n        if (ext == null) yield break;\n\n        var results = new HashSet<ThingDef>();\n\n        if (!ext.requiredWeaponDefs.IsNullOrEmpty()) {\n            results.AddRange(ext.requiredWeaponDefs);\n        }\n\n        if (!ext.requiredWeaponTags.IsNullOrEmpty()) {\n            foreach (var tag in ext.requiredWeaponTags) {\n                if (WeaponsByTag.TryGetValue(tag, out var weapons)) {\n                    results.AddRange(weapons);\n                }\n            }\n        }\n\n        if (!ext.excludeWeaponDefs.IsNullOrEmpty()) {\n            results.ExceptWith(ext.excludeWeaponDefs);\n        }\n\n        if (!ext.excludeWeaponTags.IsNullOrEmpty()) {\n            foreach (var tag in ext.excludeWeaponTags) {\n                if (WeaponsByTag.TryGetValue(tag, out var weaponsToExclude)) {\n                    results.ExceptWith(weaponsToExclude);\n                }\n            }\n        }\n\n        foreach (var weaponDef in results) {\n            yield return weaponDef;\n        }\n    }\n\n    #endregion\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/ModuleDatabase.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Postfix_ThingDef_SpecialDisplayStats.GetStatsExplanation(CWF.CompDynamicTraits,System.Text.StringBuilder,System.String,System.Func{RimWorld.WeaponTraitDef,System.Single},System.Single,Verse.ToStringNumberSense,Verse.ToStringStyle)",
    "name": "GetStatsExplanation",
    "fullName": "CWF.HarmonyPatches.Postfix_ThingDef_SpecialDisplayStats.GetStatsExplanation(CWF.CompDynamicTraits, System.Text.StringBuilder, string, System.Func<RimWorld.WeaponTraitDef, float>, float, Verse.ToStringNumberSense, Verse.ToStringStyle)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static void GetStatsExplanation(\n        this CompDynamicTraits comp,\n        StringBuilder sb,\n        string whitespace,\n        Func<WeaponTraitDef, float> valueSelector,\n        float defaultValue,\n        ToStringNumberSense numberSense,\n        ToStringStyle toStringStyle) {\n        var stringBuilder = new StringBuilder();\n\n        foreach (var weaponTraitDef in comp.Traits) {\n            var value = valueSelector(weaponTraitDef);\n            if (Mathf.Approximately(value, defaultValue)) continue;\n\n            var valueStr = value.ToStringByStyle(toStringStyle, numberSense);\n            stringBuilder.AppendLine($\"{whitespace} - {weaponTraitDef.LabelCap}: {valueStr}\");\n        }\n\n        if (stringBuilder.Length == 0) return;\n\n        sb.AppendLine(whitespace + \"CWF_UI_WeaponModules\".Translate() + \":\");\n        sb.Append(stringBuilder);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_ThingDef_SpecialDisplayStats.cs",
    "startLine": 105,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Func`2.Invoke(`0)",
      "M:UnityEngine.Mathf.Approximately(System.Single,System.Single)",
      "M:Verse.GenText.ToStringByStyle(Verse.ToStringStyle,Verse.ToStringNumberSense)",
      "M:System.Text.StringBuilder.AppendLine(System.String)",
      "M:Verse.Translator.Translate",
      "M:System.Text.StringBuilder.Append(System.Text.StringBuilder)",
      "M:System.Text.StringBuilder.#ctor"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Postfix_ThingDef_SpecialDisplayStats.Postfix(System.Collections.Generic.IEnumerable{RimWorld.StatDrawEntry},Verse.ThingDef,RimWorld.StatRequest)",
    "name": "Postfix",
    "fullName": "CWF.HarmonyPatches.Postfix_ThingDef_SpecialDisplayStats.Postfix(System.Collections.Generic.IEnumerable<RimWorld.StatDrawEntry>, Verse.ThingDef, RimWorld.StatRequest)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static IEnumerable<StatDrawEntry> Postfix(IEnumerable<StatDrawEntry> __result, ThingDef __instance,\n        StatRequest req) {\n        var resultList = __result.ToList();\n\n        if (!req.HasThing) {\n            foreach (var entry in resultList) yield return entry;\n            yield break;\n        }\n\n        var comp = req.Thing.TryGetComp<CompDynamicTraits>();\n        if (comp == null || comp.Traits.Count == 0) {\n            foreach (var entry in resultList) yield return entry;\n            yield break;\n        }\n\n        var verb = __instance.Verbs?.FirstOrDefault(v => v.isPrimary);\n        if (verb == null) {\n            foreach (var entry in resultList) yield return entry;\n            yield break;\n        }\n\n        var statCat = __instance.IsMeleeWeapon ? StatCategoryDefOf.Weapon_Melee : StatCategoryDefOf.Weapon_Ranged;\n\n        if (verb is { showBurstShotStats: true, burstShotCount: > 1 }) {\n            // === BurstShotCount ===\n            resultList.RemoveAll(entry => entry.DisplayPriorityWithinCategory == 5391);\n            var baseBurstCount = (float)verb.burstShotCount;\n            var burstCountMultiplier =\n                comp.Traits.Aggregate(1f, (current, trait) => current * trait.burstShotCountMultiplier);\n            var finalBurstCount = baseBurstCount * burstCountMultiplier;\n\n            var burstCountSb = new StringBuilder(\"Stat_Thing_Weapon_BurstShotFireRate_Desc\".Translate());\n            burstCountSb.AppendLine().AppendLine();\n            burstCountSb.AppendLine(\"StatsReport_BaseValue\".Translate() + \": \" + verb.burstShotCount);\n            comp.GetStatsExplanation(burstCountSb, \"    \", t => t.burstShotCountMultiplier, 1f,\n                ToStringNumberSense.Factor, ToStringStyle.PercentZero);\n            burstCountSb.AppendLine()\n                .AppendLine(\"StatsReport_FinalValue\".Translate() + \": \" + Mathf.CeilToInt(finalBurstCount));\n\n            yield return new StatDrawEntry(statCat, \"BurstShotCount\".Translate(),\n                Mathf.CeilToInt(finalBurstCount).ToString(), burstCountSb.ToString(), 5391);\n\n            // === TicksBetweenBurstShots ===\n            resultList.RemoveAll(entry => entry.DisplayPriorityWithinCategory == 5395);\n            var baseTicksBetweenShots = (float)verb.ticksBetweenBurstShots;\n            var burstSpeedMultiplier =\n                comp.Traits.Aggregate(1f, (current, trait) => current * trait.burstShotSpeedMultiplier);\n            var finalTicksBetweenShots = baseTicksBetweenShots / burstSpeedMultiplier;\n\n            // === RPM ===\n            var finalFireRate = 60f / (finalTicksBetweenShots / 60f);\n\n            var fireRateSb = new StringBuilder(\"Stat_Thing_Weapon_BurstShotFireRate_Desc\".Translate());\n            fireRateSb.AppendLine().AppendLine();\n            fireRateSb.AppendLine(\"StatsReport_BaseValue\".Translate() + \": \" +\n                                  (60f / verb.ticksBetweenBurstShots.TicksToSeconds()).ToString(\"0.##\") + \" rpm\");\n            comp.GetStatsExplanation(fireRateSb, \"    \", t => t.burstShotSpeedMultiplier, 1f,\n                ToStringNumberSense.Factor, ToStringStyle.PercentZero);\n            fireRateSb.AppendLine().AppendLine(\"StatsReport_FinalValue\".Translate() + \": \" +\n                                               finalFireRate.ToString(\"0.##\") + \" rpm\");\n\n            yield return new StatDrawEntry(statCat, \"BurstShotFireRate\".Translate(),\n                finalFireRate.ToString(\"0.##\") + \" rpm\", fireRateSb.ToString(), 5395);\n        }\n\n        // === StoppingPower ===\n        var stoppingPowerStat = verb.defaultProjectile?.projectile?.stoppingPower;\n        if (stoppingPowerStat is > 0f) {\n            resultList.RemoveAll(entry => entry.DisplayPriorityWithinCategory == 5402);\n            var baseStoppingPower = stoppingPowerStat.Value;\n            var additionalStoppingPower = comp.Traits.Sum(t => t.additionalStoppingPower);\n            var finalStoppingPower = baseStoppingPower + additionalStoppingPower;\n\n            var stoppingPowerSb = new StringBuilder(\"StoppingPowerExplanation\".Translate());\n            stoppingPowerSb.AppendLine().AppendLine();\n            stoppingPowerSb.AppendLine(\n                \"StatsReport_BaseValue\".Translate() + \": \" + baseStoppingPower.ToString(\"F1\"));\n            comp.GetStatsExplanation(stoppingPowerSb, \"    \", t => t.additionalStoppingPower, 0f,\n                ToStringNumberSense.Offset, ToStringStyle.FloatOne);\n            stoppingPowerSb.AppendLine()\n                .AppendLine(\"StatsReport_FinalValue\".Translate() + \": \" + finalStoppingPower.ToString(\"F1\"));\n\n            yield return new StatDrawEntry(statCat, \"StoppingPower\".Translate(), finalStoppingPower.ToString(\"F1\"),\n                stoppingPowerSb.ToString(), 5402);\n        }\n\n        foreach (var entry in resultList) {\n            yield return entry;\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_ThingDef_SpecialDisplayStats.cs",
    "startLine": 13,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.ToList``1",
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:Verse.GenCollection.FirstOrDefault``1(System.Predicate{``0})",
      "M:System.Collections.Generic.List`1.RemoveAll(System.Predicate{`0})",
      "M:System.Linq.Enumerable.Aggregate``2(``1,System.Func{``1,``0,``1})",
      "M:Verse.Translator.Translate",
      "M:System.Text.StringBuilder.AppendLine",
      "M:System.Text.StringBuilder.AppendLine(System.String)",
      "M:CWF.HarmonyPatches.Postfix_ThingDef_SpecialDisplayStats.GetStatsExplanation(System.Text.StringBuilder,System.String,System.Func{RimWorld.WeaponTraitDef,System.Single},System.Single,Verse.ToStringNumberSense,Verse.ToStringStyle)",
      "M:UnityEngine.Mathf.CeilToInt(System.Single)",
      "M:System.Int32.ToString",
      "M:System.Text.StringBuilder.ToString",
      "M:System.Single.ToString(System.String)",
      "M:Verse.GenTicks.TicksToSeconds",
      "M:System.Linq.Enumerable.Sum``1(System.Func{``0,System.Single})",
      "M:System.Text.StringBuilder.#ctor(System.String)",
      "M:RimWorld.StatDrawEntry.#ctor(RimWorld.StatCategoryDef,System.String,System.String,System.String,System.Int32,System.String,System.Collections.Generic.IEnumerable{Verse.Dialog_InfoCard.Hyperlink},System.Boolean,System.Boolean)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Postfix_ThingDef_SpecialDisplayStats",
    "name": "Postfix_ThingDef_SpecialDisplayStats",
    "fullName": "CWF.HarmonyPatches.Postfix_ThingDef_SpecialDisplayStats",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(ThingDef), nameof(ThingDef.SpecialDisplayStats))]\npublic static class Postfix_ThingDef_SpecialDisplayStats {\n    public static IEnumerable<StatDrawEntry> Postfix(IEnumerable<StatDrawEntry> __result, ThingDef __instance,\n        StatRequest req) {\n        var resultList = __result.ToList();\n\n        if (!req.HasThing) {\n            foreach (var entry in resultList) yield return entry;\n            yield break;\n        }\n\n        var comp = req.Thing.TryGetComp<CompDynamicTraits>();\n        if (comp == null || comp.Traits.Count == 0) {\n            foreach (var entry in resultList) yield return entry;\n            yield break;\n        }\n\n        var verb = __instance.Verbs?.FirstOrDefault(v => v.isPrimary);\n        if (verb == null) {\n            foreach (var entry in resultList) yield return entry;\n            yield break;\n        }\n\n        var statCat = __instance.IsMeleeWeapon ? StatCategoryDefOf.Weapon_Melee : StatCategoryDefOf.Weapon_Ranged;\n\n        if (verb is { showBurstShotStats: true, burstShotCount: > 1 }) {\n            // === BurstShotCount ===\n            resultList.RemoveAll(entry => entry.DisplayPriorityWithinCategory == 5391);\n            var baseBurstCount = (float)verb.burstShotCount;\n            var burstCountMultiplier =\n                comp.Traits.Aggregate(1f, (current, trait) => current * trait.burstShotCountMultiplier);\n            var finalBurstCount = baseBurstCount * burstCountMultiplier;\n\n            var burstCountSb = new StringBuilder(\"Stat_Thing_Weapon_BurstShotFireRate_Desc\".Translate());\n            burstCountSb.AppendLine().AppendLine();\n            burstCountSb.AppendLine(\"StatsReport_BaseValue\".Translate() + \": \" + verb.burstShotCount);\n            comp.GetStatsExplanation(burstCountSb, \"    \", t => t.burstShotCountMultiplier, 1f,\n                ToStringNumberSense.Factor, ToStringStyle.PercentZero);\n            burstCountSb.AppendLine()\n                .AppendLine(\"StatsReport_FinalValue\".Translate() + \": \" + Mathf.CeilToInt(finalBurstCount));\n\n            yield return new StatDrawEntry(statCat, \"BurstShotCount\".Translate(),\n                Mathf.CeilToInt(finalBurstCount).ToString(), burstCountSb.ToString(), 5391);\n\n            // === TicksBetweenBurstShots ===\n            resultList.RemoveAll(entry => entry.DisplayPriorityWithinCategory == 5395);\n            var baseTicksBetweenShots = (float)verb.ticksBetweenBurstShots;\n            var burstSpeedMultiplier =\n                comp.Traits.Aggregate(1f, (current, trait) => current * trait.burstShotSpeedMultiplier);\n            var finalTicksBetweenShots = baseTicksBetweenShots / burstSpeedMultiplier;\n\n            // === RPM ===\n            var finalFireRate = 60f / (finalTicksBetweenShots / 60f);\n\n            var fireRateSb = new StringBuilder(\"Stat_Thing_Weapon_BurstShotFireRate_Desc\".Translate());\n            fireRateSb.AppendLine().AppendLine();\n            fireRateSb.AppendLine(\"StatsReport_BaseValue\".Translate() + \": \" +\n                                  (60f / verb.ticksBetweenBurstShots.TicksToSeconds()).ToString(\"0.##\") + \" rpm\");\n            comp.GetStatsExplanation(fireRateSb, \"    \", t => t.burstShotSpeedMultiplier, 1f,\n                ToStringNumberSense.Factor, ToStringStyle.PercentZero);\n            fireRateSb.AppendLine().AppendLine(\"StatsReport_FinalValue\".Translate() + \": \" +\n                                               finalFireRate.ToString(\"0.##\") + \" rpm\");\n\n            yield return new StatDrawEntry(statCat, \"BurstShotFireRate\".Translate(),\n                finalFireRate.ToString(\"0.##\") + \" rpm\", fireRateSb.ToString(), 5395);\n        }\n\n        // === StoppingPower ===\n        var stoppingPowerStat = verb.defaultProjectile?.projectile?.stoppingPower;\n        if (stoppingPowerStat is > 0f) {\n            resultList.RemoveAll(entry => entry.DisplayPriorityWithinCategory == 5402);\n            var baseStoppingPower = stoppingPowerStat.Value;\n            var additionalStoppingPower = comp.Traits.Sum(t => t.additionalStoppingPower);\n            var finalStoppingPower = baseStoppingPower + additionalStoppingPower;\n\n            var stoppingPowerSb = new StringBuilder(\"StoppingPowerExplanation\".Translate());\n            stoppingPowerSb.AppendLine().AppendLine();\n            stoppingPowerSb.AppendLine(\n                \"StatsReport_BaseValue\".Translate() + \": \" + baseStoppingPower.ToString(\"F1\"));\n            comp.GetStatsExplanation(stoppingPowerSb, \"    \", t => t.additionalStoppingPower, 0f,\n                ToStringNumberSense.Offset, ToStringStyle.FloatOne);\n            stoppingPowerSb.AppendLine()\n                .AppendLine(\"StatsReport_FinalValue\".Translate() + \": \" + finalStoppingPower.ToString(\"F1\"));\n\n            yield return new StatDrawEntry(statCat, \"StoppingPower\".Translate(), finalStoppingPower.ToString(\"F1\"),\n                stoppingPowerSb.ToString(), 5402);\n        }\n\n        foreach (var entry in resultList) {\n            yield return entry;\n        }\n    }\n\n    // Helper\n    private static void GetStatsExplanation(\n        this CompDynamicTraits comp,\n        StringBuilder sb,\n        string whitespace,\n        Func<WeaponTraitDef, float> valueSelector,\n        float defaultValue,\n        ToStringNumberSense numberSense,\n        ToStringStyle toStringStyle) {\n        var stringBuilder = new StringBuilder();\n\n        foreach (var weaponTraitDef in comp.Traits) {\n            var value = valueSelector(weaponTraitDef);\n            if (Mathf.Approximately(value, defaultValue)) continue;\n\n            var valueStr = value.ToStringByStyle(toStringStyle, numberSense);\n            stringBuilder.AppendLine($\"{whitespace} - {weaponTraitDef.LabelCap}: {valueStr}\");\n        }\n\n        if (stringBuilder.Length == 0) return;\n\n        sb.AppendLine(whitespace + \"CWF_UI_WeaponModules\".Translate() + \":\");\n        sb.Append(stringBuilder);\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_ThingDef_SpecialDisplayStats.cs",
    "startLine": 11,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(ThingDef), nameof(ThingDef.SpecialDisplayStats))"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Postfix_ThingComp_Notify_Equipped.Postfix(Verse.ThingComp,Verse.Pawn)",
    "name": "Postfix",
    "fullName": "CWF.HarmonyPatches.Postfix_ThingComp_Notify_Equipped.Postfix(Verse.ThingComp, Verse.Pawn)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static void Postfix(ThingComp __instance, Pawn pawn) {\n        var compAbilityProvider = __instance.parent.GetComp<CompAbilityProvider>();\n        compAbilityProvider?.OnEquipped(pawn);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_ThingComp_Notify_Equipped.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingWithComps.GetComp``1",
      "M:CWF.CompAbilityProvider.OnEquipped(Verse.Pawn)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Postfix_ThingComp_Notify_Equipped",
    "name": "Postfix_ThingComp_Notify_Equipped",
    "fullName": "CWF.HarmonyPatches.Postfix_ThingComp_Notify_Equipped",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(ThingComp), nameof(ThingComp.Notify_Equipped))]\npublic static class Postfix_ThingComp_Notify_Equipped {\n    public static void Postfix(ThingComp __instance, Pawn pawn) {\n        var compAbilityProvider = __instance.parent.GetComp<CompAbilityProvider>();\n        compAbilityProvider?.OnEquipped(pawn);\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_ThingComp_Notify_Equipped.cs",
    "startLine": 8,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(ThingComp), nameof(ThingComp.Notify_Equipped))"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Postfix_CompEquippableAbility_AbilityForReading.Postfix(RimWorld.CompEquippableAbility,RimWorld.Ability@)",
    "name": "Postfix",
    "fullName": "CWF.HarmonyPatches.Postfix_CompEquippableAbility_AbilityForReading.Postfix(RimWorld.CompEquippableAbility, ref RimWorld.Ability?)",
    "type": "Method",
    "baseType": null,
    "codeBody": "[HarmonyPostfix]\n    public static void Postfix(CompEquippableAbility __instance, ref Ability? __result) {\n        var props = __instance.props as CompProperties_EquippableAbility;\n        var expectedAbilityDef = props?.abilityDef;\n\n        if ((__result == null || __result.def == expectedAbilityDef) &&\n            (__result == null || expectedAbilityDef != null)) return;\n\n        if (AbilityField != null) {\n            AbilityField.SetValue(__instance, null);\n        }\n\n        __result = __instance.AbilityForReading;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_CompEquippableAbility_AbilityForReading.cs",
    "startLine": 13,
    "attributes": ["HarmonyPostfix"],
    "attributeDetails": ["HarmonyPostfix"],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Postfix_CompEquippableAbility_AbilityForReading",
    "name": "Postfix_CompEquippableAbility_AbilityForReading",
    "fullName": "CWF.HarmonyPatches.Postfix_CompEquippableAbility_AbilityForReading",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(CompEquippableAbility), \"get_AbilityForReading\")]\npublic static class Postfix_CompEquippableAbility_AbilityForReading {\n    private static readonly FieldInfo? AbilityField = AccessTools.Field(typeof(CompEquippableAbility), \"ability\");\n\n    [HarmonyPostfix]\n    public static void Postfix(CompEquippableAbility __instance, ref Ability? __result) {\n        var props = __instance.props as CompProperties_EquippableAbility;\n        var expectedAbilityDef = props?.abilityDef;\n\n        if ((__result == null || __result.def == expectedAbilityDef) &&\n            (__result == null || expectedAbilityDef != null)) return;\n\n        if (AbilityField != null) {\n            AbilityField.SetValue(__instance, null);\n        }\n\n        __result = __instance.AbilityForReading;\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_CompEquippableAbility_AbilityForReading.cs",
    "startLine": 9,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(CompEquippableAbility), \"get_AbilityForReading\")"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.AttachmentPointData.ExposeData",
    "name": "ExposeData",
    "fullName": "CWF.AttachmentPointData.ExposeData()",
    "type": "Method",
    "baseType": null,
    "codeBody": "[UsedImplicitly]\n    public void ExposeData() {\n        Scribe_Defs.Look(ref part, \"part\");\n\n        Scribe_Values.Look(ref baseTexture, \"baseTexture\");\n        Scribe_Values.Look(ref layer, \"layer\");\n        Scribe_Values.Look(ref receivesColor, \"receivesColor\");\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_DynamicGraphic.cs",
    "startLine": 46,
    "attributes": ["UsedImplicitly"],
    "attributeDetails": ["UsedImplicitly"],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Scribe_Defs.Look``1(``0@,System.String)",
      "M:Verse.Scribe_Values.Look``1(``0@,System.String,``0,System.Boolean)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.AttachmentPointData",
    "name": "AttachmentPointData",
    "fullName": "CWF.AttachmentPointData",
    "type": "Class",
    "baseType": null,
    "codeBody": "[UsedImplicitly]\npublic class AttachmentPointData {\n    /// <summary>\n    /// The logical part slot this visual point corresponds to.\n    /// </summary>\n    public PartDef? part;\n\n    /// <summary>\n    /// The default graphic to display at this point if no module is installed in the corresponding part slot.\n    /// </summary>\n    public ModuleGraphicData? baseTexture;\n\n    /// <summary>\n    /// The draw order for this attachment point. Higher numbers are drawn on top.\n    /// </summary>\n    public int layer;\n\n    /// <summary>\n    /// If true, the graphic at this point will be tinted with the weapon's primary color from `CompColorable`.\n    /// </summary>\n    public bool receivesColor;\n\n    [UsedImplicitly]\n    public void ExposeData() {\n        Scribe_Defs.Look(ref part, \"part\");\n\n        Scribe_Values.Look(ref baseTexture, \"baseTexture\");\n        Scribe_Values.Look(ref layer, \"layer\");\n        Scribe_Values.Look(ref receivesColor, \"receivesColor\");\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_DynamicGraphic.cs",
    "startLine": 24,
    "attributes": ["UsedImplicitly"],
    "attributeDetails": ["UsedImplicitly"],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompProperties_DynamicGraphic.#ctor",
    "name": ".ctor",
    "fullName": "CWF.CompProperties_DynamicGraphic.CompProperties_DynamicGraphic()",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public CompProperties_DynamicGraphic() => compClass = typeof(CompDynamicGraphic);",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_DynamicGraphic.cs",
    "startLine": 18,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.CompProperties_DynamicGraphic",
    "name": "CompProperties_DynamicGraphic",
    "fullName": "CWF.CompProperties_DynamicGraphic",
    "type": "Class",
    "baseType": "Verse.CompProperties",
    "codeBody": "public class CompProperties_DynamicGraphic : CompProperties {\n    /// <summary>\n    /// A list of visual attachment points on the weapon where module graphics will be rendered.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly List<AttachmentPointData> attachmentPoints = [];\n\n    public CompProperties_DynamicGraphic() => compClass = typeof(CompDynamicGraphic);\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_DynamicGraphic.cs",
    "startLine": 11,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.ViewDrawers.AsideDrawer.DrawLabelRow(UnityEngine.Rect@,System.String,System.String,System.Single)",
    "name": "DrawLabelRow",
    "fullName": "CWF.ViewDrawers.AsideDrawer.DrawLabelRow(in UnityEngine.Rect, string, string, float)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static void DrawLabelRow(in Rect rect, string label, string value, float deltaValue = 0f) {\n        var inRect = rect;\n\n        // Label\n        UIKit.WithStyle(() => Widgets.Label(inRect, label), anchor: TextAnchor.MiddleLeft);\n\n        // Value with color\n        var color = deltaValue switch {\n            > 0f => new Color(0.15f, 0.85f, 0.15f),\n            < 0f => new Color(0.87f, 0.49f, 0.51f),\n            _ => Color.white\n        };\n\n        UIKit.WithStyle(() => Widgets.Label(inRect, value), color: color, anchor: TextAnchor.MiddleRight);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/AsideDrawer.cs",
    "startLine": 58,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.UIKit.WithStyle(System.Action,Verse.GameFont,System.Nullable{UnityEngine.Color},UnityEngine.TextAnchor)",
      "M:Verse.Widgets.Label(UnityEngine.Rect,System.String)",
      "M:UnityEngine.Color.#ctor(System.Single,System.Single,System.Single)"
    ],
    "calledBy": [
      "M:CWF.ViewDrawers.AsideDrawer.DrawStatRow(Verse.Listing_Standard,System.String,CWF.Spec,System.String,System.String)"
    ]
  },
  {
    "id": "M:CWF.ViewDrawers.AsideDrawer.DrawStatRow(Verse.Listing_Standard,System.String,CWF.Spec,System.String,System.String)",
    "name": "DrawStatRow",
    "fullName": "CWF.ViewDrawers.AsideDrawer.DrawStatRow(Verse.Listing_Standard, string, CWF.Spec, string, string)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static void DrawStatRow(\n        Listing_Standard listing, string label, Spec spec,\n        string format = \"N0\", string unit = \"\") {\n        var value = unit == \"%\" ? spec.Dynamic * 100 : spec.Dynamic;\n        var valueString = value.ToString(format) + unit;\n        var delta = spec.IsLowerValueBetter ? spec.Raw - spec.Dynamic : spec.Dynamic - spec.Raw;\n\n        DrawLabelRow(listing.GetRect(22), label, valueString, delta);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/AsideDrawer.cs",
    "startLine": 48,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Single.ToString(System.String)",
      "M:CWF.ViewDrawers.AsideDrawer.DrawLabelRow(UnityEngine.Rect@,System.String,System.String,System.Single)",
      "M:Verse.Listing.GetRect(System.Single,System.Single)"
    ],
    "calledBy": ["M:CWF.ViewDrawers.AsideDrawer.Draw(UnityEngine.Rect@)"]
  },
  {
    "id": "M:CWF.ViewDrawers.AsideDrawer.Draw(UnityEngine.Rect@)",
    "name": "Draw",
    "fullName": "CWF.ViewDrawers.AsideDrawer.Draw(in UnityEngine.Rect)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void Draw(in Rect rect) {\n        var listing = new Listing_Standard();\n        listing.Begin(rect);\n\n        if (specDatabase.IsMeleeWeapon) {\n            listing.Label(\"CWF_UI_NotRanged\".Translate());\n            listing.End();\n            return;\n        }\n\n        // === Weapon Stats ===\n        DrawStatRow(listing, \"CWF_UI_Range\".Translate(), specDatabase.Range);\n        DrawStatRow(listing, \"CWF_UI_RangeDPS\".Translate(), specDatabase.Dps);\n        DrawStatRow(listing, \"CWF_UI_RangeBurstCount\".Translate(), specDatabase.BurstShotCount);\n        DrawStatRow(listing, \"CWF_UI_RangeWarmupTime\".Translate(), specDatabase.WarmupTime, \"F1\", \" s\");\n        DrawStatRow(listing, \"CWF_UI_RangeCooldown\".Translate(), specDatabase.Cooldown, \"F1\", \" s\");\n\n        // === Projectile Stats ===\n        listing.GapLine();\n        listing.Label($\"<color=#999999><b>{\"CWF_UI_Projectile\".Translate()}</b></color>\", 22f);\n        DrawStatRow(listing, \"CWF_UI_Damage\".Translate(), specDatabase.Damage);\n        DrawStatRow(listing, \"CWF_UI_ArmorPenetration\".Translate(), specDatabase.ArmorPenetration, unit: \"%\");\n        DrawStatRow(listing, \"CWF_UI_StoppingPower\".Translate(), specDatabase.StoppingPower, \"F1\");\n\n        // === Accuracy Stats ===\n        listing.GapLine();\n        listing.Label($\"<color=#999999><b>{\"CWF_UI_Accuracy\".Translate()}</b></color>\", 22f);\n        DrawStatRow(listing, \"CWF_UI_Touch\".Translate(), specDatabase.AccuracyTouch, unit: \"%\");\n        DrawStatRow(listing, \"CWF_UI_Short\".Translate(), specDatabase.AccuracyShort, unit: \"%\");\n        DrawStatRow(listing, \"CWF_UI_Medium\".Translate(), specDatabase.AccuracyMedium, unit: \"%\");\n        DrawStatRow(listing, \"CWF_UI_Long\".Translate(), specDatabase.AccuracyLong, unit: \"%\");\n\n        // === Other Stats ===\n        listing.GapLine();\n        DrawStatRow(listing, \"Mass\".Translate(), specDatabase.Mass, \"F1\", \"Kg\");\n        DrawStatRow(listing, \"MarketValueTip\".Translate(), specDatabase.MarketValue);\n\n        listing.End();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/AsideDrawer.cs",
    "startLine": 7,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Listing_Standard.Begin(UnityEngine.Rect)",
      "M:Verse.Listing_Standard.Label(Verse.TaggedString,System.Single,System.String)",
      "M:Verse.Translator.Translate",
      "M:Verse.Listing_Standard.End",
      "M:CWF.ViewDrawers.AsideDrawer.DrawStatRow(Verse.Listing_Standard,System.String,CWF.Spec,System.String,System.String)",
      "M:Verse.Listing.GapLine(System.Single)",
      "M:Verse.Listing_Standard.Label(System.String,System.Single,System.Nullable{Verse.TipSignal})",
      "M:Verse.Listing_Standard.#ctor"
    ],
    "calledBy": ["M:CWF.WeaponWindow.DoWindowContents(UnityEngine.Rect)"]
  },
  {
    "id": "T:CWF.ViewDrawers.AsideDrawer",
    "name": "AsideDrawer",
    "fullName": "CWF.ViewDrawers.AsideDrawer",
    "type": "Class",
    "baseType": null,
    "codeBody": "public class AsideDrawer(SpecDatabase specDatabase) {\n    public void Draw(in Rect rect) {\n        var listing = new Listing_Standard();\n        listing.Begin(rect);\n\n        if (specDatabase.IsMeleeWeapon) {\n            listing.Label(\"CWF_UI_NotRanged\".Translate());\n            listing.End();\n            return;\n        }\n\n        // === Weapon Stats ===\n        DrawStatRow(listing, \"CWF_UI_Range\".Translate(), specDatabase.Range);\n        DrawStatRow(listing, \"CWF_UI_RangeDPS\".Translate(), specDatabase.Dps);\n        DrawStatRow(listing, \"CWF_UI_RangeBurstCount\".Translate(), specDatabase.BurstShotCount);\n        DrawStatRow(listing, \"CWF_UI_RangeWarmupTime\".Translate(), specDatabase.WarmupTime, \"F1\", \" s\");\n        DrawStatRow(listing, \"CWF_UI_RangeCooldown\".Translate(), specDatabase.Cooldown, \"F1\", \" s\");\n\n        // === Projectile Stats ===\n        listing.GapLine();\n        listing.Label($\"<color=#999999><b>{\"CWF_UI_Projectile\".Translate()}</b></color>\", 22f);\n        DrawStatRow(listing, \"CWF_UI_Damage\".Translate(), specDatabase.Damage);\n        DrawStatRow(listing, \"CWF_UI_ArmorPenetration\".Translate(), specDatabase.ArmorPenetration, unit: \"%\");\n        DrawStatRow(listing, \"CWF_UI_StoppingPower\".Translate(), specDatabase.StoppingPower, \"F1\");\n\n        // === Accuracy Stats ===\n        listing.GapLine();\n        listing.Label($\"<color=#999999><b>{\"CWF_UI_Accuracy\".Translate()}</b></color>\", 22f);\n        DrawStatRow(listing, \"CWF_UI_Touch\".Translate(), specDatabase.AccuracyTouch, unit: \"%\");\n        DrawStatRow(listing, \"CWF_UI_Short\".Translate(), specDatabase.AccuracyShort, unit: \"%\");\n        DrawStatRow(listing, \"CWF_UI_Medium\".Translate(), specDatabase.AccuracyMedium, unit: \"%\");\n        DrawStatRow(listing, \"CWF_UI_Long\".Translate(), specDatabase.AccuracyLong, unit: \"%\");\n\n        // === Other Stats ===\n        listing.GapLine();\n        DrawStatRow(listing, \"Mass\".Translate(), specDatabase.Mass, \"F1\", \"Kg\");\n        DrawStatRow(listing, \"MarketValueTip\".Translate(), specDatabase.MarketValue);\n\n        listing.End();\n    }\n\n    // helper\n    private static void DrawStatRow(\n        Listing_Standard listing, string label, Spec spec,\n        string format = \"N0\", string unit = \"\") {\n        var value = unit == \"%\" ? spec.Dynamic * 100 : spec.Dynamic;\n        var valueString = value.ToString(format) + unit;\n        var delta = spec.IsLowerValueBetter ? spec.Raw - spec.Dynamic : spec.Dynamic - spec.Raw;\n\n        DrawLabelRow(listing.GetRect(22), label, valueString, delta);\n    }\n\n    private static void DrawLabelRow(in Rect rect, string label, string value, float deltaValue = 0f) {\n        var inRect = rect;\n\n        // Label\n        UIKit.WithStyle(() => Widgets.Label(inRect, label), anchor: TextAnchor.MiddleLeft);\n\n        // Value with color\n        var color = deltaValue switch {\n            > 0f => new Color(0.15f, 0.85f, 0.15f),\n            < 0f => new Color(0.87f, 0.49f, 0.51f),\n            _ => Color.white\n        };\n\n        UIKit.WithStyle(() => Widgets.Label(inRect, value), color: color, anchor: TextAnchor.MiddleRight);\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/AsideDrawer.cs",
    "startLine": 6,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.UIKit.WithStyle(System.Action,Verse.GameFont,System.Nullable{UnityEngine.Color},UnityEngine.TextAnchor)",
    "name": "WithStyle",
    "fullName": "CWF.UIKit.WithStyle(System.Action, Verse.GameFont, UnityEngine.Color?, UnityEngine.TextAnchor)",
    "type": "Method",
    "baseType": null,
    "codeBody": "internal static void WithStyle(Action drawAction, GameFont font = GameFont.Small, Color? color = null,\n        TextAnchor anchor = TextAnchor.UpperLeft) {\n        var originalFont = Text.Font;\n        var originalColor = GUI.color;\n        var originalAnchor = Text.Anchor;\n\n        Text.Font = font;\n        GUI.color = color ?? Color.white;\n        Text.Anchor = anchor;\n\n        drawAction();\n\n        Text.Font = originalFont;\n        GUI.color = originalColor;\n        Text.Anchor = originalAnchor;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/UIKit.cs",
    "startLine": 7,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:System.Action.Invoke"],
    "calledBy": [
      "M:CWF.ViewDrawers.MainDrawer.DrawPartSlot(UnityEngine.Rect@,System.String)",
      "M:CWF.ViewDrawers.MainDrawer.TryDrawSlot(CWF.PartDef,UnityEngine.Rect@)",
      "M:CWF.ViewDrawers.AsideDrawer.DrawLabelRow(UnityEngine.Rect@,System.String,System.String,System.Single)",
      "M:CWF.ViewDrawers.HeaderDrawer.Draw(UnityEngine.Rect@)",
      "M:CWF.Dialog_TextInput.DoWindowContents(UnityEngine.Rect)",
      "M:CWF.ModuleBrowserWindow.DrawRightColumn(UnityEngine.Rect@)",
      "M:CWF.ModuleBrowserWindow.DrawLeftColumn(UnityEngine.Rect@)"
    ]
  },
  {
    "id": "T:CWF.UIKit",
    "name": "UIKit",
    "fullName": "CWF.UIKit",
    "type": "Class",
    "baseType": null,
    "codeBody": "internal static class UIKit {\n    internal static void WithStyle(Action drawAction, GameFont font = GameFont.Small, Color? color = null,\n        TextAnchor anchor = TextAnchor.UpperLeft) {\n        var originalFont = Text.Font;\n        var originalColor = GUI.color;\n        var originalAnchor = Text.Anchor;\n\n        Text.Font = font;\n        GUI.color = color ?? Color.white;\n        Text.Anchor = anchor;\n\n        drawAction();\n\n        Text.Font = originalFont;\n        GUI.color = originalColor;\n        Text.Anchor = originalAnchor;\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/UIKit.cs",
    "startLine": 6,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.ConfigWindow.DoSettingsWindowContents(UnityEngine.Rect)",
    "name": "DoSettingsWindowContents",
    "fullName": "CWF.ConfigWindow.DoSettingsWindowContents(UnityEngine.Rect)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void DoSettingsWindowContents(Rect inRect) {\n        var listing = new Listing_Standard();\n        listing.Begin(inRect);\n\n        listing.CheckboxLabeled(\"CWF_UI_RandomModuleGeneration\".Translate(), ref _settings.RandomModulesEnabled,\n            \"CWF_UI_RandomModuleGenerationDesc\".Translate());\n\n        if (_settings.RandomModulesEnabled) {\n            var range = new IntRange(_settings.MinRandomModules, _settings.MaxRandomModules);\n            listing.IntRange(ref range, 0, 10);\n\n            _settings.MinRandomModules = range.min;\n            _settings.MaxRandomModules = range.max;\n        }\n\n        listing.Gap(24f);\n\n        if (listing.ButtonText(\"Reset\".Translate(), widthPct: 0.5f)) {\n            _settings.Reset();\n        }\n\n        listing.End();\n        base.DoSettingsWindowContents(inRect);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ConfigWindow.cs",
    "startLine": 17,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Listing_Standard.Begin(UnityEngine.Rect)",
      "M:Verse.Listing_Standard.CheckboxLabeled(System.String,System.Boolean@,System.String,System.Single,System.Single)",
      "M:Verse.Translator.Translate",
      "M:Verse.Listing_Standard.IntRange(Verse.IntRange@,System.Int32,System.Int32)",
      "M:Verse.Listing.Gap(System.Single)",
      "M:Verse.Listing_Standard.ButtonText(System.String,System.String,System.Single)",
      "M:CWF.Settings.Reset",
      "M:Verse.Listing_Standard.End",
      "M:Verse.Mod.DoSettingsWindowContents(UnityEngine.Rect)",
      "M:Verse.Listing_Standard.#ctor",
      "M:Verse.IntRange.#ctor(System.Int32,System.Int32)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.ConfigWindow.SettingsCategory",
    "name": "SettingsCategory",
    "fullName": "CWF.ConfigWindow.SettingsCategory()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override string SettingsCategory() => \"Customize Weapon\";",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ConfigWindow.cs",
    "startLine": 15,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.ConfigWindow.#ctor(Verse.ModContentPack)",
    "name": ".ctor",
    "fullName": "CWF.ConfigWindow.ConfigWindow(Verse.ModContentPack)",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public ConfigWindow(ModContentPack content) : base(content) {\n        _settings = GetSettings<Settings>();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ConfigWindow.cs",
    "startLine": 11,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.Mod.GetSettings``1"],
    "calledBy": []
  },
  {
    "id": "T:CWF.ConfigWindow",
    "name": "ConfigWindow",
    "fullName": "CWF.ConfigWindow",
    "type": "Class",
    "baseType": "Verse.Mod",
    "codeBody": "[UsedImplicitly]\npublic class ConfigWindow : Mod {\n    private readonly Settings _settings;\n\n    public ConfigWindow(ModContentPack content) : base(content) {\n        _settings = GetSettings<Settings>();\n    }\n\n    public override string SettingsCategory() => \"Customize Weapon\";\n\n    public override void DoSettingsWindowContents(Rect inRect) {\n        var listing = new Listing_Standard();\n        listing.Begin(inRect);\n\n        listing.CheckboxLabeled(\"CWF_UI_RandomModuleGeneration\".Translate(), ref _settings.RandomModulesEnabled,\n            \"CWF_UI_RandomModuleGenerationDesc\".Translate());\n\n        if (_settings.RandomModulesEnabled) {\n            var range = new IntRange(_settings.MinRandomModules, _settings.MaxRandomModules);\n            listing.IntRange(ref range, 0, 10);\n\n            _settings.MinRandomModules = range.min;\n            _settings.MaxRandomModules = range.max;\n        }\n\n        listing.Gap(24f);\n\n        if (listing.ButtonText(\"Reset\".Translate(), widthPct: 0.5f)) {\n            _settings.Reset();\n        }\n\n        listing.End();\n        base.DoSettingsWindowContents(inRect);\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ConfigWindow.cs",
    "startLine": 7,
    "attributes": ["UsedImplicitly"],
    "attributeDetails": ["UsedImplicitly"],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompColorable.CompGetGizmosExtra",
    "name": "CompGetGizmosExtra",
    "fullName": "CWF.CompColorable.CompGetGizmosExtra()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override IEnumerable<Gizmo> CompGetGizmosExtra() {\n        foreach (var g in base.CompGetGizmosExtra()) {\n            yield return g;\n        }\n\n        if (!Prefs.DevMode || parent.IsForbidden(Faction.OfPlayer)) yield break;\n\n        yield return new Command_Action {\n            defaultLabel = \"Dev: Randomize color\",\n            action = RandomizeColor\n        };\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompColorable.cs",
    "startLine": 49,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingComp.CompGetGizmosExtra",
      "M:RimWorld.ForbidUtility.IsForbidden(RimWorld.Faction)",
      "M:Verse.Command_Action.#ctor"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompColorable.PostExposeData",
    "name": "PostExposeData",
    "fullName": "CWF.CompColorable.PostExposeData()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void PostExposeData() {\n        base.PostExposeData();\n        Scribe_Defs.Look(ref _colorDef, \"colorDef\");\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompColorable.cs",
    "startLine": 43,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingComp.PostExposeData",
      "M:Verse.Scribe_Defs.Look``1(``0@,System.String)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompColorable.PostPostMake",
    "name": "PostPostMake",
    "fullName": "CWF.CompColorable.PostPostMake()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void PostPostMake() {\n        base.PostPostMake();\n\n        if (Scribe.mode != LoadSaveMode.Inactive || ColorDef != null) return;\n\n        RandomizeColor();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompColorable.cs",
    "startLine": 35,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingComp.PostPostMake",
      "M:CWF.CompColorable.RandomizeColor"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompColorable.ForceColor",
    "name": "ForceColor",
    "fullName": "CWF.CompColorable.ForceColor()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override Color? ForceColor() {\n        return ColorDef?.color;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompColorable.cs",
    "startLine": 31,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompColorable.RandomizeColor",
    "name": "RandomizeColor",
    "fullName": "CWF.CompColorable.RandomizeColor()",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void RandomizeColor() {\n        var randomColor = DefDatabase<ColorDef>.AllDefs\n            .Where(c => c.colorType == ColorType.Weapon && c.randomlyPickable)\n            .RandomElementWithFallback();\n\n        if (randomColor != null) {\n            ColorDef = randomColor;\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompColorable.cs",
    "startLine": 20,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.GenCollection.RandomElementWithFallback``1(``0)",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})"
    ],
    "calledBy": ["M:CWF.CompColorable.PostPostMake"]
  },
  {
    "id": "P:CWF.CompColorable.ColorDef",
    "name": "ColorDef",
    "fullName": "CWF.CompColorable.ColorDef",
    "type": "Property",
    "baseType": null,
    "codeBody": "public ColorDef? ColorDef {\n        get => _colorDef;\n        private set {\n            if (_colorDef == value) return;\n\n            _colorDef = value;\n            parent.Notify_ColorChanged();\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompColorable.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.ThingWithComps.Notify_ColorChanged"],
    "calledBy": []
  },
  {
    "id": "T:CWF.CompColorable",
    "name": "CompColorable",
    "fullName": "CWF.CompColorable",
    "type": "Class",
    "baseType": "Verse.ThingComp",
    "codeBody": "public class CompColorable : ThingComp {\n    private ColorDef? _colorDef;\n\n    public ColorDef? ColorDef {\n        get => _colorDef;\n        private set {\n            if (_colorDef == value) return;\n\n            _colorDef = value;\n            parent.Notify_ColorChanged();\n        }\n    }\n\n    private void RandomizeColor() {\n        var randomColor = DefDatabase<ColorDef>.AllDefs\n            .Where(c => c.colorType == ColorType.Weapon && c.randomlyPickable)\n            .RandomElementWithFallback();\n\n        if (randomColor != null) {\n            ColorDef = randomColor;\n        }\n    }\n\n    // Override default color if defined.\n    public override Color? ForceColor() {\n        return ColorDef?.color;\n    }\n\n    public override void PostPostMake() {\n        base.PostPostMake();\n\n        if (Scribe.mode != LoadSaveMode.Inactive || ColorDef != null) return;\n\n        RandomizeColor();\n    }\n\n    public override void PostExposeData() {\n        base.PostExposeData();\n        Scribe_Defs.Look(ref _colorDef, \"colorDef\");\n    }\n\n    // debug\n    public override IEnumerable<Gizmo> CompGetGizmosExtra() {\n        foreach (var g in base.CompGetGizmosExtra()) {\n            yield return g;\n        }\n\n        if (!Prefs.DevMode || parent.IsForbidden(Faction.OfPlayer)) yield break;\n\n        yield return new Command_Action {\n            defaultLabel = \"Dev: Randomize color\",\n            action = RandomizeColor\n        };\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompColorable.cs",
    "startLine": 7,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Transpiler_Thing_Graphic.Transpiler(System.Collections.Generic.IEnumerable{HarmonyLib.CodeInstruction},System.Reflection.Emit.ILGenerator)",
    "name": "Transpiler",
    "fullName": "CWF.HarmonyPatches.Transpiler_Thing_Graphic.Transpiler(System.Collections.Generic.IEnumerable<HarmonyLib.CodeInstruction>, System.Reflection.Emit.ILGenerator)",
    "type": "Method",
    "baseType": null,
    "codeBody": "[HarmonyTranspiler]\n    public static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions, ILGenerator il) {\n        var getDynamicGraphicMethod = AccessTools.Method(typeof(CompDynamicGraphic),\n            nameof(CompDynamicGraphic.GetDynamicGraphic));\n        var compsField = AccessTools.Field(typeof(ThingWithComps), \"comps\");\n        var listGetItemMethod = AccessTools.Method(typeof(List<ThingComp>), \"get_Item\");\n        var listGetCountMethod = AccessTools.Method(typeof(List<ThingComp>), \"get_Count\");\n\n        var thingWithCompsVar = il.DeclareLocal(typeof(ThingWithComps));\n        var compListVar = il.DeclareLocal(typeof(List<ThingComp>));\n        var loopIndexVar = il.DeclareLocal(typeof(int));\n        var currentCompVar = il.DeclareLocal(typeof(ThingComp));\n\n        var originalCodeLabel = il.DefineLabel();\n        var loopStartLabel = il.DefineLabel();\n        var loopCheckLabel = il.DefineLabel();\n\n        var code = new List<CodeInstruction> {\n            new(OpCodes.Ldarg_0),\n            new(OpCodes.Isinst, typeof(ThingWithComps)),\n            new(OpCodes.Stloc, thingWithCompsVar),\n            new(OpCodes.Ldloc, thingWithCompsVar),\n            new(OpCodes.Brfalse_S, originalCodeLabel),\n            new(OpCodes.Ldloc, thingWithCompsVar),\n            new(OpCodes.Ldfld, compsField),\n            new(OpCodes.Stloc, compListVar),\n            new(OpCodes.Ldloc, compListVar),\n            new(OpCodes.Brfalse_S, originalCodeLabel),\n            new(OpCodes.Ldc_I4_0),\n            new(OpCodes.Stloc, loopIndexVar),\n            new(OpCodes.Br_S, loopCheckLabel),\n            new CodeInstruction(OpCodes.Nop).WithLabels(loopStartLabel),\n            new(OpCodes.Ldloc, compListVar),\n            new(OpCodes.Ldloc, loopIndexVar),\n            new(OpCodes.Callvirt, listGetItemMethod),\n            new(OpCodes.Stloc, currentCompVar),\n            new(OpCodes.Ldloc, currentCompVar),\n            new(OpCodes.Isinst, typeof(CompDynamicGraphic))\n        };\n\n        var foundCompLabel = il.DefineLabel();\n        code.Add(new CodeInstruction(OpCodes.Brtrue_S, foundCompLabel));\n\n        var incrementLabel = il.DefineLabel();\n        code.Add(new CodeInstruction(OpCodes.Nop).WithLabels(incrementLabel));\n        code.Add(new CodeInstruction(OpCodes.Ldloc, loopIndexVar));\n        code.Add(new CodeInstruction(OpCodes.Ldc_I4_1));\n        code.Add(new CodeInstruction(OpCodes.Add));\n        code.Add(new CodeInstruction(OpCodes.Stloc, loopIndexVar));\n\n        code.Add(new CodeInstruction(OpCodes.Nop).WithLabels(loopCheckLabel));\n        code.Add(new CodeInstruction(OpCodes.Ldloc, loopIndexVar));\n        code.Add(new CodeInstruction(OpCodes.Ldloc, compListVar));\n        code.Add(new CodeInstruction(OpCodes.Callvirt, listGetCountMethod));\n        code.Add(new CodeInstruction(OpCodes.Blt_S, loopStartLabel));\n\n        code.Add(new CodeInstruction(OpCodes.Br_S, originalCodeLabel));\n\n        code.Add(new CodeInstruction(OpCodes.Nop).WithLabels(foundCompLabel));\n        code.Add(new CodeInstruction(OpCodes.Ldloc, currentCompVar));\n        code.Add(new CodeInstruction(OpCodes.Isinst, typeof(CompDynamicGraphic)));\n        code.Add(new CodeInstruction(OpCodes.Callvirt, getDynamicGraphicMethod));\n        code.Add(new CodeInstruction(OpCodes.Ret));\n\n        var originalInstructions = instructions.ToList();\n        if (originalInstructions.Any()) {\n            originalInstructions.First().labels.Add(originalCodeLabel);\n        }\n\n        code.AddRange(originalInstructions);\n\n        return code.AsEnumerable();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_Thing_Graphic.cs",
    "startLine": 9,
    "attributes": ["HarmonyTranspiler"],
    "attributeDetails": ["HarmonyTranspiler"],
    "implementedInterfaces": [],
    "calls": [
      "M:HarmonyLib.AccessTools.Method(System.Type,System.String,System.Type[],System.Type[])",
      "M:HarmonyLib.AccessTools.Field(System.Type,System.String)",
      "M:System.Reflection.Emit.ILGenerator.DeclareLocal(System.Type)",
      "M:System.Reflection.Emit.ILGenerator.DefineLabel",
      "M:HarmonyLib.CodeInstructionExtensions.WithLabels(System.Reflection.Emit.Label[])",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:System.Linq.Enumerable.ToList``1",
      "M:Verse.GenCollection.Any``1",
      "M:System.Linq.Enumerable.First``1",
      "M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})",
      "M:System.Linq.Enumerable.AsEnumerable``1",
      "M:System.Collections.Generic.List`1.#ctor",
      "M:HarmonyLib.CodeInstruction.#ctor(System.Reflection.Emit.OpCode,System.Object)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Transpiler_Thing_Graphic",
    "name": "Transpiler_Thing_Graphic",
    "fullName": "CWF.HarmonyPatches.Transpiler_Thing_Graphic",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(Thing), nameof(Thing.Graphic), MethodType.Getter)]\npublic static class Transpiler_Thing_Graphic {\n    [HarmonyTranspiler]\n    public static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions, ILGenerator il) {\n        var getDynamicGraphicMethod = AccessTools.Method(typeof(CompDynamicGraphic),\n            nameof(CompDynamicGraphic.GetDynamicGraphic));\n        var compsField = AccessTools.Field(typeof(ThingWithComps), \"comps\");\n        var listGetItemMethod = AccessTools.Method(typeof(List<ThingComp>), \"get_Item\");\n        var listGetCountMethod = AccessTools.Method(typeof(List<ThingComp>), \"get_Count\");\n\n        var thingWithCompsVar = il.DeclareLocal(typeof(ThingWithComps));\n        var compListVar = il.DeclareLocal(typeof(List<ThingComp>));\n        var loopIndexVar = il.DeclareLocal(typeof(int));\n        var currentCompVar = il.DeclareLocal(typeof(ThingComp));\n\n        var originalCodeLabel = il.DefineLabel();\n        var loopStartLabel = il.DefineLabel();\n        var loopCheckLabel = il.DefineLabel();\n\n        var code = new List<CodeInstruction> {\n            new(OpCodes.Ldarg_0),\n            new(OpCodes.Isinst, typeof(ThingWithComps)),\n            new(OpCodes.Stloc, thingWithCompsVar),\n            new(OpCodes.Ldloc, thingWithCompsVar),\n            new(OpCodes.Brfalse_S, originalCodeLabel),\n            new(OpCodes.Ldloc, thingWithCompsVar),\n            new(OpCodes.Ldfld, compsField),\n            new(OpCodes.Stloc, compListVar),\n            new(OpCodes.Ldloc, compListVar),\n            new(OpCodes.Brfalse_S, originalCodeLabel),\n            new(OpCodes.Ldc_I4_0),\n            new(OpCodes.Stloc, loopIndexVar),\n            new(OpCodes.Br_S, loopCheckLabel),\n            new CodeInstruction(OpCodes.Nop).WithLabels(loopStartLabel),\n            new(OpCodes.Ldloc, compListVar),\n            new(OpCodes.Ldloc, loopIndexVar),\n            new(OpCodes.Callvirt, listGetItemMethod),\n            new(OpCodes.Stloc, currentCompVar),\n            new(OpCodes.Ldloc, currentCompVar),\n            new(OpCodes.Isinst, typeof(CompDynamicGraphic))\n        };\n\n        var foundCompLabel = il.DefineLabel();\n        code.Add(new CodeInstruction(OpCodes.Brtrue_S, foundCompLabel));\n\n        var incrementLabel = il.DefineLabel();\n        code.Add(new CodeInstruction(OpCodes.Nop).WithLabels(incrementLabel));\n        code.Add(new CodeInstruction(OpCodes.Ldloc, loopIndexVar));\n        code.Add(new CodeInstruction(OpCodes.Ldc_I4_1));\n        code.Add(new CodeInstruction(OpCodes.Add));\n        code.Add(new CodeInstruction(OpCodes.Stloc, loopIndexVar));\n\n        code.Add(new CodeInstruction(OpCodes.Nop).WithLabels(loopCheckLabel));\n        code.Add(new CodeInstruction(OpCodes.Ldloc, loopIndexVar));\n        code.Add(new CodeInstruction(OpCodes.Ldloc, compListVar));\n        code.Add(new CodeInstruction(OpCodes.Callvirt, listGetCountMethod));\n        code.Add(new CodeInstruction(OpCodes.Blt_S, loopStartLabel));\n\n        code.Add(new CodeInstruction(OpCodes.Br_S, originalCodeLabel));\n\n        code.Add(new CodeInstruction(OpCodes.Nop).WithLabels(foundCompLabel));\n        code.Add(new CodeInstruction(OpCodes.Ldloc, currentCompVar));\n        code.Add(new CodeInstruction(OpCodes.Isinst, typeof(CompDynamicGraphic)));\n        code.Add(new CodeInstruction(OpCodes.Callvirt, getDynamicGraphicMethod));\n        code.Add(new CodeInstruction(OpCodes.Ret));\n\n        var originalInstructions = instructions.ToList();\n        if (originalInstructions.Any()) {\n            originalInstructions.First().labels.Add(originalCodeLabel);\n        }\n\n        code.AddRange(originalInstructions);\n\n        return code.AsEnumerable();\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_Thing_Graphic.cs",
    "startLine": 7,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(Thing), nameof(Thing.Graphic), MethodType.Getter)"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Postfix_ThingDef_SpecialDisplayStats_Modules.Postfix(System.Collections.Generic.IEnumerable{RimWorld.StatDrawEntry},Verse.ThingDef)",
    "name": "Postfix",
    "fullName": "CWF.HarmonyPatches.Postfix_ThingDef_SpecialDisplayStats_Modules.Postfix(System.Collections.Generic.IEnumerable<RimWorld.StatDrawEntry>, Verse.ThingDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static IEnumerable<StatDrawEntry> Postfix(IEnumerable<StatDrawEntry> __result, ThingDef __instance) {\n        foreach (var entry in __result) {\n            yield return entry;\n        }\n\n        var ext = __instance.GetModExtension<TraitModuleExtension>();\n        if (ext?.weaponTraitDef == null) yield break;\n\n        var traitDef = ext.weaponTraitDef;\n        var part = ext.part;\n\n        var sb = new StringBuilder();\n        var effect = traitDef.GetTraitEffect();\n\n        if (effect.Any()) {\n            sb.AppendLine(\"CWF_UI_ModuleEffectsDesc\".Translate(traitDef.Named(\"MODULE\")) + \":\");\n            sb.AppendLine();\n            sb.AppendLine(effect);\n            sb.AppendLine();\n        }\n\n        sb.AppendLine(\"CWF_UI_PartOf\".Translate() + \": \" + part.LabelCap);\n\n        yield return new StatDrawEntry(\n            StatCategoryDefOf.BasicsImportant,\n            \"CWF_UI_ModuleEffects\".Translate(),\n            traitDef.LabelCap,\n            sb.ToString().TrimEndNewlines(),\n            1000\n        );\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_ThingDef_SpecialDisplayStats_Modules.cs",
    "startLine": 12,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Def.GetModExtension``1",
      "M:CWF.ModuleDatabase.GetTraitEffect",
      "M:System.Linq.Enumerable.Any``1",
      "M:System.Text.StringBuilder.AppendLine(System.String)",
      "M:Verse.TranslatorFormattedStringExtensions.Translate(Verse.NamedArgument)",
      "M:Verse.NamedArgumentUtility.Named(System.String)",
      "M:System.Text.StringBuilder.AppendLine",
      "M:Verse.Translator.Translate",
      "M:Verse.GenText.TrimEndNewlines",
      "M:System.Text.StringBuilder.ToString",
      "M:System.Text.StringBuilder.#ctor",
      "M:RimWorld.StatDrawEntry.#ctor(RimWorld.StatCategoryDef,System.String,System.String,System.String,System.Int32,System.String,System.Collections.Generic.IEnumerable{Verse.Dialog_InfoCard.Hyperlink},System.Boolean,System.Boolean)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Postfix_ThingDef_SpecialDisplayStats_Modules",
    "name": "Postfix_ThingDef_SpecialDisplayStats_Modules",
    "fullName": "CWF.HarmonyPatches.Postfix_ThingDef_SpecialDisplayStats_Modules",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(ThingDef), nameof(ThingDef.SpecialDisplayStats))]\npublic static class Postfix_ThingDef_SpecialDisplayStats_Modules {\n    public static IEnumerable<StatDrawEntry> Postfix(IEnumerable<StatDrawEntry> __result, ThingDef __instance) {\n        foreach (var entry in __result) {\n            yield return entry;\n        }\n\n        var ext = __instance.GetModExtension<TraitModuleExtension>();\n        if (ext?.weaponTraitDef == null) yield break;\n\n        var traitDef = ext.weaponTraitDef;\n        var part = ext.part;\n\n        var sb = new StringBuilder();\n        var effect = traitDef.GetTraitEffect();\n\n        if (effect.Any()) {\n            sb.AppendLine(\"CWF_UI_ModuleEffectsDesc\".Translate(traitDef.Named(\"MODULE\")) + \":\");\n            sb.AppendLine();\n            sb.AppendLine(effect);\n            sb.AppendLine();\n        }\n\n        sb.AppendLine(\"CWF_UI_PartOf\".Translate() + \": \" + part.LabelCap);\n\n        yield return new StatDrawEntry(\n            StatCategoryDefOf.BasicsImportant,\n            \"CWF_UI_ModuleEffects\".Translate(),\n            traitDef.LabelCap,\n            sb.ToString().TrimEndNewlines(),\n            1000\n        );\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_ThingDef_SpecialDisplayStats_Modules.cs",
    "startLine": 10,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(ThingDef), nameof(ThingDef.SpecialDisplayStats))"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Postfix_Projectile_Launch_StoppingPower.Postfix(Verse.Projectile,Verse.Thing)",
    "name": "Postfix",
    "fullName": "CWF.HarmonyPatches.Postfix_Projectile_Launch_StoppingPower.Postfix(Verse.Projectile, Verse.Thing?)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static void Postfix(Projectile __instance, Thing? equipment) {\n        if (equipment == null || !equipment.TryGetComp<CompDynamicTraits>(out var comp)) return;\n\n        foreach (var trait in comp.Traits) {\n            if (!Mathf.Approximately(trait.additionalStoppingPower, 0.0f)) {\n                __instance.stoppingPower += trait.additionalStoppingPower;\n            }\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_Projectile_Launch_StoppingPower.cs",
    "startLine": 17,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingCompUtility.TryGetComp``1(``0@)",
      "M:UnityEngine.Mathf.Approximately(System.Single,System.Single)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Postfix_Projectile_Launch_StoppingPower",
    "name": "Postfix_Projectile_Launch_StoppingPower",
    "fullName": "CWF.HarmonyPatches.Postfix_Projectile_Launch_StoppingPower",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(\n    typeof(Projectile),\n    nameof(Projectile.Launch), new[] {\n        typeof(Thing), typeof(Vector3), typeof(LocalTargetInfo), typeof(LocalTargetInfo),\n        typeof(ProjectileHitFlags), typeof(bool), typeof(Thing), typeof(ThingDef)\n    }\n)]\npublic static class Postfix_Projectile_Launch_StoppingPower {\n    public static void Postfix(Projectile __instance, Thing? equipment) {\n        if (equipment == null || !equipment.TryGetComp<CompDynamicTraits>(out var comp)) return;\n\n        foreach (var trait in comp.Traits) {\n            if (!Mathf.Approximately(trait.additionalStoppingPower, 0.0f)) {\n                __instance.stoppingPower += trait.additionalStoppingPower;\n            }\n        }\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_Projectile_Launch_StoppingPower.cs",
    "startLine": 9,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(\n    typeof(Projectile),\n    nameof(Projectile.Launch), new[] {\n        typeof(Thing), typeof(Vector3), typeof(LocalTargetInfo), typeof(LocalTargetInfo),\n        typeof(ProjectileHitFlags), typeof(bool), typeof(Thing), typeof(ThingDef)\n    }\n)"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Postfix_CompColorable_ForceColor.Postfix(Verse.ThingComp,System.Nullable{UnityEngine.Color}@)",
    "name": "Postfix",
    "fullName": "CWF.HarmonyPatches.Postfix_CompColorable_ForceColor.Postfix(Verse.ThingComp, ref UnityEngine.Color?)",
    "type": "Method",
    "baseType": null,
    "codeBody": "[HarmonyPostfix]\n    public static void Postfix(ThingComp __instance, ref Color? __result) {\n        if (__result.HasValue && __instance.parent.TryGetComp<CompDynamicGraphic>() != null) {\n            __result = Color.white;\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_CompColorable_ForceColor.cs",
    "startLine": 11,
    "attributes": ["HarmonyPostfix"],
    "attributeDetails": ["HarmonyPostfix"],
    "implementedInterfaces": [],
    "calls": ["M:Verse.ThingCompUtility.TryGetComp``1"],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Postfix_CompColorable_ForceColor",
    "name": "Postfix_CompColorable_ForceColor",
    "fullName": "CWF.HarmonyPatches.Postfix_CompColorable_ForceColor",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(CompColorable), nameof(CompColorable.ForceColor))]\npublic static class Postfix_CompColorable_ForceColor {\n    [HarmonyPostfix]\n    public static void Postfix(ThingComp __instance, ref Color? __result) {\n        if (__result.HasValue && __instance.parent.TryGetComp<CompDynamicGraphic>() != null) {\n            __result = Color.white;\n        }\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_CompColorable_ForceColor.cs",
    "startLine": 9,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(CompColorable), nameof(CompColorable.ForceColor))"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.Settings.ExposeData",
    "name": "ExposeData",
    "fullName": "CWF.Settings.ExposeData()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void ExposeData() {\n        base.ExposeData();\n        Scribe_Values.Look(ref RandomModulesEnabled, \"randomModulesEnabled\", DefaultRandomModulesEnabled);\n        Scribe_Values.Look(ref MinRandomModules, \"minRandomModules\", DefaultMinRandomModules);\n        Scribe_Values.Look(ref MaxRandomModules, \"maxRandomModules\", DefaultMaxRandomModules);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/Settings.cs",
    "startLine": 20,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ModSettings.ExposeData",
      "M:Verse.Scribe_Values.Look``1(``0@,System.String,``0,System.Boolean)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.Settings.Reset",
    "name": "Reset",
    "fullName": "CWF.Settings.Reset()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void Reset() {\n        RandomModulesEnabled = DefaultRandomModulesEnabled;\n        MinRandomModules = DefaultMinRandomModules;\n        MaxRandomModules = DefaultMaxRandomModules;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/Settings.cs",
    "startLine": 14,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": [
      "M:CWF.ConfigWindow.DoSettingsWindowContents(UnityEngine.Rect)"
    ]
  },
  {
    "id": "T:CWF.Settings",
    "name": "Settings",
    "fullName": "CWF.Settings",
    "type": "Class",
    "baseType": "Verse.ModSettings",
    "codeBody": "public class Settings : ModSettings {\n    private const bool DefaultRandomModulesEnabled = true;\n    private const int DefaultMinRandomModules = 0;\n    private const int DefaultMaxRandomModules = 3;\n\n    public bool RandomModulesEnabled = DefaultRandomModulesEnabled;\n    public int MinRandomModules = DefaultMinRandomModules;\n    public int MaxRandomModules = DefaultMaxRandomModules;\n\n    public void Reset() {\n        RandomModulesEnabled = DefaultRandomModulesEnabled;\n        MinRandomModules = DefaultMinRandomModules;\n        MaxRandomModules = DefaultMaxRandomModules;\n    }\n\n    public override void ExposeData() {\n        base.ExposeData();\n        Scribe_Values.Look(ref RandomModulesEnabled, \"randomModulesEnabled\", DefaultRandomModulesEnabled);\n        Scribe_Values.Look(ref MinRandomModules, \"minRandomModules\", DefaultMinRandomModules);\n        Scribe_Values.Look(ref MaxRandomModules, \"maxRandomModules\", DefaultMaxRandomModules);\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/Settings.cs",
    "startLine": 5,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.TraitEquippedOffsets.GetApplicableTraits(RimWorld.StatRequest)",
    "name": "GetApplicableTraits",
    "fullName": "CWF.TraitEquippedOffsets.GetApplicableTraits(RimWorld.StatRequest)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private IReadOnlyCollection<WeaponTraitDef>? GetApplicableTraits(StatRequest req) {\n        if (!req.HasThing || req.Thing is not Pawn pawn) return null;\n\n        var weapon = pawn.equipment?.Primary;\n        if (weapon == null) return null;\n\n        var traits = weapon.TryGetComp<CompDynamicTraits>()?.Traits;\n        if (traits.IsNullOrEmpty()) return null;\n\n        var applicableTraits = traits\n            .Where(trait =>\n                trait != null &&\n                trait.equippedStatOffsets?.Any(m => m?.stat == parentStat) == true)\n            .ToList();\n\n        return !applicableTraits.IsNullOrEmpty() ? applicableTraits : null;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/StatParts/TraitEquippedOffsets.cs",
    "startLine": 79,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:CWF.Extensions.Extensions.IsNullOrEmpty``1",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:Verse.GenCollection.Any``1(System.Predicate{``0})"
    ],
    "calledBy": [
      "M:CWF.TraitEquippedOffsets.GetInfoCardHyperlinks(RimWorld.StatRequest)",
      "M:CWF.TraitEquippedOffsets.ExplanationPart(RimWorld.StatRequest)",
      "M:CWF.TraitEquippedOffsets.TransformValue(RimWorld.StatRequest,System.Single@)"
    ]
  },
  {
    "id": "M:CWF.TraitEquippedOffsets.Inject",
    "name": "Inject",
    "fullName": "CWF.TraitEquippedOffsets.Inject()",
    "type": "Method",
    "baseType": null,
    "codeBody": "internal static void Inject() {\n        var targets = DefDatabase<StatDef>.AllDefsListForReading\n            .Where(stat => stat.showOnPawns && stat.showOnHumanlikes)\n            .ToList();\n\n        if (targets.IsNullOrEmpty()) {\n            Log.Warning(\"[CWF] No suitable StatDefs found to inject TraitEquippedOffsets.\");\n            return;\n        }\n\n        foreach (var stat in targets) {\n            // try {\n            stat.parts ??= [];\n            if (stat.parts.Any(p => p is TraitEquippedOffsets)) continue;\n\n            stat.parts.Add(new TraitEquippedOffsets { parentStat = stat });\n            // } catch (Exception e) {\n            // Log.Error($\"[CWF] Failed to inject TraitEquippedOffsets into '{stat?.defName}': {e}\");\n            // }\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/StatParts/TraitEquippedOffsets.cs",
    "startLine": 56,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:CWF.Extensions.Extensions.IsNullOrEmpty``1",
      "M:Verse.Log.Warning(System.String)",
      "M:Verse.GenCollection.Any``1(System.Predicate{``0})",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:CWF.TraitEquippedOffsets.#ctor"
    ],
    "calledBy": ["M:CWF.CustomizeWeaponFramework.#cctor"]
  },
  {
    "id": "M:CWF.TraitEquippedOffsets.GetInfoCardHyperlinks(RimWorld.StatRequest)",
    "name": "GetInfoCardHyperlinks",
    "fullName": "CWF.TraitEquippedOffsets.GetInfoCardHyperlinks(RimWorld.StatRequest)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override IEnumerable<Dialog_InfoCard.Hyperlink> GetInfoCardHyperlinks(StatRequest req) {\n        var traits = GetApplicableTraits(req);\n\n        if (traits == null) yield break;\n\n        var seenModules = new HashSet<ThingDef>();\n        foreach (var trait in traits) {\n            if (trait.TryGetModuleDef(out var moduleDef) && seenModules.Add(moduleDef)) {\n                yield return new Dialog_InfoCard.Hyperlink(moduleDef);\n            }\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/StatParts/TraitEquippedOffsets.cs",
    "startLine": 43,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.TraitEquippedOffsets.GetApplicableTraits(RimWorld.StatRequest)",
      "M:CWF.ModuleDatabase.TryGetModuleDef(Verse.ThingDef@)",
      "M:System.Collections.Generic.HashSet`1.Add(`0)",
      "M:System.Collections.Generic.HashSet`1.#ctor",
      "M:Verse.Dialog_InfoCard.Hyperlink.#ctor(Verse.Def,System.Int32)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.TraitEquippedOffsets.ExplanationPart(RimWorld.StatRequest)",
    "name": "ExplanationPart",
    "fullName": "CWF.TraitEquippedOffsets.ExplanationPart(RimWorld.StatRequest)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override string ExplanationPart(StatRequest req) {\n        var traits = GetApplicableTraits(req);\n        if (traits == null) return string.Empty;\n\n        var sb = new StringBuilder();\n        sb.AppendLine();\n        sb.Append(\"CWF_UI_FromEquipped\".Translate());\n\n        foreach (var trait in traits) {\n            var localOffset = trait.equippedStatOffsets?\n                .Where(mod => mod?.stat == parentStat)\n                .Sum(mod => mod.value) ?? 0f;\n\n            if (localOffset == 0f) continue;\n\n            var valueStr = parentStat.ValueToString(localOffset, numberSense: ToStringNumberSense.Offset);\n            sb.AppendInNewLine($\"    {trait.LabelCap}: {valueStr}\"); // consistent with interface format\n        }\n        \n        sb.AppendLine();\n\n        return sb.ToString();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/StatParts/TraitEquippedOffsets.cs",
    "startLine": 19,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.TraitEquippedOffsets.GetApplicableTraits(RimWorld.StatRequest)",
      "M:System.Text.StringBuilder.AppendLine",
      "M:System.Text.StringBuilder.Append(System.String)",
      "M:Verse.Translator.Translate",
      "M:System.Linq.Enumerable.Sum``1(System.Func{``0,System.Single})",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:RimWorld.StatDef.ValueToString(System.Single,Verse.ToStringNumberSense,System.Boolean)",
      "M:Verse.GenText.AppendInNewLine(System.String)",
      "M:System.Text.StringBuilder.ToString",
      "M:System.Text.StringBuilder.#ctor"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.TraitEquippedOffsets.TransformValue(RimWorld.StatRequest,System.Single@)",
    "name": "TransformValue",
    "fullName": "CWF.TraitEquippedOffsets.TransformValue(RimWorld.StatRequest, ref float)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void TransformValue(StatRequest req, ref float val) {\n        var traits = GetApplicableTraits(req);\n        if (traits == null) return;\n\n        var totalOffset = traits.Sum(trait => trait.equippedStatOffsets?.Where(m => m?.stat == parentStat)\n            .Sum(m => m.value) ?? 0f);\n\n        val += totalOffset;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/StatParts/TraitEquippedOffsets.cs",
    "startLine": 9,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.TraitEquippedOffsets.GetApplicableTraits(RimWorld.StatRequest)",
      "M:System.Linq.Enumerable.Sum``1(System.Func{``0,System.Single})",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.TraitEquippedOffsets",
    "name": "TraitEquippedOffsets",
    "fullName": "CWF.TraitEquippedOffsets",
    "type": "Class",
    "baseType": "RimWorld.StatPart",
    "codeBody": "public class TraitEquippedOffsets : StatPart {\n    public override void TransformValue(StatRequest req, ref float val) {\n        var traits = GetApplicableTraits(req);\n        if (traits == null) return;\n\n        var totalOffset = traits.Sum(trait => trait.equippedStatOffsets?.Where(m => m?.stat == parentStat)\n            .Sum(m => m.value) ?? 0f);\n\n        val += totalOffset;\n    }\n\n    public override string ExplanationPart(StatRequest req) {\n        var traits = GetApplicableTraits(req);\n        if (traits == null) return string.Empty;\n\n        var sb = new StringBuilder();\n        sb.AppendLine();\n        sb.Append(\"CWF_UI_FromEquipped\".Translate());\n\n        foreach (var trait in traits) {\n            var localOffset = trait.equippedStatOffsets?\n                .Where(mod => mod?.stat == parentStat)\n                .Sum(mod => mod.value) ?? 0f;\n\n            if (localOffset == 0f) continue;\n\n            var valueStr = parentStat.ValueToString(localOffset, numberSense: ToStringNumberSense.Offset);\n            sb.AppendInNewLine($\"    {trait.LabelCap}: {valueStr}\"); // consistent with interface format\n        }\n        \n        sb.AppendLine();\n\n        return sb.ToString();\n    }\n\n    public override IEnumerable<Dialog_InfoCard.Hyperlink> GetInfoCardHyperlinks(StatRequest req) {\n        var traits = GetApplicableTraits(req);\n\n        if (traits == null) yield break;\n\n        var seenModules = new HashSet<ThingDef>();\n        foreach (var trait in traits) {\n            if (trait.TryGetModuleDef(out var moduleDef) && seenModules.Add(moduleDef)) {\n                yield return new Dialog_InfoCard.Hyperlink(moduleDef);\n            }\n        }\n    }\n\n    internal static void Inject() {\n        var targets = DefDatabase<StatDef>.AllDefsListForReading\n            .Where(stat => stat.showOnPawns && stat.showOnHumanlikes)\n            .ToList();\n\n        if (targets.IsNullOrEmpty()) {\n            Log.Warning(\"[CWF] No suitable StatDefs found to inject TraitEquippedOffsets.\");\n            return;\n        }\n\n        foreach (var stat in targets) {\n            // try {\n            stat.parts ??= [];\n            if (stat.parts.Any(p => p is TraitEquippedOffsets)) continue;\n\n            stat.parts.Add(new TraitEquippedOffsets { parentStat = stat });\n            // } catch (Exception e) {\n            // Log.Error($\"[CWF] Failed to inject TraitEquippedOffsets into '{stat?.defName}': {e}\");\n            // }\n        }\n    }\n\n    // helper\n    private IReadOnlyCollection<WeaponTraitDef>? GetApplicableTraits(StatRequest req) {\n        if (!req.HasThing || req.Thing is not Pawn pawn) return null;\n\n        var weapon = pawn.equipment?.Primary;\n        if (weapon == null) return null;\n\n        var traits = weapon.TryGetComp<CompDynamicTraits>()?.Traits;\n        if (traits.IsNullOrEmpty()) return null;\n\n        var applicableTraits = traits\n            .Where(trait =>\n                trait != null &&\n                trait.equippedStatOffsets?.Any(m => m?.stat == parentStat) == true)\n            .ToList();\n\n        return !applicableTraits.IsNullOrEmpty() ? applicableTraits : null;\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/StatParts/TraitEquippedOffsets.cs",
    "startLine": 8,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.JobGiver_ModifyWeapon.GetUniqueLoadID",
    "name": "GetUniqueLoadID",
    "fullName": "CWF.JobGiver_ModifyWeapon.GetUniqueLoadID()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public string GetUniqueLoadID() {\n        if (_loadID == -1) {\n            _loadID = Find.UniqueIDsManager.GetNextThingID();\n        }\n\n        return $\"JobGiver_ModifyWeapon_{_loadID}\";\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobGivers/JobGiver_ModifyWeapon.cs",
    "startLine": 17,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:RimWorld.UniqueIDsManager.GetNextThingID"],
    "calledBy": []
  },
  {
    "id": "M:CWF.JobGiver_ModifyWeapon.ExposeData",
    "name": "ExposeData",
    "fullName": "CWF.JobGiver_ModifyWeapon.ExposeData()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void ExposeData() {\n        Scribe_Collections.Look(ref ModDataList, \"modDataList\", LookMode.Deep);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobGivers/JobGiver_ModifyWeapon.cs",
    "startLine": 13,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Scribe_Collections.Look``1(System.Collections.Generic.List{``0}@,System.String,Verse.LookMode,System.Object[])"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.JobGiver_ModifyWeapon.TryGiveJob(Verse.Pawn)",
    "name": "TryGiveJob",
    "fullName": "CWF.JobGiver_ModifyWeapon.TryGiveJob(Verse.Pawn)",
    "type": "Method",
    "baseType": null,
    "codeBody": "protected override Job? TryGiveJob(Pawn pawn) => null;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobGivers/JobGiver_ModifyWeapon.cs",
    "startLine": 11,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.JobGiver_ModifyWeapon",
    "name": "JobGiver_ModifyWeapon",
    "fullName": "CWF.JobGiver_ModifyWeapon",
    "type": "Class",
    "baseType": "Verse.AI.ThinkNode_JobGiver",
    "codeBody": "public class JobGiver_ModifyWeapon : ThinkNode_JobGiver, IExposable, ILoadReferenceable {\n    public List<ModificationData> ModDataList = []; // for transfer of data\n    private int _loadID = -1;\n\n    // This method must be overridden, but will never be invoked via the AI tree.\n    protected override Job? TryGiveJob(Pawn pawn) => null;\n\n    public void ExposeData() {\n        Scribe_Collections.Look(ref ModDataList, \"modDataList\", LookMode.Deep);\n    }\n\n    public string GetUniqueLoadID() {\n        if (_loadID == -1) {\n            _loadID = Find.UniqueIDsManager.GetNextThingID();\n        }\n\n        return $\"JobGiver_ModifyWeapon_{_loadID}\";\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobGivers/JobGiver_ModifyWeapon.cs",
    "startLine": 6,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": ["IExposable", "ILoadReferenceable"],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Postfix_Pawn_EquipmentTracker_GetGizmos.Postfix(System.Collections.Generic.IEnumerable{Verse.Gizmo},Verse.Pawn_EquipmentTracker)",
    "name": "Postfix",
    "fullName": "CWF.HarmonyPatches.Postfix_Pawn_EquipmentTracker_GetGizmos.Postfix(System.Collections.Generic.IEnumerable<Verse.Gizmo>, Verse.Pawn_EquipmentTracker)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static IEnumerable<Gizmo> Postfix(IEnumerable<Gizmo> __result, Pawn_EquipmentTracker __instance) {\n        foreach (var gizmo in __result) {\n            yield return gizmo;\n        }\n\n        if (__instance.Primary?.TryGetComp<CompDynamicTraits>() is not { } comp) yield break;\n\n        foreach (var extraGizmo in comp.CompGetEquippedGizmosExtra(__instance.pawn)) {\n            yield return extraGizmo;\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_Pawn_EquipmentTracker_GetGizmos.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:CWF.CompDynamicTraits.CompGetEquippedGizmosExtra(Verse.Pawn)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Postfix_Pawn_EquipmentTracker_GetGizmos",
    "name": "Postfix_Pawn_EquipmentTracker_GetGizmos",
    "fullName": "CWF.HarmonyPatches.Postfix_Pawn_EquipmentTracker_GetGizmos",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(Pawn_EquipmentTracker), nameof(Pawn_EquipmentTracker.GetGizmos))]\npublic static class Postfix_Pawn_EquipmentTracker_GetGizmos {\n    public static IEnumerable<Gizmo> Postfix(IEnumerable<Gizmo> __result, Pawn_EquipmentTracker __instance) {\n        foreach (var gizmo in __result) {\n            yield return gizmo;\n        }\n\n        if (__instance.Primary?.TryGetComp<CompDynamicTraits>() is not { } comp) yield break;\n\n        foreach (var extraGizmo in comp.CompGetEquippedGizmosExtra(__instance.pawn)) {\n            yield return extraGizmo;\n        }\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_Pawn_EquipmentTracker_GetGizmos.cs",
    "startLine": 8,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(Pawn_EquipmentTracker), nameof(Pawn_EquipmentTracker.GetGizmos))"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.Extensions.Extensions.IsNullOrEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})",
    "name": "IsNullOrEmpty",
    "fullName": "CWF.Extensions.Extensions.IsNullOrEmpty<T>(System.Collections.Generic.IReadOnlyCollection<T>?)",
    "type": "Method",
    "baseType": null,
    "codeBody": "internal static bool IsNullOrEmpty<T>([NotNullWhen(false)] this IReadOnlyCollection<T>? collection) {\n        return collection == null || collection.Count == 0;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Extensions/Extensions.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.Extensions.Extensions.IsNullOrEmpty(System.String)",
    "name": "IsNullOrEmpty",
    "fullName": "CWF.Extensions.Extensions.IsNullOrEmpty(string?)",
    "type": "Method",
    "baseType": null,
    "codeBody": "internal static bool IsNullOrEmpty([NotNullWhen(false)] this string? str) {\n        return string.IsNullOrEmpty(str);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Extensions/Extensions.cs",
    "startLine": 6,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:System.String.IsNullOrEmpty(System.String)"],
    "calledBy": []
  },
  {
    "id": "T:CWF.Extensions.Extensions",
    "name": "Extensions",
    "fullName": "CWF.Extensions.Extensions",
    "type": "Class",
    "baseType": null,
    "codeBody": "internal static class Extensions {\n    internal static bool IsNullOrEmpty([NotNullWhen(false)] this string? str) {\n        return string.IsNullOrEmpty(str);\n    }\n\n    internal static bool IsNullOrEmpty<T>([NotNullWhen(false)] this IReadOnlyCollection<T>? collection) {\n        return collection == null || collection.Count == 0;\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Extensions/Extensions.cs",
    "startLine": 5,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CustomizeWeaponFramework.#cctor",
    "name": ".cctor",
    "fullName": "CWF.CustomizeWeaponFramework.CustomizeWeaponFramework()",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "static CustomizeWeaponFramework() {\n        var harmony = new Harmony(\"Vortex.CustomizeWeaponFramework\");\n        harmony.PatchAll();\n\n        AdapterDef.Inject();\n        ModuleDatabase.BuildCacheAndInject();\n        TraitEquippedOffsets.Inject();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CustomizeWeaponFramework.cs",
    "startLine": 8,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:HarmonyLib.Harmony.PatchAll",
      "M:CWF.AdapterDef.Inject",
      "M:CWF.ModuleDatabase.BuildCacheAndInject",
      "M:CWF.TraitEquippedOffsets.Inject",
      "M:HarmonyLib.Harmony.#ctor(System.String)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.CustomizeWeaponFramework",
    "name": "CustomizeWeaponFramework",
    "fullName": "CWF.CustomizeWeaponFramework",
    "type": "Class",
    "baseType": null,
    "codeBody": "[StaticConstructorOnStartup]\npublic class CustomizeWeaponFramework {\n    static CustomizeWeaponFramework() {\n        var harmony = new Harmony(\"Vortex.CustomizeWeaponFramework\");\n        harmony.PatchAll();\n\n        AdapterDef.Inject();\n        ModuleDatabase.BuildCacheAndInject();\n        TraitEquippedOffsets.Inject();\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CustomizeWeaponFramework.cs",
    "startLine": 6,
    "attributes": ["StaticConstructorOnStartup"],
    "attributeDetails": ["StaticConstructorOnStartup"],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicGraphic.GetOutlineTexture(CWF.ModuleGraphicData)",
    "name": "GetOutlineTexture",
    "fullName": "CWF.CompDynamicGraphic.GetOutlineTexture(CWF.ModuleGraphicData)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static Texture2D? GetOutlineTexture(ModuleGraphicData graphicData) {\n        string? outlinePathToLoad = null;\n\n        if (!graphicData.outlinePath.NullOrEmpty()) {\n            outlinePathToLoad = graphicData.outlinePath;\n        } else if (!graphicData.texturePath.NullOrEmpty()) {\n            outlinePathToLoad = graphicData.texturePath + \"_o\";\n        }\n\n        return outlinePathToLoad != null ? ContentFinder<Texture2D>.Get(outlinePathToLoad, false) : null;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicGraphic.cs",
    "startLine": 173,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.GenText.NullOrEmpty",
      "M:Verse.ContentFinder`1.Get(System.String,System.Boolean)"
    ],
    "calledBy": [
      "M:CWF.ViewDrawers.MainDrawer.DrawModuleTexture(UnityEngine.Rect@,CWF.ModuleGraphicData)",
      "M:CWF.CompDynamicGraphic.GenerateGraphic"
    ]
  },
  {
    "id": "M:CWF.CompDynamicGraphic.GetMaskTexture(Verse.GraphicData,CWF.AttachmentPointData)",
    "name": "GetMaskTexture",
    "fullName": "CWF.CompDynamicGraphic.GetMaskTexture(Verse.GraphicData, CWF.AttachmentPointData)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static Texture2D? GetMaskTexture(GraphicData graphicData, AttachmentPointData point) {\n        var maskPathToLoad = graphicData.maskPath.NullOrEmpty()\n            ? graphicData.texPath + \"_m\"\n            : graphicData.maskPath;\n\n        return point.receivesColor\n            ? ContentFinder<Texture2D>.Get(maskPathToLoad, false)\n            : null;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicGraphic.cs",
    "startLine": 163,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.GenText.NullOrEmpty",
      "M:Verse.ContentFinder`1.Get(System.String,System.Boolean)"
    ],
    "calledBy": ["M:CWF.CompDynamicGraphic.GenerateGraphic"]
  },
  {
    "id": "M:CWF.CompDynamicGraphic.GenerateGraphic",
    "name": "GenerateGraphic",
    "fullName": "CWF.CompDynamicGraphic.GenerateGraphic()",
    "type": "Method",
    "baseType": null,
    "codeBody": "private Graphic GenerateGraphic() {\n        var originalGraphicData = parent.def.graphicData;\n        if (originalGraphicData == null) return BaseContent.BadGraphic;\n\n        var sizeReference = ContentFinder<Texture2D>.Get(originalGraphicData.texPath, false)\n                            ?? new Texture2D(512, 512);\n\n        var renderTexture = RenderTexture.GetTemporary(sizeReference.width, sizeReference.height, 0);\n\n        var layersToDraw = new List<(Texture2D texture, Vector2 offset, float scale, int sortOrder,\n            Color color, Texture2D? maskTexture)>();\n\n        if (_compDynamicTraits != null) {\n            foreach (var point in Props.attachmentPoints) {\n                if (point.part == null) continue;\n\n                var installedTrait = _compDynamicTraits.GetInstalledTraitFor(point.part);\n                ModuleGraphicData? graphicToRender = null;\n\n                if (installedTrait != null) {\n                    graphicToRender = GetGraphicDataFor(installedTrait);\n                }\n\n                graphicToRender ??= point.baseTexture;\n\n                if (graphicToRender == null) continue;\n\n                var finalOffset = graphicToRender.offset ?? point.baseTexture?.offset ?? Vector2.zero;\n                var finalScale = graphicToRender.scale ?? point.baseTexture?.scale ?? 1f;\n                var baseSortOrder = point.layer * 10;\n\n                // outline\n                var outlineTex = GetOutlineTexture(graphicToRender);\n                if (outlineTex != null) {\n                    layersToDraw.Add((outlineTex, finalOffset, finalScale, baseSortOrder - 999, Color.white, null));\n                }\n\n                // module\n                if (string.IsNullOrEmpty(graphicToRender.texturePath)) continue;\n                var moduleTexture = ContentFinder<Texture2D>.Get(graphicToRender.texturePath, false);\n                if (moduleTexture == null) continue;\n\n                var color = point.receivesColor\n                    ? parent.TryGetComp<CompColorable>()?.ColorDef?.color ?? originalGraphicData.color\n                    : Color.white;\n\n                var mask = GetMaskTexture(originalGraphicData, point);\n\n                layersToDraw.Add((moduleTexture, finalOffset, finalScale, baseSortOrder, color, mask));\n            }\n        }\n\n        RenderTexture.active = renderTexture;\n        GL.Clear(true, true, Color.clear);\n        GL.PushMatrix();\n        GL.LoadPixelMatrix(0, renderTexture.width, renderTexture.height, 0);\n\n        var sortedLayers = layersToDraw.OrderBy(l => l.sortOrder).ToList();\n\n        foreach (var layer in sortedLayers) {\n            var scaledWidth = layer.texture.width * layer.scale;\n            var scaledHeight = layer.texture.height * layer.scale;\n            var y = (renderTexture.height - scaledHeight) - layer.offset.y;\n            var destRect = new Rect(layer.offset.x, y, scaledWidth, scaledHeight);\n\n            if (layer.color != Color.white && originalGraphicData.shaderType?.Shader != null) {\n                var tempMaterial = new Material(originalGraphicData.shaderType.Shader) { color = layer.color };\n                if (tempMaterial.HasProperty(ShaderPropertyIDs.ColorTwo)) {\n                    tempMaterial.SetColor(ShaderPropertyIDs.ColorTwo, layer.color);\n                }\n\n                if (layer.maskTexture != null && tempMaterial.HasProperty(ShaderPropertyIDs.MaskTex)) {\n                    tempMaterial.SetTexture(ShaderPropertyIDs.MaskTex, layer.maskTexture);\n                }\n\n                Graphics.DrawTexture(destRect, layer.texture, tempMaterial);\n                UnityEngine.Object.Destroy(tempMaterial);\n            } else {\n                Graphics.DrawTexture(destRect, layer.texture);\n            }\n        }\n\n        GL.PopMatrix();\n\n        var finalBakedTexture = new Texture2D(renderTexture.width, renderTexture.height);\n        finalBakedTexture.ReadPixels(new Rect(0, 0, renderTexture.width, renderTexture.height), 0, 0);\n        finalBakedTexture.Apply();\n\n        RenderTexture.active = null;\n        RenderTexture.ReleaseTemporary(renderTexture);\n\n        var graphic = new Graphic_Single();\n        var request = new GraphicRequest(\n            typeof(Graphic_Single), finalBakedTexture, ShaderDatabase.Cutout,\n            originalGraphicData.drawSize, Color.white, Color.white,\n            originalGraphicData, 0, null, null\n        );\n\n        graphic.Init(request);\n        return graphic;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicGraphic.cs",
    "startLine": 61,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ContentFinder`1.Get(System.String,System.Boolean)",
      "M:UnityEngine.RenderTexture.GetTemporary(System.Int32,System.Int32,System.Int32)",
      "M:CWF.CompDynamicTraits.GetInstalledTraitFor(CWF.PartDef)",
      "M:CWF.CompDynamicGraphic.GetGraphicDataFor(RimWorld.WeaponTraitDef)",
      "M:CWF.CompDynamicGraphic.GetOutlineTexture(CWF.ModuleGraphicData)",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:System.String.IsNullOrEmpty(System.String)",
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:CWF.CompDynamicGraphic.GetMaskTexture(Verse.GraphicData,CWF.AttachmentPointData)",
      "M:UnityEngine.GL.Clear(System.Boolean,System.Boolean,UnityEngine.Color)",
      "M:UnityEngine.GL.PushMatrix",
      "M:UnityEngine.GL.LoadPixelMatrix(System.Single,System.Single,System.Single,System.Single)",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.OrderBy``2(System.Func{``0,``1})",
      "M:UnityEngine.Material.HasProperty(System.Int32)",
      "M:UnityEngine.Material.SetColor(System.Int32,UnityEngine.Color)",
      "M:UnityEngine.Material.SetTexture(System.Int32,UnityEngine.Texture)",
      "M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture,UnityEngine.Material)",
      "M:UnityEngine.Object.Destroy(UnityEngine.Object)",
      "M:UnityEngine.Graphics.DrawTexture(UnityEngine.Rect,UnityEngine.Texture)",
      "M:UnityEngine.GL.PopMatrix",
      "M:UnityEngine.Texture2D.ReadPixels(UnityEngine.Rect,System.Int32,System.Int32)",
      "M:UnityEngine.Texture2D.Apply",
      "M:UnityEngine.RenderTexture.ReleaseTemporary(UnityEngine.RenderTexture)",
      "M:Verse.Graphic_Single.Init(Verse.GraphicRequest)",
      "M:UnityEngine.Texture2D.#ctor(System.Int32,System.Int32)",
      "M:System.Collections.Generic.List`1.#ctor",
      "M:UnityEngine.Rect.#ctor(System.Single,System.Single,System.Single,System.Single)",
      "M:UnityEngine.Material.#ctor(UnityEngine.Shader)",
      "M:Verse.Graphic_Single.#ctor",
      "M:Verse.GraphicRequest.#ctor(System.Type,UnityEngine.Texture2D,UnityEngine.Shader,UnityEngine.Vector2,UnityEngine.Color,UnityEngine.Color,Verse.GraphicData,System.Int32,System.Collections.Generic.List{Verse.ShaderParameter},System.String)"
    ],
    "calledBy": ["M:CWF.CompDynamicGraphic.GetDynamicGraphic"]
  },
  {
    "id": "M:CWF.CompDynamicGraphic.GetGraphicDataFor(RimWorld.WeaponTraitDef)",
    "name": "GetGraphicDataFor",
    "fullName": "CWF.CompDynamicGraphic.GetGraphicDataFor(RimWorld.WeaponTraitDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public ModuleGraphicData? GetGraphicDataFor(WeaponTraitDef traitDef) {\n        if (!traitDef.TryGetModuleDef(out var moduleDef)) return null;\n\n        var ext = moduleDef.GetModExtension<TraitModuleExtension>();\n        if (ext?.graphicCases.IsNullOrEmpty() ?? true) return null;\n\n        var matchingCases = ext.graphicCases\n            .Where(c => c.matcher != null && c.graphicData != null && c.matcher.IsMatch(parent.def))\n            .ToList();\n\n        if (!matchingCases.Any()) return null;\n\n        var bestCase = matchingCases.MaxBy(c => c.priority);\n        return bestCase.graphicData;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicGraphic.cs",
    "startLine": 44,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.ModuleDatabase.TryGetModuleDef(Verse.ThingDef@)",
      "M:Verse.Def.GetModExtension``1",
      "M:CWF.Extensions.Extensions.IsNullOrEmpty``1",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:CWF.WeaponMatcher.IsMatch(Verse.ThingDef)",
      "M:Verse.GenCollection.Any``1",
      "M:Verse.GenCollection.MaxBy``2(System.Func{``0,``1})"
    ],
    "calledBy": [
      "M:CWF.ViewDrawers.MainDrawer.TryDrawSlot(CWF.PartDef,UnityEngine.Rect@)",
      "M:CWF.CompDynamicGraphic.GenerateGraphic"
    ]
  },
  {
    "id": "M:CWF.CompDynamicGraphic.Notify_ColorChanged",
    "name": "Notify_ColorChanged",
    "fullName": "CWF.CompDynamicGraphic.Notify_ColorChanged()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void Notify_ColorChanged() {\n        base.Notify_ColorChanged();\n        Notify_GraphicDirty();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicGraphic.cs",
    "startLine": 35,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingComp.Notify_ColorChanged",
      "M:CWF.CompDynamicGraphic.Notify_GraphicDirty"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicGraphic.Notify_GraphicDirty",
    "name": "Notify_GraphicDirty",
    "fullName": "CWF.CompDynamicGraphic.Notify_GraphicDirty()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void Notify_GraphicDirty() {\n        _isDirty = true;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicGraphic.cs",
    "startLine": 31,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": [
      "M:CWF.CompDynamicGraphic.Notify_ColorChanged",
      "M:CWF.CompDynamicTraits.OnTraitsChanged"
    ]
  },
  {
    "id": "M:CWF.CompDynamicGraphic.GetDynamicGraphic",
    "name": "GetDynamicGraphic",
    "fullName": "CWF.CompDynamicGraphic.GetDynamicGraphic()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public Graphic GetDynamicGraphic() {\n        if (!_isDirty && _cachedGraphic != null) return _cachedGraphic;\n\n        _cachedGraphic = GenerateGraphic();\n        _isDirty = false;\n\n        return _cachedGraphic;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicGraphic.cs",
    "startLine": 22,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:CWF.CompDynamicGraphic.GenerateGraphic"],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicGraphic.Initialize(Verse.CompProperties)",
    "name": "Initialize",
    "fullName": "CWF.CompDynamicGraphic.Initialize(Verse.CompProperties)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void Initialize(CompProperties properties) {\n        base.Initialize(properties);\n        _compDynamicTraits = parent.TryGetComp<CompDynamicTraits>();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicGraphic.cs",
    "startLine": 17,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingComp.Initialize(Verse.CompProperties)",
      "M:Verse.ThingCompUtility.TryGetComp``1"
    ],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompDynamicGraphic.Props",
    "name": "Props",
    "fullName": "CWF.CompDynamicGraphic.Props",
    "type": "Property",
    "baseType": null,
    "codeBody": "private CompProperties_DynamicGraphic Props => (CompProperties_DynamicGraphic)props;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicGraphic.cs",
    "startLine": 9,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.CompDynamicGraphic",
    "name": "CompDynamicGraphic",
    "fullName": "CWF.CompDynamicGraphic",
    "type": "Class",
    "baseType": "Verse.ThingComp",
    "codeBody": "public class CompDynamicGraphic : ThingComp {\n    private CompProperties_DynamicGraphic Props => (CompProperties_DynamicGraphic)props;\n\n    private Graphic? _cachedGraphic;\n\n    private bool _isDirty = true;\n\n    private CompDynamicTraits? _compDynamicTraits;\n\n    public override void Initialize(CompProperties properties) {\n        base.Initialize(properties);\n        _compDynamicTraits = parent.TryGetComp<CompDynamicTraits>();\n    }\n\n    public Graphic GetDynamicGraphic() {\n        if (!_isDirty && _cachedGraphic != null) return _cachedGraphic;\n\n        _cachedGraphic = GenerateGraphic();\n        _isDirty = false;\n\n        return _cachedGraphic;\n    }\n\n    public void Notify_GraphicDirty() {\n        _isDirty = true;\n    }\n\n    public override void Notify_ColorChanged() {\n        base.Notify_ColorChanged();\n        Notify_GraphicDirty();\n    }\n\n    /// <summary>\n    /// Finds the most suitable graphic data for a given module trait when applied to a specific weapon.\n    /// It resolves the graphic based on the matching rules and priority defined in the module's TraitModuleExtension.\n    /// </summary>\n    public ModuleGraphicData? GetGraphicDataFor(WeaponTraitDef traitDef) {\n        if (!traitDef.TryGetModuleDef(out var moduleDef)) return null;\n\n        var ext = moduleDef.GetModExtension<TraitModuleExtension>();\n        if (ext?.graphicCases.IsNullOrEmpty() ?? true) return null;\n\n        var matchingCases = ext.graphicCases\n            .Where(c => c.matcher != null && c.graphicData != null && c.matcher.IsMatch(parent.def))\n            .ToList();\n\n        if (!matchingCases.Any()) return null;\n\n        var bestCase = matchingCases.MaxBy(c => c.priority);\n        return bestCase.graphicData;\n    }\n\n    // === Helper ===\n    private Graphic GenerateGraphic() {\n        var originalGraphicData = parent.def.graphicData;\n        if (originalGraphicData == null) return BaseContent.BadGraphic;\n\n        var sizeReference = ContentFinder<Texture2D>.Get(originalGraphicData.texPath, false)\n                            ?? new Texture2D(512, 512);\n\n        var renderTexture = RenderTexture.GetTemporary(sizeReference.width, sizeReference.height, 0);\n\n        var layersToDraw = new List<(Texture2D texture, Vector2 offset, float scale, int sortOrder,\n            Color color, Texture2D? maskTexture)>();\n\n        if (_compDynamicTraits != null) {\n            foreach (var point in Props.attachmentPoints) {\n                if (point.part == null) continue;\n\n                var installedTrait = _compDynamicTraits.GetInstalledTraitFor(point.part);\n                ModuleGraphicData? graphicToRender = null;\n\n                if (installedTrait != null) {\n                    graphicToRender = GetGraphicDataFor(installedTrait);\n                }\n\n                graphicToRender ??= point.baseTexture;\n\n                if (graphicToRender == null) continue;\n\n                var finalOffset = graphicToRender.offset ?? point.baseTexture?.offset ?? Vector2.zero;\n                var finalScale = graphicToRender.scale ?? point.baseTexture?.scale ?? 1f;\n                var baseSortOrder = point.layer * 10;\n\n                // outline\n                var outlineTex = GetOutlineTexture(graphicToRender);\n                if (outlineTex != null) {\n                    layersToDraw.Add((outlineTex, finalOffset, finalScale, baseSortOrder - 999, Color.white, null));\n                }\n\n                // module\n                if (string.IsNullOrEmpty(graphicToRender.texturePath)) continue;\n                var moduleTexture = ContentFinder<Texture2D>.Get(graphicToRender.texturePath, false);\n                if (moduleTexture == null) continue;\n\n                var color = point.receivesColor\n                    ? parent.TryGetComp<CompColorable>()?.ColorDef?.color ?? originalGraphicData.color\n                    : Color.white;\n\n                var mask = GetMaskTexture(originalGraphicData, point);\n\n                layersToDraw.Add((moduleTexture, finalOffset, finalScale, baseSortOrder, color, mask));\n            }\n        }\n\n        RenderTexture.active = renderTexture;\n        GL.Clear(true, true, Color.clear);\n        GL.PushMatrix();\n        GL.LoadPixelMatrix(0, renderTexture.width, renderTexture.height, 0);\n\n        var sortedLayers = layersToDraw.OrderBy(l => l.sortOrder).ToList();\n\n        foreach (var layer in sortedLayers) {\n            var scaledWidth = layer.texture.width * layer.scale;\n            var scaledHeight = layer.texture.height * layer.scale;\n            var y = (renderTexture.height - scaledHeight) - layer.offset.y;\n            var destRect = new Rect(layer.offset.x, y, scaledWidth, scaledHeight);\n\n            if (layer.color != Color.white && originalGraphicData.shaderType?.Shader != null) {\n                var tempMaterial = new Material(originalGraphicData.shaderType.Shader) { color = layer.color };\n                if (tempMaterial.HasProperty(ShaderPropertyIDs.ColorTwo)) {\n                    tempMaterial.SetColor(ShaderPropertyIDs.ColorTwo, layer.color);\n                }\n\n                if (layer.maskTexture != null && tempMaterial.HasProperty(ShaderPropertyIDs.MaskTex)) {\n                    tempMaterial.SetTexture(ShaderPropertyIDs.MaskTex, layer.maskTexture);\n                }\n\n                Graphics.DrawTexture(destRect, layer.texture, tempMaterial);\n                UnityEngine.Object.Destroy(tempMaterial);\n            } else {\n                Graphics.DrawTexture(destRect, layer.texture);\n            }\n        }\n\n        GL.PopMatrix();\n\n        var finalBakedTexture = new Texture2D(renderTexture.width, renderTexture.height);\n        finalBakedTexture.ReadPixels(new Rect(0, 0, renderTexture.width, renderTexture.height), 0, 0);\n        finalBakedTexture.Apply();\n\n        RenderTexture.active = null;\n        RenderTexture.ReleaseTemporary(renderTexture);\n\n        var graphic = new Graphic_Single();\n        var request = new GraphicRequest(\n            typeof(Graphic_Single), finalBakedTexture, ShaderDatabase.Cutout,\n            originalGraphicData.drawSize, Color.white, Color.white,\n            originalGraphicData, 0, null, null\n        );\n\n        graphic.Init(request);\n        return graphic;\n    }\n\n    private static Texture2D? GetMaskTexture(GraphicData graphicData, AttachmentPointData point) {\n        var maskPathToLoad = graphicData.maskPath.NullOrEmpty()\n            ? graphicData.texPath + \"_m\"\n            : graphicData.maskPath;\n\n        return point.receivesColor\n            ? ContentFinder<Texture2D>.Get(maskPathToLoad, false)\n            : null;\n    }\n\n    public static Texture2D? GetOutlineTexture(ModuleGraphicData graphicData) {\n        string? outlinePathToLoad = null;\n\n        if (!graphicData.outlinePath.NullOrEmpty()) {\n            outlinePathToLoad = graphicData.outlinePath;\n        } else if (!graphicData.texturePath.NullOrEmpty()) {\n            outlinePathToLoad = graphicData.texturePath + \"_o\";\n        }\n\n        return outlinePathToLoad != null ? ContentFinder<Texture2D>.Get(outlinePathToLoad, false) : null;\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicGraphic.cs",
    "startLine": 8,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Transpiler_Verb_BurstShotCount.ApplyAllMultipliers(System.Single,Verse.Verb)",
    "name": "ApplyAllMultipliers",
    "fullName": "CWF.HarmonyPatches.Transpiler_Verb_BurstShotCount.ApplyAllMultipliers(float, Verse.Verb)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static float ApplyAllMultipliers(float originalNum, Verb verb) {\n        var num = originalNum;\n        var equipment = verb.EquipmentSource;\n\n        if (equipment == null) return num;\n\n        if (equipment.TryGetComp<CompUniqueWeapon>(out var uniqueWeapon)) {\n            var traits = uniqueWeapon.TraitsListForReading;\n            num = traits.Aggregate(num, (cur, t) => cur * t.burstShotCountMultiplier);\n        }\n\n        if (equipment.TryGetComp<CompDynamicTraits>(out var dynamicTraits)) {\n            num = dynamicTraits.Traits.Aggregate(num, (cur, t) => cur * t.burstShotCountMultiplier);\n        }\n\n        return num;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_Verb_BurstShotCount.cs",
    "startLine": 45,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingCompUtility.TryGetComp``1(``0@)",
      "M:System.Linq.Enumerable.Aggregate``2(``1,System.Func{``1,``0,``1})"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Transpiler_Verb_BurstShotCount.Transpiler(System.Collections.Generic.IEnumerable{HarmonyLib.CodeInstruction})",
    "name": "Transpiler",
    "fullName": "CWF.HarmonyPatches.Transpiler_Verb_BurstShotCount.Transpiler(System.Collections.Generic.IEnumerable<HarmonyLib.CodeInstruction>)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions) {\n        var codes = new List<CodeInstruction>(instructions);\n\n        var loopStartIndex = codes.FindIndex(code => code.opcode == OpCodes.Stloc_0) + 1;\n\n        var loopEndIndex = -1;\n        for (var i = loopStartIndex; i < codes.Count; i++) {\n            if (codes[i].opcode != OpCodes.Ldarg_0 ||\n                codes[i + 1].opcode != OpCodes.Ldloc_0 ||\n                codes[i + 2].opcode != OpCodes.Call ||\n                !codes[i + 2].operand.ToString().Contains(\"CeilToInt\")) continue;\n            loopEndIndex = i;\n            break;\n        }\n\n        if (loopStartIndex > 0 && loopEndIndex != -1) {\n            codes.RemoveRange(loopStartIndex, loopEndIndex - loopStartIndex);\n\n            var newInstructions = new List<CodeInstruction> {\n                new(OpCodes.Ldloc_0),\n                new(OpCodes.Ldarg_0),\n                CodeInstruction.Call(typeof(Transpiler_Verb_BurstShotCount), nameof(ApplyAllMultipliers)),\n                new(OpCodes.Stloc_0)\n            };\n\n            codes.InsertRange(loopStartIndex, newInstructions);\n        }\n        else {\n            Log.Error(\n                \"[CWF] Transpiler for Verb.get_BurstShotCount failed. The mod may not function correctly with this version of RimWorld.\");\n        }\n\n        return codes.AsEnumerable();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_Verb_BurstShotCount.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})",
      "M:System.String.Contains(System.String)",
      "M:System.Object.ToString",
      "M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)",
      "M:HarmonyLib.CodeInstruction.Call(System.Type,System.String,System.Type[],System.Type[])",
      "M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})",
      "M:Verse.Log.Error(System.String)",
      "M:System.Linq.Enumerable.AsEnumerable``1",
      "M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})",
      "M:System.Collections.Generic.List`1.#ctor"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Transpiler_Verb_BurstShotCount",
    "name": "Transpiler_Verb_BurstShotCount",
    "fullName": "CWF.HarmonyPatches.Transpiler_Verb_BurstShotCount",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(Verb), nameof(Verb.BurstShotCount), MethodType.Getter)]\npublic static class Transpiler_Verb_BurstShotCount {\n    public static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions) {\n        var codes = new List<CodeInstruction>(instructions);\n\n        var loopStartIndex = codes.FindIndex(code => code.opcode == OpCodes.Stloc_0) + 1;\n\n        var loopEndIndex = -1;\n        for (var i = loopStartIndex; i < codes.Count; i++) {\n            if (codes[i].opcode != OpCodes.Ldarg_0 ||\n                codes[i + 1].opcode != OpCodes.Ldloc_0 ||\n                codes[i + 2].opcode != OpCodes.Call ||\n                !codes[i + 2].operand.ToString().Contains(\"CeilToInt\")) continue;\n            loopEndIndex = i;\n            break;\n        }\n\n        if (loopStartIndex > 0 && loopEndIndex != -1) {\n            codes.RemoveRange(loopStartIndex, loopEndIndex - loopStartIndex);\n\n            var newInstructions = new List<CodeInstruction> {\n                new(OpCodes.Ldloc_0),\n                new(OpCodes.Ldarg_0),\n                CodeInstruction.Call(typeof(Transpiler_Verb_BurstShotCount), nameof(ApplyAllMultipliers)),\n                new(OpCodes.Stloc_0)\n            };\n\n            codes.InsertRange(loopStartIndex, newInstructions);\n        }\n        else {\n            Log.Error(\n                \"[CWF] Transpiler for Verb.get_BurstShotCount failed. The mod may not function correctly with this version of RimWorld.\");\n        }\n\n        return codes.AsEnumerable();\n    }\n\n    private static float ApplyAllMultipliers(float originalNum, Verb verb) {\n        var num = originalNum;\n        var equipment = verb.EquipmentSource;\n\n        if (equipment == null) return num;\n\n        if (equipment.TryGetComp<CompUniqueWeapon>(out var uniqueWeapon)) {\n            var traits = uniqueWeapon.TraitsListForReading;\n            num = traits.Aggregate(num, (cur, t) => cur * t.burstShotCountMultiplier);\n        }\n\n        if (equipment.TryGetComp<CompDynamicTraits>(out var dynamicTraits)) {\n            num = dynamicTraits.Traits.Aggregate(num, (cur, t) => cur * t.burstShotCountMultiplier);\n        }\n\n        return num;\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_Verb_BurstShotCount.cs",
    "startLine": 8,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(Verb), nameof(Verb.BurstShotCount), MethodType.Getter)"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Prefix_Projectile_Launch.Prefix(Verse.Projectile,Verse.Thing)",
    "name": "Prefix",
    "fullName": "CWF.HarmonyPatches.Prefix_Projectile_Launch.Prefix(Verse.Projectile, Verse.Thing?)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static void Prefix(Projectile __instance, Thing? equipment) {\n        if (equipment == null || !equipment.TryGetComp<CompDynamicTraits>(out var compDynamicTraits)) return;\n\n        foreach (var trait in compDynamicTraits.Traits) {\n            if (trait.damageDefOverride != null) {\n                __instance.damageDefOverride = trait.damageDefOverride;\n            }\n\n            if (trait.extraDamages.NullOrEmpty()) continue;\n\n            __instance.extraDamages ??= [];\n            __instance.extraDamages.AddRange(trait.extraDamages);\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Prefix_Projectile_Launch.cs",
    "startLine": 12,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingCompUtility.TryGetComp``1(``0@)",
      "M:Verse.GenList.NullOrEmpty``1",
      "M:System.Collections.Generic.List`1.AddRange(System.Collections.Generic.IEnumerable{`0})"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Prefix_Projectile_Launch",
    "name": "Prefix_Projectile_Launch",
    "fullName": "CWF.HarmonyPatches.Prefix_Projectile_Launch",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(Projectile), nameof(Projectile.Launch), typeof(Thing), typeof(Vector3), typeof(LocalTargetInfo),\n    typeof(LocalTargetInfo), typeof(ProjectileHitFlags), typeof(bool), typeof(Thing), typeof(ThingDef))]\npublic static class Prefix_Projectile_Launch {\n    public static void Prefix(Projectile __instance, Thing? equipment) {\n        if (equipment == null || !equipment.TryGetComp<CompDynamicTraits>(out var compDynamicTraits)) return;\n\n        foreach (var trait in compDynamicTraits.Traits) {\n            if (trait.damageDefOverride != null) {\n                __instance.damageDefOverride = trait.damageDefOverride;\n            }\n\n            if (trait.extraDamages.NullOrEmpty()) continue;\n\n            __instance.extraDamages ??= [];\n            __instance.extraDamages.AddRange(trait.extraDamages);\n        }\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Prefix_Projectile_Launch.cs",
    "startLine": 9,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(Projectile), nameof(Projectile.Launch), typeof(Thing), typeof(Vector3), typeof(LocalTargetInfo),\n    typeof(LocalTargetInfo), typeof(ProjectileHitFlags), typeof(bool), typeof(Thing), typeof(ThingDef))"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Postfix_ThingComp_Notify_Unequipped.Postfix(Verse.ThingComp,Verse.Pawn)",
    "name": "Postfix",
    "fullName": "CWF.HarmonyPatches.Postfix_ThingComp_Notify_Unequipped.Postfix(Verse.ThingComp, Verse.Pawn)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static void Postfix(ThingComp __instance, Pawn pawn) {\n        var compAbilityProvider = __instance.parent.GetComp<CompAbilityProvider>();\n        compAbilityProvider?.OnUnequipped(pawn);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_TingComp_Notify_Unequipped.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingWithComps.GetComp``1",
      "M:CWF.CompAbilityProvider.OnUnequipped(Verse.Pawn)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Postfix_ThingComp_Notify_Unequipped",
    "name": "Postfix_ThingComp_Notify_Unequipped",
    "fullName": "CWF.HarmonyPatches.Postfix_ThingComp_Notify_Unequipped",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(ThingComp), nameof(ThingComp.Notify_Unequipped))]\npublic static class Postfix_ThingComp_Notify_Unequipped {\n    public static void Postfix(ThingComp __instance, Pawn pawn) {\n        var compAbilityProvider = __instance.parent.GetComp<CompAbilityProvider>();\n        compAbilityProvider?.OnUnequipped(pawn);\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_TingComp_Notify_Unequipped.cs",
    "startLine": 8,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(ThingComp), nameof(ThingComp.Notify_Unequipped))"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.AdapterDef.TryAddComp(Verse.ThingDef,Verse.CompProperties)",
    "name": "TryAddComp",
    "fullName": "CWF.AdapterDef.TryAddComp(Verse.ThingDef, Verse.CompProperties)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static void TryAddComp(ThingDef weaponDef, CompProperties newComp) {\n        if (!weaponDef.comps.Any(comp => comp.compClass == newComp.compClass)) {\n            weaponDef.comps.Add(newComp);\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Defs/AdapterDef.cs",
    "startLine": 83,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.GenCollection.Any``1(System.Predicate{``0})",
      "M:System.Collections.Generic.List`1.Add(`0)"
    ],
    "calledBy": ["M:CWF.AdapterDef.AdaptWeapon(Verse.ThingDef,CWF.AdapterDef)"]
  },
  {
    "id": "M:CWF.AdapterDef.AdaptWeapon(Verse.ThingDef,CWF.AdapterDef)",
    "name": "AdaptWeapon",
    "fullName": "CWF.AdapterDef.AdaptWeapon(Verse.ThingDef, CWF.AdapterDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static void AdaptWeapon(ThingDef weaponDef, AdapterDef adapter) {\n        // === graphicData ===\n        weaponDef.graphicData.texPath = adapter.graphicData?.texPath;\n        weaponDef.graphicData.graphicClass = adapter.graphicData?.graphicClass;\n        weaponDef.graphicData.shaderType = adapter.graphicData?.shaderType;\n\n        // === weaponTags ===\n        if (adapter.weaponTags.Count > 0) {\n            weaponDef.weaponTags ??= [];\n            weaponDef.weaponTags = weaponDef.weaponTags.Union(adapter.weaponTags).ToList();\n        }\n\n        // === comps ===\n        weaponDef.comps ??= [];\n\n        // injector default comps\n        TryAddComp(weaponDef, new CompProperties_Renamable());\n        TryAddComp(weaponDef, new CompProperties_Colorable());\n        TryAddComp(weaponDef, new CompProperties_AbilityProvider());\n\n        // injector adapter inner comps\n        foreach (var compToAdd in adapter.comps) {\n            TryAddComp(weaponDef, compToAdd);\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Defs/AdapterDef.cs",
    "startLine": 57,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.Union``1(System.Collections.Generic.IEnumerable{``0})",
      "M:CWF.AdapterDef.TryAddComp(Verse.ThingDef,Verse.CompProperties)",
      "M:CWF.CompProperties_Renamable.#ctor",
      "M:CWF.CompProperties_Colorable.#ctor",
      "M:CWF.CompProperties_AbilityProvider.#ctor"
    ],
    "calledBy": ["M:CWF.AdapterDef.Inject"]
  },
  {
    "id": "M:CWF.AdapterDef.Inject",
    "name": "Inject",
    "fullName": "CWF.AdapterDef.Inject()",
    "type": "Method",
    "baseType": null,
    "codeBody": "internal static void Inject() {\n        var allAdapters = DefDatabase<AdapterDef>.AllDefs;\n\n        foreach (var adapter in allAdapters) {\n            var weaponDef = DefDatabase<ThingDef>.GetNamed(adapter.defName, false);\n\n            if (weaponDef == null) {\n                Log.Warning($\"[CWF] AdapterDef '{adapter.defName}' could not find a matching ThingDef to adapt.\");\n                continue;\n            }\n\n            AdaptWeapon(weaponDef, adapter);\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Defs/AdapterDef.cs",
    "startLine": 40,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.DefDatabase`1.GetNamed(System.String,System.Boolean)",
      "M:Verse.Log.Warning(System.String)",
      "M:CWF.AdapterDef.AdaptWeapon(Verse.ThingDef,CWF.AdapterDef)"
    ],
    "calledBy": ["M:CWF.CustomizeWeaponFramework.#cctor"]
  },
  {
    "id": "M:CWF.AdapterDef.ConfigErrors",
    "name": "ConfigErrors",
    "fullName": "CWF.AdapterDef.ConfigErrors()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override IEnumerable<string> ConfigErrors() {\n        foreach (var item in base.ConfigErrors()) {\n            yield return item;\n        }\n\n        if (graphicData == null) {\n            yield return \"graphicData is null\";\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Defs/AdapterDef.cs",
    "startLine": 30,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.Def.ConfigErrors"],
    "calledBy": []
  },
  {
    "id": "T:CWF.AdapterDef",
    "name": "AdapterDef",
    "fullName": "CWF.AdapterDef",
    "type": "Class",
    "baseType": "Verse.Def",
    "codeBody": "public class AdapterDef : Def {\n    /// <summary>\n    /// The new base graphic data to apply to the adapted weapon.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly GraphicData? graphicData;\n\n    /// <summary>\n    /// Additional weaponTags to add to the adapted weapon.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly List<string> weaponTags = [];\n\n    /// <summary>\n    /// A list of CompProperties to inject into the adapted weapon, such as `CompProperties_DynamicTraits`.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly List<CompProperties> comps = [];\n\n    public override IEnumerable<string> ConfigErrors() {\n        foreach (var item in base.ConfigErrors()) {\n            yield return item;\n        }\n\n        if (graphicData == null) {\n            yield return \"graphicData is null\";\n        }\n    }\n\n    internal static void Inject() {\n        var allAdapters = DefDatabase<AdapterDef>.AllDefs;\n\n        foreach (var adapter in allAdapters) {\n            var weaponDef = DefDatabase<ThingDef>.GetNamed(adapter.defName, false);\n\n            if (weaponDef == null) {\n                Log.Warning($\"[CWF] AdapterDef '{adapter.defName}' could not find a matching ThingDef to adapt.\");\n                continue;\n            }\n\n            AdaptWeapon(weaponDef, adapter);\n        }\n    }\n\n    #region Helper\n\n    private static void AdaptWeapon(ThingDef weaponDef, AdapterDef adapter) {\n        // === graphicData ===\n        weaponDef.graphicData.texPath = adapter.graphicData?.texPath;\n        weaponDef.graphicData.graphicClass = adapter.graphicData?.graphicClass;\n        weaponDef.graphicData.shaderType = adapter.graphicData?.shaderType;\n\n        // === weaponTags ===\n        if (adapter.weaponTags.Count > 0) {\n            weaponDef.weaponTags ??= [];\n            weaponDef.weaponTags = weaponDef.weaponTags.Union(adapter.weaponTags).ToList();\n        }\n\n        // === comps ===\n        weaponDef.comps ??= [];\n\n        // injector default comps\n        TryAddComp(weaponDef, new CompProperties_Renamable());\n        TryAddComp(weaponDef, new CompProperties_Colorable());\n        TryAddComp(weaponDef, new CompProperties_AbilityProvider());\n\n        // injector adapter inner comps\n        foreach (var compToAdd in adapter.comps) {\n            TryAddComp(weaponDef, compToAdd);\n        }\n    }\n\n    private static void TryAddComp(ThingDef weaponDef, CompProperties newComp) {\n        if (!weaponDef.comps.Any(comp => comp.compClass == newComp.compClass)) {\n            weaponDef.comps.Add(newComp);\n        }\n    }\n\n    #endregion\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Defs/AdapterDef.cs",
    "startLine": 11,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompProperties_DynamicTraits.#ctor",
    "name": ".ctor",
    "fullName": "CWF.CompProperties_DynamicTraits.CompProperties_DynamicTraits()",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public CompProperties_DynamicTraits() => compClass = typeof(CompDynamicTraits);",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_DynamicTraits.cs",
    "startLine": 24,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.CompProperties_DynamicTraits",
    "name": "CompProperties_DynamicTraits",
    "fullName": "CWF.CompProperties_DynamicTraits",
    "type": "Class",
    "baseType": "Verse.CompProperties",
    "codeBody": "[UsedImplicitly]\npublic class CompProperties_DynamicTraits : CompProperties {\n    /// <summary>\n    /// A list of all part slots this weapon can have modules attached to.\n    /// </summary>\n    public readonly List<PartDef> supportParts = [];\n\n    /// <summary>\n    /// A list of traits that are pre-installed on this weapon when it is generated.\n    /// </summary>\n    public readonly List<WeaponTraitDef> defaultWeaponTraitDefs = [];\n\n    public CompProperties_DynamicTraits() => compClass = typeof(CompDynamicTraits);\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_DynamicTraits.cs",
    "startLine": 12,
    "attributes": ["UsedImplicitly"],
    "attributeDetails": ["UsedImplicitly"],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicTraits.ClearAllCaches",
    "name": "ClearAllCaches",
    "fullName": "CWF.CompDynamicTraits.ClearAllCaches()",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void ClearAllCaches() {\n        // === stats ===\n        foreach (var statDef in DefDatabase<StatDef>.AllDefs) {\n            statDef.Worker.ClearCacheForThing(parent);\n        }\n\n        // === verbs ===\n        var verb = parent.TryGetComp<CompEquippable>()?.PrimaryVerb;\n        if (verb == null) return;\n\n        // === cached ===\n        AccessTools.Field(typeof(Verb), \"cachedBurstShotCount\").SetValue(verb, null);\n        AccessTools.Field(typeof(Verb), \"cachedTicksBetweenBurstShots\").SetValue(verb, null);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 402,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:RimWorld.StatWorker.ClearCacheForThing(Verse.Thing)",
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:System.Reflection.FieldInfo.SetValue(System.Object,System.Object)",
      "M:HarmonyLib.AccessTools.Field(System.Type,System.String)"
    ],
    "calledBy": ["M:CWF.CompDynamicTraits.OnTraitsChanged"]
  },
  {
    "id": "M:CWF.CompDynamicTraits.SetupAbility(System.Boolean)",
    "name": "SetupAbility",
    "fullName": "CWF.CompDynamicTraits.SetupAbility(bool)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void SetupAbility(bool isPostLoad) {\n        var abilityProvider = parent.TryGetComp<CompAbilityProvider>();\n        if (abilityProvider == null) return;\n\n        var propsList = Traits\n            .Where(trait => trait.abilityProps != null)\n            .Select(trait => trait.abilityProps)\n            .ToList();\n\n        abilityProvider.SetOrUpdateAbilities(propsList, isPostLoad);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 390,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.Select``2(System.Func{``0,``1})",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:CWF.CompAbilityProvider.SetOrUpdateAbilities(System.Collections.Generic.List{RimWorld.CompProperties_EquippableAbilityReloadable},System.Boolean)"
    ],
    "calledBy": [
      "M:CWF.CompDynamicTraits.OnTraitsChanged",
      "M:CWF.CompDynamicTraits.PostExposeData",
      "M:CWF.CompDynamicTraits.PostPostMake"
    ]
  },
  {
    "id": "M:CWF.CompDynamicTraits.RecalculateAvailableParts",
    "name": "RecalculateAvailableParts",
    "fullName": "CWF.CompDynamicTraits.RecalculateAvailableParts()",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void RecalculateAvailableParts() {\n        _availableParts = new HashSet<PartDef>(Props.supportParts);\n\n        foreach (var traitDef in Traits) {\n            if (!traitDef.TryGetModuleDef(out var moduleDef)) continue;\n\n            var modifiers = moduleDef.GetModExtension<TraitModuleExtension>()?.conditionalPartModifiers;\n            if (modifiers == null) continue;\n\n            foreach (var rule in modifiers) {\n                if (rule.matcher == null || !rule.matcher.IsMatch(parent.def)) continue;\n\n                _availableParts.UnionWith(rule.enablesParts);\n                _availableParts.ExceptWith(rule.disablesParts);\n            }\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 372,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.ModuleDatabase.TryGetModuleDef(Verse.ThingDef@)",
      "M:Verse.Def.GetModExtension``1",
      "M:CWF.WeaponMatcher.IsMatch(Verse.ThingDef)",
      "M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})",
      "M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})",
      "M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})"
    ],
    "calledBy": [
      "M:CWF.CompDynamicTraits.OnTraitsChanged",
      "M:CWF.CompDynamicTraits.PostExposeData",
      "M:CWF.CompDynamicTraits.PostPostMake"
    ]
  },
  {
    "id": "M:CWF.CompDynamicTraits.OnTraitsChanged",
    "name": "OnTraitsChanged",
    "fullName": "CWF.CompDynamicTraits.OnTraitsChanged()",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void OnTraitsChanged() {\n        RecalculateAvailableParts();\n        SetupAbility(false);\n        ClearAllCaches();\n\n        #region Refresh graphic\n\n        if (!parent.TryGetComp<CompDynamicGraphic>(out var compDynamicGraphic)) return;\n\n        compDynamicGraphic.Notify_GraphicDirty();\n\n        if (parent.Map != null) {\n            // ground graphic dirty\n            parent.Map.mapDrawer.MapMeshDirty(parent.Position, MapMeshFlagDefOf.Things);\n        } else if (parent.ParentHolder is Pawn_EquipmentTracker { pawn: not null } equipmentTracker) {\n            // equipment graphic dirty\n            equipmentTracker.pawn.Drawer.renderer.SetAllGraphicsDirty();\n        }\n\n        #endregion\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 350,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.CompDynamicTraits.RecalculateAvailableParts",
      "M:CWF.CompDynamicTraits.SetupAbility(System.Boolean)",
      "M:CWF.CompDynamicTraits.ClearAllCaches",
      "M:Verse.ThingCompUtility.TryGetComp``1(``0@)",
      "M:CWF.CompDynamicGraphic.Notify_GraphicDirty",
      "M:Verse.MapDrawer.MapMeshDirty(Verse.IntVec3,System.UInt64)",
      "M:Verse.PawnRenderer.SetAllGraphicsDirty"
    ],
    "calledBy": [
      "M:CWF.CompDynamicTraits.UninstallTrait(CWF.PartDef)",
      "M:CWF.CompDynamicTraits.InstallTrait(CWF.PartDef,RimWorld.WeaponTraitDef)",
      "P:CWF.CompDynamicTraits.InstalledTraits"
    ]
  },
  {
    "id": "M:CWF.CompDynamicTraits.InitializeTraits",
    "name": "InitializeTraits",
    "fullName": "CWF.CompDynamicTraits.InitializeTraits()",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void InitializeTraits() {\n        var defaultTraitsList = Props.defaultWeaponTraitDefs;\n        if (defaultTraitsList.Empty()) return;\n\n        foreach (var traitDef in defaultTraitsList) {\n            if (traitDef.TryGetPart(out var part)) {\n                // Found the corresponding slot; now check whether the slot is already occupied (conflict check).\n                if (_installedTraits.TryGetValue(part, out var existingTrait)) {\n                    Log.Error($\"[CWF] Initialization Error for {parent.def.defName}: \" +\n                              $\"Both '{traitDef.defName}' and '{existingTrait.defName}' are configured as default traits for the same part slot '{part}'. \" +\n                              $\"Ignoring the latter: '{traitDef.defName}'.\");\n                } else {\n                    // No conflictinstall this default trait into the corresponding slot.\n                    _installedTraits.Add(part, traitDef);\n                }\n            } else {\n                // If no corresponding module definition is found, skip it.\n                Log.Warning($\"[CWF] Initialization Warning for {parent.def.defName}: \" +\n                            $\"Default trait '{traitDef.defName}' has no corresponding TraitModule with a Part defined. It will be ignored.\");\n            }\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 327,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.GenCollection.Empty``1",
      "M:CWF.ModuleDatabase.TryGetPart(CWF.PartDef@)",
      "M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)",
      "M:Verse.Log.Error(System.String)",
      "M:System.Collections.Generic.Dictionary`2.Add(`0,`1)",
      "M:Verse.Log.Warning(System.String)"
    ],
    "calledBy": ["M:CWF.CompDynamicTraits.PostPostMake"]
  },
  {
    "id": "M:CWF.CompDynamicTraits.CompGetEquippedGizmosExtra(Verse.Pawn)",
    "name": "CompGetEquippedGizmosExtra",
    "fullName": "CWF.CompDynamicTraits.CompGetEquippedGizmosExtra(Verse.Pawn)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public IEnumerable<Gizmo> CompGetEquippedGizmosExtra(Pawn owner) {\n        // harmony patched\n        if (owner.Faction == Faction.OfPlayer) {\n            yield return new Command_Action {\n                defaultLabel = \"CWF_UI_WeaponPanel\".Translate(),\n                defaultDesc = \"CWF_UI_WeaponPanelDesc\".Translate(),\n                icon = ContentFinder<Texture2D>.Get(\"CustomizeWeapon/Gizmos/Panel\"),\n                action = () => { Find.WindowStack.Add(new WeaponWindow(parent)); }\n            };\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 311,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Translator.Translate",
      "M:Verse.ContentFinder`1.Get(System.String,System.Boolean)",
      "M:Verse.WindowStack.Add(Verse.Window)",
      "M:Verse.Command_Action.#ctor",
      "M:CWF.WeaponWindow.#ctor(Verse.Thing)"
    ],
    "calledBy": [
      "M:CWF.HarmonyPatches.Postfix_Pawn_EquipmentTracker_GetGizmos.Postfix(System.Collections.Generic.IEnumerable{Verse.Gizmo},Verse.Pawn_EquipmentTracker)"
    ]
  },
  {
    "id": "M:CWF.CompDynamicTraits.CompGetGizmosExtra",
    "name": "CompGetGizmosExtra",
    "fullName": "CWF.CompDynamicTraits.CompGetGizmosExtra()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override IEnumerable<Gizmo> CompGetGizmosExtra() {\n        foreach (var g in base.CompGetGizmosExtra()) {\n            yield return g;\n        }\n\n        if (parent.IsForbidden(Faction.OfPlayer)) yield break;\n\n        yield return new Command_Action {\n            defaultLabel = \"CWF_UI_WeaponPanel\".Translate(),\n            defaultDesc = \"CWF_UI_WeaponPanelDesc\".Translate(),\n            icon = ContentFinder<Texture2D>.Get(\"CustomizeWeapon/Gizmos/Panel\"),\n            action = () => { Find.WindowStack.Add(new WeaponWindow(parent)); }\n        };\n\n        if (!Prefs.DevMode) yield break;\n        var addTraitGizmo = new Command_Action {\n            defaultLabel = \"Dev: + Add Trait\",\n            action = () => {\n                var availableTraits = DefDatabase<WeaponTraitDef>.AllDefs\n                    .Where(traitDef => {\n                        if (!traitDef.TryGetPart(out var part)) return false;\n                        if (_installedTraits.ContainsKey(part)) return false;\n\n                        return traitDef.TryGetModuleDef(out var moduleDef) &&\n                               moduleDef.IsCompatibleWith(parent.def);\n                    })\n                    .ToList();\n\n                if (availableTraits.Empty()) {\n                    Messages.Message(\"Debug: No available traits to install.\", MessageTypeDefOf.NeutralEvent);\n                    return;\n                }\n\n                var options = new List<FloatMenuOption>();\n\n                foreach (var traitDef in availableTraits) {\n                    var localTraitDef = traitDef;\n\n                    var option = new FloatMenuOption(\n                        localTraitDef.LabelCap,\n                        () => {\n                            if (!localTraitDef.TryGetPart(out var part)) return;\n                            InstallTrait(part, localTraitDef);\n                        }\n                    );\n                    options.Add(option);\n                }\n\n                Find.WindowStack.Add(new FloatMenu(options));\n            }\n        };\n        yield return addTraitGizmo;\n\n        var removeTraitGizmo = new Command_Action {\n            defaultLabel = \"Dev: - Remove Trait\",\n            action = () => {\n                var options = new List<FloatMenuOption>();\n\n                var availableTraits = Traits;\n\n                foreach (var traitDef in availableTraits) {\n                    var option = new FloatMenuOption(\n                        traitDef.LabelCap,\n                        () => {\n                            if (!traitDef.TryGetPart(out var part)) return;\n                            UninstallTrait(part);\n                        }\n                    );\n                    options.Add(option);\n                }\n\n                if (options.Empty()) {\n                    options.Add(new FloatMenuOption(\"Nothing to remove\", null));\n                }\n\n                Find.WindowStack.Add(new FloatMenu(options));\n            }\n        };\n        yield return removeTraitGizmo;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 230,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingComp.CompGetGizmosExtra",
      "M:RimWorld.ForbidUtility.IsForbidden(RimWorld.Faction)",
      "M:Verse.Translator.Translate",
      "M:Verse.ContentFinder`1.Get(System.String,System.Boolean)",
      "M:Verse.WindowStack.Add(Verse.Window)",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:CWF.ModuleDatabase.TryGetPart(CWF.PartDef@)",
      "M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)",
      "M:CWF.ModuleDatabase.TryGetModuleDef(Verse.ThingDef@)",
      "M:CWF.ModuleDatabase.IsCompatibleWith(Verse.ThingDef)",
      "M:Verse.GenCollection.Empty``1",
      "M:Verse.Messages.Message(System.String,Verse.MessageTypeDef,System.Boolean)",
      "M:CWF.CompDynamicTraits.InstallTrait(CWF.PartDef,RimWorld.WeaponTraitDef)",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:CWF.CompDynamicTraits.UninstallTrait(CWF.PartDef)",
      "M:Verse.Command_Action.#ctor",
      "M:CWF.WeaponWindow.#ctor(Verse.Thing)",
      "M:System.Collections.Generic.List`1.#ctor",
      "M:Verse.FloatMenuOption.#ctor(System.String,System.Action,Verse.MenuOptionPriority,System.Action{UnityEngine.Rect},Verse.Thing,System.Single,System.Func{UnityEngine.Rect,System.Boolean},RimWorld.Planet.WorldObject,System.Boolean,System.Int32)",
      "M:Verse.FloatMenu.#ctor(System.Collections.Generic.List{Verse.FloatMenuOption})"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicTraits.PostExposeData",
    "name": "PostExposeData",
    "fullName": "CWF.CompDynamicTraits.PostExposeData()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void PostExposeData() {\n        base.PostExposeData();\n\n        if (Scribe.mode is LoadSaveMode.Saving or LoadSaveMode.LoadingVars) {\n            Scribe_Collections.Look(ref _installedTraits, \"installedTraits\", LookMode.Def, LookMode.Def);\n        }\n\n        if (Scribe.mode is not LoadSaveMode.PostLoadInit) return;\n\n        _installedTraits ??= new Dictionary<PartDef, WeaponTraitDef>();\n\n        #region AutoFixMissing\n\n        var partsWithMissingTraits = _installedTraits\n            .Where(pair => pair.Value == null)\n            .Select(pair => pair.Key)\n            .ToArray();\n\n        if (partsWithMissingTraits.Any()) {\n            _installedTraits.RemoveRange(partsWithMissingTraits);\n\n            Log.Warning($\"[CWF] Removed {partsWithMissingTraits.Length} missing traits from '{parent.LabelCap}'. \" +\n                        $\"This is a safe, one-time operation.\");\n        }\n\n        #endregion\n\n        RecalculateAvailableParts();\n        SetupAbility(true);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 195,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingComp.PostExposeData",
      "M:Verse.Scribe_Collections.Look``2(System.Collections.Generic.Dictionary{``0,``1}@,System.String,Verse.LookMode,Verse.LookMode)",
      "M:System.Linq.Enumerable.ToArray``1",
      "M:System.Linq.Enumerable.Select``2(System.Func{``0,``1})",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:System.Linq.Enumerable.Any``1",
      "M:Verse.GenCollection.RemoveRange``2(System.Collections.Generic.ICollection{``0})",
      "M:Verse.Log.Warning(System.String)",
      "M:CWF.CompDynamicTraits.RecalculateAvailableParts",
      "M:CWF.CompDynamicTraits.SetupAbility(System.Boolean)",
      "M:System.Collections.Generic.Dictionary`2.#ctor"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicTraits.PostPostMake",
    "name": "PostPostMake",
    "fullName": "CWF.CompDynamicTraits.PostPostMake()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void PostPostMake() {\n        base.PostPostMake();\n\n        InitializeTraits();\n        RecalculateAvailableParts();\n        SetupAbility(false);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 187,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingComp.PostPostMake",
      "M:CWF.CompDynamicTraits.InitializeTraits",
      "M:CWF.CompDynamicTraits.RecalculateAvailableParts",
      "M:CWF.CompDynamicTraits.SetupAbility(System.Boolean)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicTraits.SpecialDisplayStats",
    "name": "SpecialDisplayStats",
    "fullName": "CWF.CompDynamicTraits.SpecialDisplayStats()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override IEnumerable<StatDrawEntry> SpecialDisplayStats() {\n        if (_installedTraits.IsNullOrEmpty()) yield break;\n\n        var sb = new StringBuilder();\n        sb.AppendLine(\"CWF_UI_WeaponModules_Desc\".Translate());\n        sb.AppendLine();\n\n        var traitDescriptionBlocks = Traits.Select(trait => {\n            var blockBuilder = new StringBuilder();\n            blockBuilder.AppendLine(trait.LabelCap.Colorize(ColorLibrary.Green));\n            blockBuilder.AppendLine(trait.description);\n\n            var effect = trait.GetTraitEffect();\n            if (effect.Any()) {\n                blockBuilder.AppendLine(effect);\n            }\n\n            return blockBuilder.ToString();\n        });\n\n        sb.Append(traitDescriptionBlocks.ToLineList());\n\n        yield return new StatDrawEntry(\n            parent.def.IsMeleeWeapon ? StatCategoryDefOf.Weapon_Melee : StatCategoryDefOf.Weapon_Ranged,\n            \"CWF_UI_WeaponModules\".Translate(),\n            Traits.Select(x => x.label).ToCommaList().CapitalizeFirst(),\n            sb.ToString(),\n            1105\n        );\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 152,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.Extensions.Extensions.IsNullOrEmpty``1",
      "M:System.Text.StringBuilder.AppendLine(System.String)",
      "M:Verse.Translator.Translate",
      "M:System.Text.StringBuilder.AppendLine",
      "M:System.Linq.Enumerable.Select``2(System.Func{``0,``1})",
      "M:Verse.ColoredText.Colorize(UnityEngine.Color)",
      "M:CWF.ModuleDatabase.GetTraitEffect",
      "M:System.Linq.Enumerable.Any``1",
      "M:System.Text.StringBuilder.ToString",
      "M:System.Text.StringBuilder.Append(System.String)",
      "M:Verse.GenText.ToLineList(System.String,System.Boolean)",
      "M:Verse.GenText.CapitalizeFirst",
      "M:Verse.GenText.ToCommaList(System.Boolean,System.Boolean)",
      "M:System.Text.StringBuilder.#ctor",
      "M:RimWorld.StatDrawEntry.#ctor(RimWorld.StatCategoryDef,System.String,System.String,System.String,System.Int32,System.String,System.Collections.Generic.IEnumerable{Verse.Dialog_InfoCard.Hyperlink},System.Boolean,System.Boolean)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicTraits.CompInspectStringExtra",
    "name": "CompInspectStringExtra",
    "fullName": "CWF.CompDynamicTraits.CompInspectStringExtra()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override string? CompInspectStringExtra() {\n        if (_installedTraits.IsNullOrEmpty()) return null;\n\n        return \"CWF_UI_WeaponModules\".Translate() + \": \" + Traits\n            .Select(traitDef => traitDef.label).ToCommaList()\n            .CapitalizeFirst();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 144,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.Extensions.Extensions.IsNullOrEmpty``1",
      "M:Verse.Translator.Translate",
      "M:Verse.GenText.CapitalizeFirst",
      "M:Verse.GenText.ToCommaList(System.Boolean,System.Boolean)",
      "M:System.Linq.Enumerable.Select``2(System.Func{``0,``1})"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicTraits.GetStatsExplanation(RimWorld.StatDef,System.Text.StringBuilder,System.String)",
    "name": "GetStatsExplanation",
    "fullName": "CWF.CompDynamicTraits.GetStatsExplanation(RimWorld.StatDef, System.Text.StringBuilder, string)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void GetStatsExplanation(StatDef stat, StringBuilder sb, string whitespace = \"\") {\n        StringBuilder? stringBuilder = null;\n\n        foreach (var weaponTraitDef in Traits) {\n            // offset\n            var statOffsetFromList = weaponTraitDef.statOffsets.GetStatOffsetFromList(stat);\n            if (!Mathf.Approximately(statOffsetFromList, 0.0f)) {\n                stringBuilder ??= new StringBuilder();\n                stringBuilder.AppendLine(\n                    whitespace + \" - \" +\n                    weaponTraitDef.LabelCap + \": \" +\n                    stat.Worker.ValueToString(statOffsetFromList, false, ToStringNumberSense.Offset));\n            }\n\n            // factor\n            var statFactorFromList = weaponTraitDef.statFactors.GetStatFactorFromList(stat);\n            if (!Mathf.Approximately(statFactorFromList, 1f)) {\n                stringBuilder ??= new StringBuilder();\n                stringBuilder.AppendLine(\n                    whitespace + \" - \" +\n                    weaponTraitDef.LabelCap + \": \" +\n                    stat.Worker.ValueToString(statFactorFromList, false, ToStringNumberSense.Factor));\n            }\n        }\n\n        if (stringBuilder == null) return;\n\n        sb.AppendLine();\n        sb.AppendLine(whitespace + \"CWF_UI_WeaponModules\".Translate() + \":\");\n        sb.Append(stringBuilder);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 112,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:RimWorld.StatUtility.GetStatOffsetFromList(RimWorld.StatDef)",
      "M:UnityEngine.Mathf.Approximately(System.Single,System.Single)",
      "M:System.Text.StringBuilder.AppendLine(System.String)",
      "M:RimWorld.StatWorker.ValueToString(System.Single,System.Boolean,Verse.ToStringNumberSense)",
      "M:RimWorld.StatUtility.GetStatFactorFromList(RimWorld.StatDef)",
      "M:System.Text.StringBuilder.AppendLine",
      "M:Verse.Translator.Translate",
      "M:System.Text.StringBuilder.Append(System.Text.StringBuilder)",
      "M:System.Text.StringBuilder.#ctor"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicTraits.GetStatFactor(RimWorld.StatDef)",
    "name": "GetStatFactor",
    "fullName": "CWF.CompDynamicTraits.GetStatFactor(RimWorld.StatDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override float GetStatFactor(StatDef stat) {\n        return Traits\n            .Aggregate(1f, (current, traitDef)\n                => current * traitDef.statFactors.GetStatFactorFromList(stat));\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 102,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.Aggregate``2(``1,System.Func{``1,``0,``1})",
      "M:RimWorld.StatUtility.GetStatFactorFromList(RimWorld.StatDef)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicTraits.GetStatOffset(RimWorld.StatDef)",
    "name": "GetStatOffset",
    "fullName": "CWF.CompDynamicTraits.GetStatOffset(RimWorld.StatDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override float GetStatOffset(StatDef stat) {\n        return Traits\n            .Sum(traitDef => traitDef.statOffsets.GetStatOffsetFromList(stat));\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 97,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.Sum``1(System.Func{``0,System.Single})",
      "M:RimWorld.StatUtility.GetStatOffsetFromList(RimWorld.StatDef)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompDynamicTraits.RandomizeTraits",
    "name": "RandomizeTraits",
    "fullName": "CWF.CompDynamicTraits.RandomizeTraits()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void RandomizeTraits() {\n        var settings = LoadedModManager.GetMod<ConfigWindow>().GetSettings<Settings>();\n        if (!settings.RandomModulesEnabled) return;\n\n        var allSupportedParts = Props.supportParts;\n        if (allSupportedParts.Empty()) return;\n\n        var occupiedParts = _installedTraits.Keys;\n        var availableEmptyParts = allSupportedParts.Except(occupiedParts).ToList();\n        if (availableEmptyParts.NullOrEmpty()) return;\n\n        var modulesToInstallCount = Rand.RangeInclusive(settings.MinRandomModules, settings.MaxRandomModules);\n        modulesToInstallCount = Mathf.Min(modulesToInstallCount, availableEmptyParts.Count);\n\n        for (var i = 0; i < modulesToInstallCount; i++) {\n            if (!availableEmptyParts.Any()) break;\n\n            var randomPart = availableEmptyParts.RandomElement();\n            availableEmptyParts.Remove(randomPart);\n\n            var compatibleTraits = DefDatabase<WeaponTraitDef>.AllDefs\n                .Where(traitDef => {\n                    if (!traitDef.TryGetPart(out var part) || part != randomPart) return false;\n\n                    return traitDef.TryGetModuleDef(out var moduleDef) &&\n                           moduleDef.IsCompatibleWith(parent.def);\n                })\n                .ToList();\n\n            if (!compatibleTraits.Any()) continue;\n\n            var traitToInstall = compatibleTraits.RandomElement();\n            InstallTrait(randomPart, traitToInstall);\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 59,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Mod.GetSettings``1",
      "M:Verse.LoadedModManager.GetMod``1",
      "M:Verse.GenCollection.Empty``1",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.Except``1(System.Collections.Generic.IEnumerable{``0})",
      "M:Verse.GenList.NullOrEmpty``1",
      "M:Verse.Rand.RangeInclusive(System.Int32,System.Int32)",
      "M:UnityEngine.Mathf.Min(System.Int32,System.Int32)",
      "M:Verse.GenCollection.Any``1",
      "M:Verse.GenCollection.RandomElement``1",
      "M:System.Collections.Generic.List`1.Remove(`0)",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:CWF.ModuleDatabase.TryGetPart(CWF.PartDef@)",
      "M:CWF.ModuleDatabase.TryGetModuleDef(Verse.ThingDef@)",
      "M:CWF.ModuleDatabase.IsCompatibleWith(Verse.ThingDef)",
      "M:CWF.CompDynamicTraits.InstallTrait(CWF.PartDef,RimWorld.WeaponTraitDef)"
    ],
    "calledBy": [
      "M:CWF.HarmonyPatches.Postfix_PawnWeaponGenerator_TryGenerateWeaponFor.Postfix(Verse.Pawn,Verse.PawnGenerationRequest)"
    ]
  },
  {
    "id": "M:CWF.CompDynamicTraits.GetInstalledTraitFor(CWF.PartDef)",
    "name": "GetInstalledTraitFor",
    "fullName": "CWF.CompDynamicTraits.GetInstalledTraitFor(CWF.PartDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public WeaponTraitDef? GetInstalledTraitFor(PartDef part) {\n        _installedTraits.TryGetValue(part, out var traitDef);\n        return traitDef;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 54,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:System.Collections.Generic.Dictionary`2.TryGetValue(`0,`1@)"],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.AnalyzeInstallConflict(Verse.ThingDef)",
      "M:CWF.Controllers.InteractionController.DoUninstall(CWF.PartDef)",
      "M:CWF.ViewDrawers.MainDrawer.TryDrawSlot(CWF.PartDef,UnityEngine.Rect@)",
      "M:CWF.CompDynamicGraphic.GenerateGraphic"
    ]
  },
  {
    "id": "M:CWF.CompDynamicTraits.UninstallTrait(CWF.PartDef)",
    "name": "UninstallTrait",
    "fullName": "CWF.CompDynamicTraits.UninstallTrait(CWF.PartDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void UninstallTrait(PartDef part) {\n        if (!_installedTraits.Remove(part)) return;\n\n        OnTraitsChanged();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 42,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Collections.Generic.Dictionary`2.Remove(`0)",
      "M:CWF.CompDynamicTraits.OnTraitsChanged"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.DoUninstall(CWF.PartDef)",
      "M:CWF.CompDynamicTraits.CompGetGizmosExtra",
      "M:CWF.JobDriver_ModifyWeaponSelf.DoUninstall(CWF.CompDynamicTraits,CWF.ModificationData)",
      "M:CWF.JobDriver_ModifyWeaponHaul.PerformModifications(CWF.CompDynamicTraits,System.Collections.Generic.List{CWF.ModificationData})"
    ]
  },
  {
    "id": "M:CWF.CompDynamicTraits.InstallTrait(CWF.PartDef,RimWorld.WeaponTraitDef)",
    "name": "InstallTrait",
    "fullName": "CWF.CompDynamicTraits.InstallTrait(CWF.PartDef, RimWorld.WeaponTraitDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void InstallTrait(PartDef part, WeaponTraitDef traitDef) {\n        if (!_installedTraits.TryAdd(part, traitDef)) {\n            Log.Warning($\"[CWF] {traitDef.defName}'s slot {part} on {parent.LabelCap} already occupied.\");\n            return;\n        }\n\n        OnTraitsChanged();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 33,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Collections.Generic.Dictionary`2.TryAdd(`0,`1)",
      "M:Verse.Log.Warning(System.String)",
      "M:CWF.CompDynamicTraits.OnTraitsChanged"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.DoInstall(CWF.PartDef,RimWorld.WeaponTraitDef)",
      "M:CWF.CompDynamicTraits.CompGetGizmosExtra",
      "M:CWF.CompDynamicTraits.RandomizeTraits",
      "M:CWF.JobDriver_ModifyWeaponSelf.DoInstall(CWF.CompDynamicTraits,CWF.ModificationData)",
      "M:CWF.JobDriver_ModifyWeaponHaul.PerformModifications(CWF.CompDynamicTraits,System.Collections.Generic.List{CWF.ModificationData})"
    ]
  },
  {
    "id": "P:CWF.CompDynamicTraits.AvailableParts",
    "name": "AvailableParts",
    "fullName": "CWF.CompDynamicTraits.AvailableParts",
    "type": "Property",
    "baseType": null,
    "codeBody": "public IReadOnlyCollection<PartDef> AvailableParts => _availableParts;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 31,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompDynamicTraits.Traits",
    "name": "Traits",
    "fullName": "CWF.CompDynamicTraits.Traits",
    "type": "Property",
    "baseType": null,
    "codeBody": "public IReadOnlyCollection<WeaponTraitDef> Traits => _installedTraits.Values;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 29,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompDynamicTraits.InstalledTraits",
    "name": "InstalledTraits",
    "fullName": "CWF.CompDynamicTraits.InstalledTraits",
    "type": "Property",
    "baseType": null,
    "codeBody": "public Dictionary<PartDef, WeaponTraitDef> InstalledTraits {\n        get => new(_installedTraits);\n        set {\n            _installedTraits = new Dictionary<PartDef, WeaponTraitDef>(value);\n            OnTraitsChanged();\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 21,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.CompDynamicTraits.OnTraitsChanged",
      "M:System.Collections.Generic.Dictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})"
    ],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompDynamicTraits.Props",
    "name": "Props",
    "fullName": "CWF.CompDynamicTraits.Props",
    "type": "Property",
    "baseType": null,
    "codeBody": "private CompProperties_DynamicTraits Props => (CompProperties_DynamicTraits)props;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 11,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.CompDynamicTraits",
    "name": "CompDynamicTraits",
    "fullName": "CWF.CompDynamicTraits",
    "type": "Class",
    "baseType": "Verse.ThingComp",
    "codeBody": "public class CompDynamicTraits : ThingComp {\n    private CompProperties_DynamicTraits Props => (CompProperties_DynamicTraits)props;\n\n    private Dictionary<PartDef, WeaponTraitDef> _installedTraits = new();\n\n    private HashSet<PartDef> _availableParts = [];\n\n    /// <summary>\n    /// Gets a copy of the dictionary containing all currently installed Traits,\n    /// or sets a new dictionary of Traits, completely overwriting the old one.\n    /// </summary>\n    public Dictionary<PartDef, WeaponTraitDef> InstalledTraits {\n        get => new(_installedTraits);\n        set {\n            _installedTraits = new Dictionary<PartDef, WeaponTraitDef>(value);\n            OnTraitsChanged();\n        }\n    }\n\n    public IReadOnlyCollection<WeaponTraitDef> Traits => _installedTraits.Values;\n\n    public IReadOnlyCollection<PartDef> AvailableParts => _availableParts;\n\n    public void InstallTrait(PartDef part, WeaponTraitDef traitDef) {\n        if (!_installedTraits.TryAdd(part, traitDef)) {\n            Log.Warning($\"[CWF] {traitDef.defName}'s slot {part} on {parent.LabelCap} already occupied.\");\n            return;\n        }\n\n        OnTraitsChanged();\n    }\n\n    public void UninstallTrait(PartDef part) {\n        if (!_installedTraits.Remove(part)) return;\n\n        OnTraitsChanged();\n    }\n\n    // public void ClearTraits() {\n    //     _installedTraits.Clear();\n    //\n    //     OnTraitsChanged();\n    // }\n\n    public WeaponTraitDef? GetInstalledTraitFor(PartDef part) {\n        _installedTraits.TryGetValue(part, out var traitDef);\n        return traitDef;\n    }\n\n    public void RandomizeTraits() {\n        var settings = LoadedModManager.GetMod<ConfigWindow>().GetSettings<Settings>();\n        if (!settings.RandomModulesEnabled) return;\n\n        var allSupportedParts = Props.supportParts;\n        if (allSupportedParts.Empty()) return;\n\n        var occupiedParts = _installedTraits.Keys;\n        var availableEmptyParts = allSupportedParts.Except(occupiedParts).ToList();\n        if (availableEmptyParts.NullOrEmpty()) return;\n\n        var modulesToInstallCount = Rand.RangeInclusive(settings.MinRandomModules, settings.MaxRandomModules);\n        modulesToInstallCount = Mathf.Min(modulesToInstallCount, availableEmptyParts.Count);\n\n        for (var i = 0; i < modulesToInstallCount; i++) {\n            if (!availableEmptyParts.Any()) break;\n\n            var randomPart = availableEmptyParts.RandomElement();\n            availableEmptyParts.Remove(randomPart);\n\n            var compatibleTraits = DefDatabase<WeaponTraitDef>.AllDefs\n                .Where(traitDef => {\n                    if (!traitDef.TryGetPart(out var part) || part != randomPart) return false;\n\n                    return traitDef.TryGetModuleDef(out var moduleDef) &&\n                           moduleDef.IsCompatibleWith(parent.def);\n                })\n                .ToList();\n\n            if (!compatibleTraits.Any()) continue;\n\n            var traitToInstall = compatibleTraits.RandomElement();\n            InstallTrait(randomPart, traitToInstall);\n        }\n    }\n\n    #region Stat\n\n    public override float GetStatOffset(StatDef stat) {\n        return Traits\n            .Sum(traitDef => traitDef.statOffsets.GetStatOffsetFromList(stat));\n    }\n\n    public override float GetStatFactor(StatDef stat) {\n        return Traits\n            .Aggregate(1f, (current, traitDef)\n                => current * traitDef.statFactors.GetStatFactorFromList(stat));\n    }\n\n    #endregion\n\n    #region Display\n\n    public override void GetStatsExplanation(StatDef stat, StringBuilder sb, string whitespace = \"\") {\n        StringBuilder? stringBuilder = null;\n\n        foreach (var weaponTraitDef in Traits) {\n            // offset\n            var statOffsetFromList = weaponTraitDef.statOffsets.GetStatOffsetFromList(stat);\n            if (!Mathf.Approximately(statOffsetFromList, 0.0f)) {\n                stringBuilder ??= new StringBuilder();\n                stringBuilder.AppendLine(\n                    whitespace + \" - \" +\n                    weaponTraitDef.LabelCap + \": \" +\n                    stat.Worker.ValueToString(statOffsetFromList, false, ToStringNumberSense.Offset));\n            }\n\n            // factor\n            var statFactorFromList = weaponTraitDef.statFactors.GetStatFactorFromList(stat);\n            if (!Mathf.Approximately(statFactorFromList, 1f)) {\n                stringBuilder ??= new StringBuilder();\n                stringBuilder.AppendLine(\n                    whitespace + \" - \" +\n                    weaponTraitDef.LabelCap + \": \" +\n                    stat.Worker.ValueToString(statFactorFromList, false, ToStringNumberSense.Factor));\n            }\n        }\n\n        if (stringBuilder == null) return;\n\n        sb.AppendLine();\n        sb.AppendLine(whitespace + \"CWF_UI_WeaponModules\".Translate() + \":\");\n        sb.Append(stringBuilder);\n    }\n\n    public override string? CompInspectStringExtra() {\n        if (_installedTraits.IsNullOrEmpty()) return null;\n\n        return \"CWF_UI_WeaponModules\".Translate() + \": \" + Traits\n            .Select(traitDef => traitDef.label).ToCommaList()\n            .CapitalizeFirst();\n    }\n\n    public override IEnumerable<StatDrawEntry> SpecialDisplayStats() {\n        if (_installedTraits.IsNullOrEmpty()) yield break;\n\n        var sb = new StringBuilder();\n        sb.AppendLine(\"CWF_UI_WeaponModules_Desc\".Translate());\n        sb.AppendLine();\n\n        var traitDescriptionBlocks = Traits.Select(trait => {\n            var blockBuilder = new StringBuilder();\n            blockBuilder.AppendLine(trait.LabelCap.Colorize(ColorLibrary.Green));\n            blockBuilder.AppendLine(trait.description);\n\n            var effect = trait.GetTraitEffect();\n            if (effect.Any()) {\n                blockBuilder.AppendLine(effect);\n            }\n\n            return blockBuilder.ToString();\n        });\n\n        sb.Append(traitDescriptionBlocks.ToLineList());\n\n        yield return new StatDrawEntry(\n            parent.def.IsMeleeWeapon ? StatCategoryDefOf.Weapon_Melee : StatCategoryDefOf.Weapon_Ranged,\n            \"CWF_UI_WeaponModules\".Translate(),\n            Traits.Select(x => x.label).ToCommaList().CapitalizeFirst(),\n            sb.ToString(),\n            1105\n        );\n    }\n\n    #endregion\n\n    #region Callback\n\n    public override void PostPostMake() {\n        base.PostPostMake();\n\n        InitializeTraits();\n        RecalculateAvailableParts();\n        SetupAbility(false);\n    }\n\n    public override void PostExposeData() {\n        base.PostExposeData();\n\n        if (Scribe.mode is LoadSaveMode.Saving or LoadSaveMode.LoadingVars) {\n            Scribe_Collections.Look(ref _installedTraits, \"installedTraits\", LookMode.Def, LookMode.Def);\n        }\n\n        if (Scribe.mode is not LoadSaveMode.PostLoadInit) return;\n\n        _installedTraits ??= new Dictionary<PartDef, WeaponTraitDef>();\n\n        #region AutoFixMissing\n\n        var partsWithMissingTraits = _installedTraits\n            .Where(pair => pair.Value == null)\n            .Select(pair => pair.Key)\n            .ToArray();\n\n        if (partsWithMissingTraits.Any()) {\n            _installedTraits.RemoveRange(partsWithMissingTraits);\n\n            Log.Warning($\"[CWF] Removed {partsWithMissingTraits.Length} missing traits from '{parent.LabelCap}'. \" +\n                        $\"This is a safe, one-time operation.\");\n        }\n\n        #endregion\n\n        RecalculateAvailableParts();\n        SetupAbility(true);\n    }\n\n    #endregion\n\n    #region Gizmos\n\n    public override IEnumerable<Gizmo> CompGetGizmosExtra() {\n        foreach (var g in base.CompGetGizmosExtra()) {\n            yield return g;\n        }\n\n        if (parent.IsForbidden(Faction.OfPlayer)) yield break;\n\n        yield return new Command_Action {\n            defaultLabel = \"CWF_UI_WeaponPanel\".Translate(),\n            defaultDesc = \"CWF_UI_WeaponPanelDesc\".Translate(),\n            icon = ContentFinder<Texture2D>.Get(\"CustomizeWeapon/Gizmos/Panel\"),\n            action = () => { Find.WindowStack.Add(new WeaponWindow(parent)); }\n        };\n\n        if (!Prefs.DevMode) yield break;\n        var addTraitGizmo = new Command_Action {\n            defaultLabel = \"Dev: + Add Trait\",\n            action = () => {\n                var availableTraits = DefDatabase<WeaponTraitDef>.AllDefs\n                    .Where(traitDef => {\n                        if (!traitDef.TryGetPart(out var part)) return false;\n                        if (_installedTraits.ContainsKey(part)) return false;\n\n                        return traitDef.TryGetModuleDef(out var moduleDef) &&\n                               moduleDef.IsCompatibleWith(parent.def);\n                    })\n                    .ToList();\n\n                if (availableTraits.Empty()) {\n                    Messages.Message(\"Debug: No available traits to install.\", MessageTypeDefOf.NeutralEvent);\n                    return;\n                }\n\n                var options = new List<FloatMenuOption>();\n\n                foreach (var traitDef in availableTraits) {\n                    var localTraitDef = traitDef;\n\n                    var option = new FloatMenuOption(\n                        localTraitDef.LabelCap,\n                        () => {\n                            if (!localTraitDef.TryGetPart(out var part)) return;\n                            InstallTrait(part, localTraitDef);\n                        }\n                    );\n                    options.Add(option);\n                }\n\n                Find.WindowStack.Add(new FloatMenu(options));\n            }\n        };\n        yield return addTraitGizmo;\n\n        var removeTraitGizmo = new Command_Action {\n            defaultLabel = \"Dev: - Remove Trait\",\n            action = () => {\n                var options = new List<FloatMenuOption>();\n\n                var availableTraits = Traits;\n\n                foreach (var traitDef in availableTraits) {\n                    var option = new FloatMenuOption(\n                        traitDef.LabelCap,\n                        () => {\n                            if (!traitDef.TryGetPart(out var part)) return;\n                            UninstallTrait(part);\n                        }\n                    );\n                    options.Add(option);\n                }\n\n                if (options.Empty()) {\n                    options.Add(new FloatMenuOption(\"Nothing to remove\", null));\n                }\n\n                Find.WindowStack.Add(new FloatMenu(options));\n            }\n        };\n        yield return removeTraitGizmo;\n    }\n\n    public IEnumerable<Gizmo> CompGetEquippedGizmosExtra(Pawn owner) {\n        // harmony patched\n        if (owner.Faction == Faction.OfPlayer) {\n            yield return new Command_Action {\n                defaultLabel = \"CWF_UI_WeaponPanel\".Translate(),\n                defaultDesc = \"CWF_UI_WeaponPanelDesc\".Translate(),\n                icon = ContentFinder<Texture2D>.Get(\"CustomizeWeapon/Gizmos/Panel\"),\n                action = () => { Find.WindowStack.Add(new WeaponWindow(parent)); }\n            };\n        }\n    }\n\n    #endregion\n\n    #region Private Helper\n\n    private void InitializeTraits() {\n        var defaultTraitsList = Props.defaultWeaponTraitDefs;\n        if (defaultTraitsList.Empty()) return;\n\n        foreach (var traitDef in defaultTraitsList) {\n            if (traitDef.TryGetPart(out var part)) {\n                // Found the corresponding slot; now check whether the slot is already occupied (conflict check).\n                if (_installedTraits.TryGetValue(part, out var existingTrait)) {\n                    Log.Error($\"[CWF] Initialization Error for {parent.def.defName}: \" +\n                              $\"Both '{traitDef.defName}' and '{existingTrait.defName}' are configured as default traits for the same part slot '{part}'. \" +\n                              $\"Ignoring the latter: '{traitDef.defName}'.\");\n                } else {\n                    // No conflictinstall this default trait into the corresponding slot.\n                    _installedTraits.Add(part, traitDef);\n                }\n            } else {\n                // If no corresponding module definition is found, skip it.\n                Log.Warning($\"[CWF] Initialization Warning for {parent.def.defName}: \" +\n                            $\"Default trait '{traitDef.defName}' has no corresponding TraitModule with a Part defined. It will be ignored.\");\n            }\n        }\n    }\n\n    private void OnTraitsChanged() {\n        RecalculateAvailableParts();\n        SetupAbility(false);\n        ClearAllCaches();\n\n        #region Refresh graphic\n\n        if (!parent.TryGetComp<CompDynamicGraphic>(out var compDynamicGraphic)) return;\n\n        compDynamicGraphic.Notify_GraphicDirty();\n\n        if (parent.Map != null) {\n            // ground graphic dirty\n            parent.Map.mapDrawer.MapMeshDirty(parent.Position, MapMeshFlagDefOf.Things);\n        } else if (parent.ParentHolder is Pawn_EquipmentTracker { pawn: not null } equipmentTracker) {\n            // equipment graphic dirty\n            equipmentTracker.pawn.Drawer.renderer.SetAllGraphicsDirty();\n        }\n\n        #endregion\n    }\n\n    private void RecalculateAvailableParts() {\n        _availableParts = new HashSet<PartDef>(Props.supportParts);\n\n        foreach (var traitDef in Traits) {\n            if (!traitDef.TryGetModuleDef(out var moduleDef)) continue;\n\n            var modifiers = moduleDef.GetModExtension<TraitModuleExtension>()?.conditionalPartModifiers;\n            if (modifiers == null) continue;\n\n            foreach (var rule in modifiers) {\n                if (rule.matcher == null || !rule.matcher.IsMatch(parent.def)) continue;\n\n                _availableParts.UnionWith(rule.enablesParts);\n                _availableParts.ExceptWith(rule.disablesParts);\n            }\n        }\n    }\n\n    private void SetupAbility(bool isPostLoad) {\n        var abilityProvider = parent.TryGetComp<CompAbilityProvider>();\n        if (abilityProvider == null) return;\n\n        var propsList = Traits\n            .Where(trait => trait.abilityProps != null)\n            .Select(trait => trait.abilityProps)\n            .ToList();\n\n        abilityProvider.SetOrUpdateAbilities(propsList, isPostLoad);\n    }\n\n    private void ClearAllCaches() {\n        // === stats ===\n        foreach (var statDef in DefDatabase<StatDef>.AllDefs) {\n            statDef.Worker.ClearCacheForThing(parent);\n        }\n\n        // === verbs ===\n        var verb = parent.TryGetComp<CompEquippable>()?.PrimaryVerb;\n        if (verb == null) return;\n\n        // === cached ===\n        AccessTools.Field(typeof(Verb), \"cachedBurstShotCount\").SetValue(verb, null);\n        AccessTools.Field(typeof(Verb), \"cachedTicksBetweenBurstShots\").SetValue(verb, null);\n    }\n\n    #endregion\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompDynamicTraits.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.JobDriver_ModifyWeaponSelf.DoUninstall(CWF.CompDynamicTraits,CWF.ModificationData)",
    "name": "DoUninstall",
    "fullName": "CWF.JobDriver_ModifyWeaponSelf.DoUninstall(CWF.CompDynamicTraits, CWF.ModificationData)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void DoUninstall(CompDynamicTraits comp, ModificationData modData) {\n        comp.UninstallTrait(modData.Part);\n        var moduleThing = ThingMaker.MakeThing(modData.ModuleDef);\n        if (!pawn.inventory.innerContainer.TryAdd(moduleThing)) {\n            GenPlace.TryPlaceThing(moduleThing, pawn.Position, pawn.Map, ThingPlaceMode.Near);\n        }\n\n        SoundDefOf.Replant_Complete.PlayOneShot(new TargetInfo(pawn.Position, pawn.Map));\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponSelf.cs",
    "startLine": 69,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.CompDynamicTraits.UninstallTrait(CWF.PartDef)",
      "M:Verse.ThingMaker.MakeThing(Verse.ThingDef,Verse.ThingDef)",
      "M:Verse.ThingOwner`1.TryAdd(Verse.Thing,System.Boolean)",
      "M:Verse.GenPlace.TryPlaceThing(Verse.Thing,Verse.IntVec3,Verse.Map,Verse.ThingPlaceMode,System.Action{Verse.Thing,System.Int32},System.Predicate{Verse.IntVec3},System.Nullable{Verse.Rot4},System.Int32)",
      "M:Verse.Sound.SoundStarter.PlayOneShot(Verse.Sound.SoundInfo)",
      "M:Verse.TargetInfo.#ctor(Verse.IntVec3,Verse.Map,System.Boolean)"
    ],
    "calledBy": ["M:CWF.JobDriver_ModifyWeaponSelf.MakeNewToils"]
  },
  {
    "id": "M:CWF.JobDriver_ModifyWeaponSelf.DoInstall(CWF.CompDynamicTraits,CWF.ModificationData)",
    "name": "DoInstall",
    "fullName": "CWF.JobDriver_ModifyWeaponSelf.DoInstall(CWF.CompDynamicTraits, CWF.ModificationData)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void DoInstall(CompDynamicTraits comp, ModificationData modData) {\n        var moduleToUse = pawn.inventory.innerContainer.FirstOrDefault(t => t.def == modData.ModuleDef);\n        if (moduleToUse != null) {\n            comp.InstallTrait(modData.Part, modData.Trait);\n            moduleToUse.SplitOff(1).Destroy();\n            SoundDefOf.Replant_Complete.PlayOneShot(new TargetInfo(pawn.Position, pawn.Map));\n        } else {\n            Log.Error($\"[CWF] '{modData.ModuleDef.defName}' missing in FinishAction despite passing EndCondition.\");\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponSelf.cs",
    "startLine": 58,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.FirstOrDefault``1(System.Func{``0,System.Boolean})",
      "M:CWF.CompDynamicTraits.InstallTrait(CWF.PartDef,RimWorld.WeaponTraitDef)",
      "M:Verse.Thing.Destroy(Verse.DestroyMode)",
      "M:Verse.Thing.SplitOff(System.Int32)",
      "M:Verse.Sound.SoundStarter.PlayOneShot(Verse.Sound.SoundInfo)",
      "M:Verse.Log.Error(System.String)",
      "M:Verse.TargetInfo.#ctor(Verse.IntVec3,Verse.Map,System.Boolean)"
    ],
    "calledBy": ["M:CWF.JobDriver_ModifyWeaponSelf.MakeNewToils"]
  },
  {
    "id": "M:CWF.JobDriver_ModifyWeaponSelf.MakeNewToils",
    "name": "MakeNewToils",
    "fullName": "CWF.JobDriver_ModifyWeaponSelf.MakeNewToils()",
    "type": "Method",
    "baseType": null,
    "codeBody": "protected override IEnumerable<Toil> MakeNewToils() {\n        // safe check\n        if (ModData == null) {\n            Log.Error(\"[CWF] JobDriver_ModifyWeaponSelf started with null ModData. Aborting.\");\n            yield break; // end job\n        }\n\n        // wait and show progress\n        var modifyToil = Toils_General.Wait(60);\n        modifyToil.WithProgressBarToilDelay(TargetIndex.A);\n\n        modifyToil.AddEndCondition(() => {\n            if (ModData.Type != ModificationType.Install) return JobCondition.Ongoing;\n\n            var moduleToUse = pawn.inventory.innerContainer.FirstOrDefault(t => t.def == ModData.ModuleDef);\n\n            return moduleToUse != null ? JobCondition.Ongoing : JobCondition.Incompletable;\n        });\n\n        // modifyToil.initAction = () => {\n        //     // callback: do something at init\n        // };\n        // modifyToil.tickAction = () => {\n        //     // callback: do something in the process\n        // };\n\n        // finished progress\n        modifyToil.AddFinishAction(() => {\n            if (ended) return;\n\n            if (!Weapon.TryGetComp<CompDynamicTraits>(out var compDynamicTraits)) return;\n\n            if (ModData.Type == ModificationType.Install) {\n                DoInstall(compDynamicTraits, ModData);\n            } else {\n                DoUninstall(compDynamicTraits, ModData);\n            }\n        });\n\n        yield return modifyToil;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponSelf.cs",
    "startLine": 15,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Log.Error(System.String)",
      "M:Verse.AI.Toils_General.Wait(System.Int32,Verse.AI.TargetIndex)",
      "M:Verse.AI.ToilEffects.WithProgressBarToilDelay(Verse.AI.TargetIndex,System.Boolean,System.Single)",
      "M:Verse.AI.Toil.AddEndCondition(System.Func{Verse.AI.JobCondition})",
      "M:System.Linq.Enumerable.FirstOrDefault``1(System.Func{``0,System.Boolean})",
      "M:Verse.AI.Toil.AddFinishAction(System.Action)",
      "M:Verse.ThingCompUtility.TryGetComp``1(``0@)",
      "M:CWF.JobDriver_ModifyWeaponSelf.DoInstall(CWF.CompDynamicTraits,CWF.ModificationData)",
      "M:CWF.JobDriver_ModifyWeaponSelf.DoUninstall(CWF.CompDynamicTraits,CWF.ModificationData)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.JobDriver_ModifyWeaponSelf.TryMakePreToilReservations(System.Boolean)",
    "name": "TryMakePreToilReservations",
    "fullName": "CWF.JobDriver_ModifyWeaponSelf.TryMakePreToilReservations(bool)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override bool TryMakePreToilReservations(bool errorOnFailed) => true;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponSelf.cs",
    "startLine": 13,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "P:CWF.JobDriver_ModifyWeaponSelf.ModData",
    "name": "ModData",
    "fullName": "CWF.JobDriver_ModifyWeaponSelf.ModData",
    "type": "Property",
    "baseType": null,
    "codeBody": "private ModificationData? ModData => (job.source as JobGiver_ModifyWeapon)?.ModDataList.FirstOrFallback();",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponSelf.cs",
    "startLine": 11,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.GenCollection.FirstOrFallback``1(``0)"],
    "calledBy": []
  },
  {
    "id": "P:CWF.JobDriver_ModifyWeaponSelf.Weapon",
    "name": "Weapon",
    "fullName": "CWF.JobDriver_ModifyWeaponSelf.Weapon",
    "type": "Property",
    "baseType": null,
    "codeBody": "private Thing Weapon => TargetA.Thing;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponSelf.cs",
    "startLine": 9,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.JobDriver_ModifyWeaponSelf",
    "name": "JobDriver_ModifyWeaponSelf",
    "fullName": "CWF.JobDriver_ModifyWeaponSelf",
    "type": "Class",
    "baseType": "Verse.AI.JobDriver",
    "codeBody": "public class JobDriver_ModifyWeaponSelf : JobDriver {\n    private Thing Weapon => TargetA.Thing;\n\n    private ModificationData? ModData => (job.source as JobGiver_ModifyWeapon)?.ModDataList.FirstOrFallback();\n\n    public override bool TryMakePreToilReservations(bool errorOnFailed) => true;\n\n    protected override IEnumerable<Toil> MakeNewToils() {\n        // safe check\n        if (ModData == null) {\n            Log.Error(\"[CWF] JobDriver_ModifyWeaponSelf started with null ModData. Aborting.\");\n            yield break; // end job\n        }\n\n        // wait and show progress\n        var modifyToil = Toils_General.Wait(60);\n        modifyToil.WithProgressBarToilDelay(TargetIndex.A);\n\n        modifyToil.AddEndCondition(() => {\n            if (ModData.Type != ModificationType.Install) return JobCondition.Ongoing;\n\n            var moduleToUse = pawn.inventory.innerContainer.FirstOrDefault(t => t.def == ModData.ModuleDef);\n\n            return moduleToUse != null ? JobCondition.Ongoing : JobCondition.Incompletable;\n        });\n\n        // modifyToil.initAction = () => {\n        //     // callback: do something at init\n        // };\n        // modifyToil.tickAction = () => {\n        //     // callback: do something in the process\n        // };\n\n        // finished progress\n        modifyToil.AddFinishAction(() => {\n            if (ended) return;\n\n            if (!Weapon.TryGetComp<CompDynamicTraits>(out var compDynamicTraits)) return;\n\n            if (ModData.Type == ModificationType.Install) {\n                DoInstall(compDynamicTraits, ModData);\n            } else {\n                DoUninstall(compDynamicTraits, ModData);\n            }\n        });\n\n        yield return modifyToil;\n    }\n\n    // === Helper ===\n    private void DoInstall(CompDynamicTraits comp, ModificationData modData) {\n        var moduleToUse = pawn.inventory.innerContainer.FirstOrDefault(t => t.def == modData.ModuleDef);\n        if (moduleToUse != null) {\n            comp.InstallTrait(modData.Part, modData.Trait);\n            moduleToUse.SplitOff(1).Destroy();\n            SoundDefOf.Replant_Complete.PlayOneShot(new TargetInfo(pawn.Position, pawn.Map));\n        } else {\n            Log.Error($\"[CWF] '{modData.ModuleDef.defName}' missing in FinishAction despite passing EndCondition.\");\n        }\n    }\n\n    private void DoUninstall(CompDynamicTraits comp, ModificationData modData) {\n        comp.UninstallTrait(modData.Part);\n        var moduleThing = ThingMaker.MakeThing(modData.ModuleDef);\n        if (!pawn.inventory.innerContainer.TryAdd(moduleThing)) {\n            GenPlace.TryPlaceThing(moduleThing, pawn.Position, pawn.Map, ThingPlaceMode.Near);\n        }\n\n        SoundDefOf.Replant_Complete.PlayOneShot(new TargetInfo(pawn.Position, pawn.Map));\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponSelf.cs",
    "startLine": 8,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Postfix_FloatMenuOptionProvider_Reload_GetReloadablesUsingAmmo.Postfix(System.Collections.Generic.IEnumerable{RimWorld.Utility.IReloadableComp},Verse.Pawn,Verse.Thing)",
    "name": "Postfix",
    "fullName": "CWF.HarmonyPatches.Postfix_FloatMenuOptionProvider_Reload_GetReloadablesUsingAmmo.Postfix(System.Collections.Generic.IEnumerable<RimWorld.Utility.IReloadableComp>, Verse.Pawn, Verse.Thing)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static IEnumerable<IReloadableComp> Postfix(IEnumerable<IReloadableComp> __result, Pawn pawn,\n        Thing clickedThing) {\n        foreach (var originalResult in __result) {\n            yield return originalResult;\n        }\n\n        var primaryEqComp = pawn.equipment?.PrimaryEq;\n        if (primaryEqComp is null) yield break;\n\n        var weapon = primaryEqComp.parent;\n        var abilityProvider = weapon.TryGetComp<CompAbilityProvider>();\n\n        if (abilityProvider is not null && abilityProvider.CanBeReloadedWith(clickedThing.def)) {\n            yield return abilityProvider;\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_FloatMenuOptionProvider_Reload_GetReloadablesUsingAmmo.cs",
    "startLine": 12,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:CWF.CompAbilityProvider.CanBeReloadedWith(Verse.ThingDef)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Postfix_FloatMenuOptionProvider_Reload_GetReloadablesUsingAmmo",
    "name": "Postfix_FloatMenuOptionProvider_Reload_GetReloadablesUsingAmmo",
    "fullName": "CWF.HarmonyPatches.Postfix_FloatMenuOptionProvider_Reload_GetReloadablesUsingAmmo",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(FloatMenuOptionProvider_Reload), \"GetReloadablesUsingAmmo\")]\npublic static class Postfix_FloatMenuOptionProvider_Reload_GetReloadablesUsingAmmo {\n    public static IEnumerable<IReloadableComp> Postfix(IEnumerable<IReloadableComp> __result, Pawn pawn,\n        Thing clickedThing) {\n        foreach (var originalResult in __result) {\n            yield return originalResult;\n        }\n\n        var primaryEqComp = pawn.equipment?.PrimaryEq;\n        if (primaryEqComp is null) yield break;\n\n        var weapon = primaryEqComp.parent;\n        var abilityProvider = weapon.TryGetComp<CompAbilityProvider>();\n\n        if (abilityProvider is not null && abilityProvider.CanBeReloadedWith(clickedThing.def)) {\n            yield return abilityProvider;\n        }\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_FloatMenuOptionProvider_Reload_GetReloadablesUsingAmmo.cs",
    "startLine": 10,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(FloatMenuOptionProvider_Reload), \"GetReloadablesUsingAmmo\")"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.ModificationType",
    "name": "ModificationType",
    "fullName": "CWF.ModificationType",
    "type": "Enum",
    "baseType": null,
    "codeBody": "public enum ModificationType {\n    Install,\n    Uninstall\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/Types/ModificationData.cs",
    "startLine": 20,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.ModificationData.ExposeData",
    "name": "ExposeData",
    "fullName": "CWF.ModificationData.ExposeData()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void ExposeData() {\n        Scribe_Values.Look(ref Type, \"type\");\n        Scribe_Defs.Look(ref Part, \"part\");\n        Scribe_Defs.Look(ref Trait, \"trait\");\n        Scribe_Defs.Look(ref ModuleDef, \"moduleDef\");\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/Types/ModificationData.cs",
    "startLine": 12,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Scribe_Values.Look``1(``0@,System.String,``0,System.Boolean)",
      "M:Verse.Scribe_Defs.Look``1(``0@,System.String)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.ModificationData",
    "name": "ModificationData",
    "fullName": "CWF.ModificationData",
    "type": "Class",
    "baseType": null,
    "codeBody": "public class ModificationData : IExposable {\n    public ModificationType Type;\n    public PartDef Part = null!;\n    public WeaponTraitDef Trait = null!;\n    public ThingDef ModuleDef = null!;\n\n    public void ExposeData() {\n        Scribe_Values.Look(ref Type, \"type\");\n        Scribe_Defs.Look(ref Part, \"part\");\n        Scribe_Defs.Look(ref Trait, \"trait\");\n        Scribe_Defs.Look(ref ModuleDef, \"moduleDef\");\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/Types/ModificationData.cs",
    "startLine": 6,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": ["IExposable"],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompProperties_Colorable.#ctor",
    "name": ".ctor",
    "fullName": "CWF.CompProperties_Colorable.CompProperties_Colorable()",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public CompProperties_Colorable() => compClass = typeof(CompColorable);",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_Colorable.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": ["M:CWF.AdapterDef.AdaptWeapon(Verse.ThingDef,CWF.AdapterDef)"]
  },
  {
    "id": "T:CWF.CompProperties_Colorable",
    "name": "CompProperties_Colorable",
    "fullName": "CWF.CompProperties_Colorable",
    "type": "Class",
    "baseType": "Verse.CompProperties",
    "codeBody": "public class CompProperties_Colorable : CompProperties {\n    public CompProperties_Colorable() => compClass = typeof(CompColorable);\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_Colorable.cs",
    "startLine": 9,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.WeaponWindow.PostClose",
    "name": "PostClose",
    "fullName": "CWF.WeaponWindow.PostClose()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void PostClose() {\n        base.PostClose();\n        _interactionController.OnDataChanged -= _specDatabase.Recalculate;\n        _jobDispatcher.CommitChangesAndDispatchJobs();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/WeaponWindow.cs",
    "startLine": 67,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Window.PostClose",
      "M:CWF.Controllers.JobDispatcher.CommitChangesAndDispatchJobs"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.WeaponWindow.DoWindowContents(UnityEngine.Rect)",
    "name": "DoWindowContents",
    "fullName": "CWF.WeaponWindow.DoWindowContents(UnityEngine.Rect)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void DoWindowContents(Rect inRect) {\n        const float headerHeight = 32f;\n        const float headerGap = 12f;\n        const float asideGap = 24f;\n        const float asideWidthFraction = 0.24f;\n        const float asideMaxWidth = 250f;\n\n        // Rects\n        var headerRect = new Rect(inRect.x, inRect.y, inRect.width, headerHeight);\n        var bodyRect = new Rect(inRect.x, headerRect.yMax + headerGap, inRect.width,\n            inRect.height - headerHeight - headerGap);\n\n        // Body Aside\n        var asideWidth = Mathf.Min(bodyRect.width * asideWidthFraction, asideMaxWidth);\n        var asideRect = new Rect(bodyRect.x, bodyRect.y, asideWidth, bodyRect.height);\n\n        // Body Main\n        var mainRect = new Rect(asideRect.xMax + asideGap, bodyRect.y,\n            bodyRect.width - asideWidth - asideGap, bodyRect.height);\n\n        // Draw\n        _headerDrawer.Draw(in headerRect);\n        _asideDrawer.Draw(in asideRect);\n        _mainDrawer.Draw(in mainRect);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/WeaponWindow.cs",
    "startLine": 41,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:UnityEngine.Mathf.Min(System.Single,System.Single)",
      "M:CWF.ViewDrawers.HeaderDrawer.Draw(UnityEngine.Rect@)",
      "M:CWF.ViewDrawers.AsideDrawer.Draw(UnityEngine.Rect@)",
      "M:CWF.ViewDrawers.MainDrawer.Draw(UnityEngine.Rect@)",
      "M:UnityEngine.Rect.#ctor(System.Single,System.Single,System.Single,System.Single)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.WeaponWindow.#ctor(Verse.Thing)",
    "name": ".ctor",
    "fullName": "CWF.WeaponWindow.WeaponWindow(Verse.Thing)",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public WeaponWindow(Thing weapon) {\n        // === UI configs ===\n        doCloseX = true;\n        closeOnClickedOutside = false;\n        draggable = true;\n        resizeable = true;\n        absorbInputAroundWindow = true;\n        forcePause = true;\n\n        // Data\n        _specDatabase = new SpecDatabase(weapon);\n\n        // Controllers\n        _interactionController = new InteractionController(weapon);\n        _interactionController.OnDataChanged += _specDatabase.Recalculate;\n        _jobDispatcher = new JobDispatcher(weapon);\n\n        // Drawers\n        _headerDrawer = new HeaderDrawer(weapon);\n        _asideDrawer = new AsideDrawer(_specDatabase);\n        _mainDrawer = new MainDrawer(weapon, _interactionController.HandleSlotClick);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/WeaponWindow.cs",
    "startLine": 18,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.SpecDatabase.#ctor(Verse.Thing)",
      "M:CWF.Controllers.InteractionController.#ctor(Verse.Thing)",
      "M:CWF.Controllers.JobDispatcher.#ctor(Verse.Thing)",
      "M:CWF.ViewDrawers.HeaderDrawer.#ctor(Verse.Thing)",
      "M:CWF.ViewDrawers.AsideDrawer.#ctor(CWF.SpecDatabase)",
      "M:CWF.ViewDrawers.MainDrawer.#ctor(Verse.Thing,System.Action{CWF.PartDef,RimWorld.WeaponTraitDef})"
    ],
    "calledBy": [
      "M:CWF.CompDynamicTraits.CompGetEquippedGizmosExtra(Verse.Pawn)",
      "M:CWF.CompDynamicTraits.CompGetGizmosExtra"
    ]
  },
  {
    "id": "P:CWF.WeaponWindow.InitialSize",
    "name": "InitialSize",
    "fullName": "CWF.WeaponWindow.InitialSize",
    "type": "Property",
    "baseType": null,
    "codeBody": "public override Vector2 InitialSize => new(800f, 550f);",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/WeaponWindow.cs",
    "startLine": 16,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.WeaponWindow",
    "name": "WeaponWindow",
    "fullName": "CWF.WeaponWindow",
    "type": "Class",
    "baseType": "Verse.Window",
    "codeBody": "public class WeaponWindow : Window {\n    private readonly HeaderDrawer _headerDrawer;\n    private readonly AsideDrawer _asideDrawer;\n    private readonly MainDrawer _mainDrawer;\n    private readonly SpecDatabase _specDatabase;\n    private readonly InteractionController _interactionController;\n    private readonly JobDispatcher _jobDispatcher;\n\n    public override Vector2 InitialSize => new(800f, 550f);\n\n    public WeaponWindow(Thing weapon) {\n        // === UI configs ===\n        doCloseX = true;\n        closeOnClickedOutside = false;\n        draggable = true;\n        resizeable = true;\n        absorbInputAroundWindow = true;\n        forcePause = true;\n\n        // Data\n        _specDatabase = new SpecDatabase(weapon);\n\n        // Controllers\n        _interactionController = new InteractionController(weapon);\n        _interactionController.OnDataChanged += _specDatabase.Recalculate;\n        _jobDispatcher = new JobDispatcher(weapon);\n\n        // Drawers\n        _headerDrawer = new HeaderDrawer(weapon);\n        _asideDrawer = new AsideDrawer(_specDatabase);\n        _mainDrawer = new MainDrawer(weapon, _interactionController.HandleSlotClick);\n    }\n\n    public override void DoWindowContents(Rect inRect) {\n        const float headerHeight = 32f;\n        const float headerGap = 12f;\n        const float asideGap = 24f;\n        const float asideWidthFraction = 0.24f;\n        const float asideMaxWidth = 250f;\n\n        // Rects\n        var headerRect = new Rect(inRect.x, inRect.y, inRect.width, headerHeight);\n        var bodyRect = new Rect(inRect.x, headerRect.yMax + headerGap, inRect.width,\n            inRect.height - headerHeight - headerGap);\n\n        // Body Aside\n        var asideWidth = Mathf.Min(bodyRect.width * asideWidthFraction, asideMaxWidth);\n        var asideRect = new Rect(bodyRect.x, bodyRect.y, asideWidth, bodyRect.height);\n\n        // Body Main\n        var mainRect = new Rect(asideRect.xMax + asideGap, bodyRect.y,\n            bodyRect.width - asideWidth - asideGap, bodyRect.height);\n\n        // Draw\n        _headerDrawer.Draw(in headerRect);\n        _asideDrawer.Draw(in asideRect);\n        _mainDrawer.Draw(in mainRect);\n    }\n\n    public override void PostClose() {\n        base.PostClose();\n        _interactionController.OnDataChanged -= _specDatabase.Recalculate;\n        _jobDispatcher.CommitChangesAndDispatchJobs();\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/WeaponWindow.cs",
    "startLine": 8,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.JobDriver_ModifyWeaponHaul.PerformModifications(CWF.CompDynamicTraits,System.Collections.Generic.List{CWF.ModificationData})",
    "name": "PerformModifications",
    "fullName": "CWF.JobDriver_ModifyWeaponHaul.PerformModifications(CWF.CompDynamicTraits, System.Collections.Generic.List<CWF.ModificationData>)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void PerformModifications(CompDynamicTraits comp, List<ModificationData> modList) {\n        // uninstall\n        foreach (var modData in modList.Where(md => md.Type == ModificationType.Uninstall)) {\n            comp.UninstallTrait(modData.Part);\n            var moduleThing = ThingMaker.MakeThing(modData.ModuleDef);\n            GenPlace.TryPlaceThing(moduleThing, pawn.Position, pawn.Map, ThingPlaceMode.Near);\n        }\n\n        // install\n        foreach (var modData in modList.Where(md => md.Type == ModificationType.Install)) {\n            var moduleToUse = pawn.inventory.innerContainer.FirstOrDefault(t => t.def == modData.ModuleDef);\n\n            if (moduleToUse != null) {\n                comp.InstallTrait(modData.Part, modData.Trait);\n                moduleToUse.SplitOff(1).Destroy();\n            } else {\n                Log.Error($\"[CWF] '{modData.ModuleDef.defName}' missing in FinishAction despite passing EndCondition.\");\n            }\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponHaul.cs",
    "startLine": 122,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:CWF.CompDynamicTraits.UninstallTrait(CWF.PartDef)",
      "M:Verse.ThingMaker.MakeThing(Verse.ThingDef,Verse.ThingDef)",
      "M:Verse.GenPlace.TryPlaceThing(Verse.Thing,Verse.IntVec3,Verse.Map,Verse.ThingPlaceMode,System.Action{Verse.Thing,System.Int32},System.Predicate{Verse.IntVec3},System.Nullable{Verse.Rot4},System.Int32)",
      "M:System.Linq.Enumerable.FirstOrDefault``1(System.Func{``0,System.Boolean})",
      "M:CWF.CompDynamicTraits.InstallTrait(CWF.PartDef,RimWorld.WeaponTraitDef)",
      "M:Verse.Thing.Destroy(Verse.DestroyMode)",
      "M:Verse.Thing.SplitOff(System.Int32)",
      "M:Verse.Log.Error(System.String)"
    ],
    "calledBy": ["M:CWF.JobDriver_ModifyWeaponHaul.MakeNewToils"]
  },
  {
    "id": "M:CWF.JobDriver_ModifyWeaponHaul.MakeNewToils",
    "name": "MakeNewToils",
    "fullName": "CWF.JobDriver_ModifyWeaponHaul.MakeNewToils()",
    "type": "Method",
    "baseType": null,
    "codeBody": "protected override IEnumerable<Toil> MakeNewToils() {\n        // === Phase 1: Preparation ===\n        var startModificationPhase = Toils_General.Label();\n        yield return Toils_Jump.JumpIf(startModificationPhase, () => job.targetQueueB.NullOrEmpty());\n\n        // === Phase 2: Loop-Carry all required modules ===\n        var haulLoop = Toils_General.Label();\n        yield return haulLoop;\n\n        yield return Toils_JobTransforms.ExtractNextTargetFromQueue(ModuleToHaulInd);\n\n        yield return Toils_Goto\n            .GotoThing(ModuleToHaulInd, PathEndMode.ClosestTouch)\n            .FailOnDespawnedNullOrForbidden(ModuleToHaulInd);\n\n        var customCarryToil = new Toil {\n            initAction = () => {\n                var actor = pawn;\n                var thingToCarry = job.GetTarget(ModuleToHaulInd).Thing;\n\n                if (thingToCarry == null || thingToCarry.Destroyed || thingToCarry.stackCount <= 0) {\n                    // skip uncatchable modules.\n                    actor.jobs.curDriver.ReadyForNextToil();\n                    return;\n                }\n\n                actor.carryTracker.TryStartCarry(thingToCarry, 1);\n            },\n            defaultCompleteMode = ToilCompleteMode.Instant\n        };\n        yield return customCarryToil;\n\n        var moveToInventory = new Toil {\n            initAction = () => {\n                var carriedThing = pawn.carryTracker.CarriedThing;\n                if (carriedThing != null) {\n                    pawn.inventory.innerContainer.TryAddOrTransfer(carriedThing);\n                }\n            },\n            defaultCompleteMode = ToilCompleteMode.Instant\n        };\n        yield return moveToInventory;\n\n        yield return Toils_Jump.JumpIfHaveTargetInQueue(ModuleToHaulInd, haulLoop);\n\n        // === Phase 3: Perform Modification ===\n        yield return startModificationPhase;\n        yield return Toils_Goto.GotoThing(WeaponInd, PathEndMode.Touch);\n\n        var finalToil = Toils_General.WaitWith(WeaponInd, TicksPerModification * (ModDataList?.Count ?? 1), true, true);\n        finalToil.FailOnCannotTouch(WeaponInd, PathEndMode.Touch);\n\n        finalToil.AddEndCondition(() => {\n            if (ModDataList.IsNullOrEmpty()) return JobCondition.Ongoing;\n\n            return ModDataList\n                .Where(modData => modData.Type == ModificationType.Install)\n                .Any(modData => pawn.inventory.innerContainer\n                    .All(t => t.def != modData.ModuleDef))\n                ? JobCondition.Incompletable\n                : JobCondition.Ongoing;\n        });\n\n        finalToil.AddFinishAction(() => {\n            if (ended) return;\n\n            var comp = Weapon.TryGetComp<CompDynamicTraits>();\n            if (comp == null || ModDataList == null) return;\n\n            PerformModifications(comp, ModDataList);\n\n            Messages.Message(\"CWF_Message_ModificationComplete\"\n                    .Translate(pawn.Named(\"PAWN\"), Weapon.Named(\"WEAPON\")),\n                new LookTargets(pawn, Weapon), MessageTypeDefOf.PositiveEvent);\n\n            SoundDefOf.Replant_Complete.PlayOneShot(new TargetInfo(pawn.Position, pawn.Map));\n        });\n\n        yield return finalToil;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponHaul.cs",
    "startLine": 40,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.AI.Toils_General.Label",
      "M:Verse.AI.Toils_Jump.JumpIf(Verse.AI.Toil,System.Func{System.Boolean})",
      "M:Verse.GenList.NullOrEmpty``1",
      "M:Verse.AI.Toils_JobTransforms.ExtractNextTargetFromQueue(Verse.AI.TargetIndex,System.Boolean)",
      "M:Verse.AI.ToilFailConditions.FailOnDespawnedNullOrForbidden``1(Verse.AI.TargetIndex)",
      "M:Verse.AI.Toils_Goto.GotoThing(Verse.AI.TargetIndex,Verse.AI.PathEndMode,System.Boolean)",
      "M:Verse.AI.Job.GetTarget(Verse.AI.TargetIndex)",
      "M:Verse.AI.JobDriver.ReadyForNextToil",
      "M:Verse.Pawn_CarryTracker.TryStartCarry(Verse.Thing,System.Int32,System.Boolean)",
      "M:Verse.ThingOwner.TryAddOrTransfer(Verse.Thing,System.Boolean)",
      "M:Verse.AI.Toils_Jump.JumpIfHaveTargetInQueue(Verse.AI.TargetIndex,Verse.AI.Toil)",
      "M:Verse.AI.Toils_General.WaitWith(Verse.AI.TargetIndex,System.Int32,System.Boolean,System.Boolean,System.Boolean,Verse.AI.TargetIndex,Verse.AI.PathEndMode)",
      "M:Verse.AI.ToilFailConditions.FailOnCannotTouch``1(Verse.AI.TargetIndex,Verse.AI.PathEndMode)",
      "M:Verse.AI.Toil.AddEndCondition(System.Func{Verse.AI.JobCondition})",
      "M:CWF.Extensions.Extensions.IsNullOrEmpty``1",
      "M:System.Linq.Enumerable.Any``1(System.Func{``0,System.Boolean})",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:System.Linq.Enumerable.All``1(System.Func{``0,System.Boolean})",
      "M:Verse.AI.Toil.AddFinishAction(System.Action)",
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:CWF.JobDriver_ModifyWeaponHaul.PerformModifications(CWF.CompDynamicTraits,System.Collections.Generic.List{CWF.ModificationData})",
      "M:Verse.Messages.Message(System.String,Verse.LookTargets,Verse.MessageTypeDef,System.Boolean)",
      "M:Verse.TranslatorFormattedStringExtensions.Translate(Verse.NamedArgument,Verse.NamedArgument)",
      "M:Verse.NamedArgumentUtility.Named(System.String)",
      "M:Verse.Sound.SoundStarter.PlayOneShot(Verse.Sound.SoundInfo)",
      "M:Verse.AI.Toil.#ctor",
      "M:Verse.LookTargets.#ctor(Verse.TargetInfo[])",
      "M:Verse.TargetInfo.#ctor(Verse.IntVec3,Verse.Map,System.Boolean)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.JobDriver_ModifyWeaponHaul.TryMakePreToilReservations(System.Boolean)",
    "name": "TryMakePreToilReservations",
    "fullName": "CWF.JobDriver_ModifyWeaponHaul.TryMakePreToilReservations(bool)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override bool TryMakePreToilReservations(bool errorOnFailed) {\n        // reserve weapon\n        if (!pawn.Reserve(Weapon, job, 1, -1, null, errorOnFailed)) {\n            return false;\n        }\n\n        // no modules to haul.\n        if (job.targetQueueB.NullOrEmpty()) {\n            return true;\n        }\n\n        var succeedReserved = job.targetQueueB\n            .Where(target => pawn.Reserve(target.Thing, job, 1, -1, null, errorOnFailed))\n            .ToList();\n\n        // replace queue with succeed reserved modules.\n        job.targetQueueB = Enumerable.Any(succeedReserved)\n            ? succeedReserved\n            : null;\n\n        return true; // always succeed while holding a weapon.\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponHaul.cs",
    "startLine": 17,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.AI.ReservationUtility.Reserve(Verse.LocalTargetInfo,Verse.AI.Job,System.Int32,System.Int32,Verse.ReservationLayerDef,System.Boolean,System.Boolean)",
      "M:Verse.GenList.NullOrEmpty``1",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:System.Linq.Enumerable.Any``1(System.Collections.Generic.IEnumerable{``0})"
    ],
    "calledBy": []
  },
  {
    "id": "P:CWF.JobDriver_ModifyWeaponHaul.ModDataList",
    "name": "ModDataList",
    "fullName": "CWF.JobDriver_ModifyWeaponHaul.ModDataList",
    "type": "Property",
    "baseType": null,
    "codeBody": "private List<ModificationData>? ModDataList => (job.source as JobGiver_ModifyWeapon)?.ModDataList;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponHaul.cs",
    "startLine": 15,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "P:CWF.JobDriver_ModifyWeaponHaul.Weapon",
    "name": "Weapon",
    "fullName": "CWF.JobDriver_ModifyWeaponHaul.Weapon",
    "type": "Property",
    "baseType": null,
    "codeBody": "private Thing Weapon => job.GetTarget(WeaponInd).Thing;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponHaul.cs",
    "startLine": 14,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.AI.Job.GetTarget(Verse.AI.TargetIndex)"],
    "calledBy": []
  },
  {
    "id": "T:CWF.JobDriver_ModifyWeaponHaul",
    "name": "JobDriver_ModifyWeaponHaul",
    "fullName": "CWF.JobDriver_ModifyWeaponHaul",
    "type": "Class",
    "baseType": "Verse.AI.JobDriver",
    "codeBody": "public class JobDriver_ModifyWeaponHaul : JobDriver {\n    private const TargetIndex WeaponInd = TargetIndex.A;\n    private const TargetIndex ModuleToHaulInd = TargetIndex.B;\n    private const int TicksPerModification = 60;\n\n    private Thing Weapon => job.GetTarget(WeaponInd).Thing;\n    private List<ModificationData>? ModDataList => (job.source as JobGiver_ModifyWeapon)?.ModDataList;\n\n    public override bool TryMakePreToilReservations(bool errorOnFailed) {\n        // reserve weapon\n        if (!pawn.Reserve(Weapon, job, 1, -1, null, errorOnFailed)) {\n            return false;\n        }\n\n        // no modules to haul.\n        if (job.targetQueueB.NullOrEmpty()) {\n            return true;\n        }\n\n        var succeedReserved = job.targetQueueB\n            .Where(target => pawn.Reserve(target.Thing, job, 1, -1, null, errorOnFailed))\n            .ToList();\n\n        // replace queue with succeed reserved modules.\n        job.targetQueueB = Enumerable.Any(succeedReserved)\n            ? succeedReserved\n            : null;\n\n        return true; // always succeed while holding a weapon.\n    }\n\n    protected override IEnumerable<Toil> MakeNewToils() {\n        // === Phase 1: Preparation ===\n        var startModificationPhase = Toils_General.Label();\n        yield return Toils_Jump.JumpIf(startModificationPhase, () => job.targetQueueB.NullOrEmpty());\n\n        // === Phase 2: Loop-Carry all required modules ===\n        var haulLoop = Toils_General.Label();\n        yield return haulLoop;\n\n        yield return Toils_JobTransforms.ExtractNextTargetFromQueue(ModuleToHaulInd);\n\n        yield return Toils_Goto\n            .GotoThing(ModuleToHaulInd, PathEndMode.ClosestTouch)\n            .FailOnDespawnedNullOrForbidden(ModuleToHaulInd);\n\n        var customCarryToil = new Toil {\n            initAction = () => {\n                var actor = pawn;\n                var thingToCarry = job.GetTarget(ModuleToHaulInd).Thing;\n\n                if (thingToCarry == null || thingToCarry.Destroyed || thingToCarry.stackCount <= 0) {\n                    // skip uncatchable modules.\n                    actor.jobs.curDriver.ReadyForNextToil();\n                    return;\n                }\n\n                actor.carryTracker.TryStartCarry(thingToCarry, 1);\n            },\n            defaultCompleteMode = ToilCompleteMode.Instant\n        };\n        yield return customCarryToil;\n\n        var moveToInventory = new Toil {\n            initAction = () => {\n                var carriedThing = pawn.carryTracker.CarriedThing;\n                if (carriedThing != null) {\n                    pawn.inventory.innerContainer.TryAddOrTransfer(carriedThing);\n                }\n            },\n            defaultCompleteMode = ToilCompleteMode.Instant\n        };\n        yield return moveToInventory;\n\n        yield return Toils_Jump.JumpIfHaveTargetInQueue(ModuleToHaulInd, haulLoop);\n\n        // === Phase 3: Perform Modification ===\n        yield return startModificationPhase;\n        yield return Toils_Goto.GotoThing(WeaponInd, PathEndMode.Touch);\n\n        var finalToil = Toils_General.WaitWith(WeaponInd, TicksPerModification * (ModDataList?.Count ?? 1), true, true);\n        finalToil.FailOnCannotTouch(WeaponInd, PathEndMode.Touch);\n\n        finalToil.AddEndCondition(() => {\n            if (ModDataList.IsNullOrEmpty()) return JobCondition.Ongoing;\n\n            return ModDataList\n                .Where(modData => modData.Type == ModificationType.Install)\n                .Any(modData => pawn.inventory.innerContainer\n                    .All(t => t.def != modData.ModuleDef))\n                ? JobCondition.Incompletable\n                : JobCondition.Ongoing;\n        });\n\n        finalToil.AddFinishAction(() => {\n            if (ended) return;\n\n            var comp = Weapon.TryGetComp<CompDynamicTraits>();\n            if (comp == null || ModDataList == null) return;\n\n            PerformModifications(comp, ModDataList);\n\n            Messages.Message(\"CWF_Message_ModificationComplete\"\n                    .Translate(pawn.Named(\"PAWN\"), Weapon.Named(\"WEAPON\")),\n                new LookTargets(pawn, Weapon), MessageTypeDefOf.PositiveEvent);\n\n            SoundDefOf.Replant_Complete.PlayOneShot(new TargetInfo(pawn.Position, pawn.Map));\n        });\n\n        yield return finalToil;\n    }\n\n    // helper\n    private void PerformModifications(CompDynamicTraits comp, List<ModificationData> modList) {\n        // uninstall\n        foreach (var modData in modList.Where(md => md.Type == ModificationType.Uninstall)) {\n            comp.UninstallTrait(modData.Part);\n            var moduleThing = ThingMaker.MakeThing(modData.ModuleDef);\n            GenPlace.TryPlaceThing(moduleThing, pawn.Position, pawn.Map, ThingPlaceMode.Near);\n        }\n\n        // install\n        foreach (var modData in modList.Where(md => md.Type == ModificationType.Install)) {\n            var moduleToUse = pawn.inventory.innerContainer.FirstOrDefault(t => t.def == modData.ModuleDef);\n\n            if (moduleToUse != null) {\n                comp.InstallTrait(modData.Part, modData.Trait);\n                moduleToUse.SplitOff(1).Destroy();\n            } else {\n                Log.Error($\"[CWF] '{modData.ModuleDef.defName}' missing in FinishAction despite passing EndCondition.\");\n            }\n        }\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/JobDrivers/JobDriver_ModifyWeaponHaul.cs",
    "startLine": 9,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Postfix_PawnWeaponGenerator_TryGenerateWeaponFor.Postfix(Verse.Pawn,Verse.PawnGenerationRequest)",
    "name": "Postfix",
    "fullName": "CWF.HarmonyPatches.Postfix_PawnWeaponGenerator_TryGenerateWeaponFor.Postfix(Verse.Pawn, Verse.PawnGenerationRequest)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static void Postfix(Pawn pawn, PawnGenerationRequest request) {\n        if (pawn.Faction is null || pawn.Faction.IsPlayer || !pawn.RaceProps.Humanlike) return;\n\n        var weapon = pawn.equipment?.Primary;\n        var compDynamicTraits = weapon?.TryGetComp<CompDynamicTraits>();\n\n        compDynamicTraits?.RandomizeTraits();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_PawnWeaponGenerator_TryGenerateWeaponFor.cs",
    "startLine": 9,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:CWF.CompDynamicTraits.RandomizeTraits"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Postfix_PawnWeaponGenerator_TryGenerateWeaponFor",
    "name": "Postfix_PawnWeaponGenerator_TryGenerateWeaponFor",
    "fullName": "CWF.HarmonyPatches.Postfix_PawnWeaponGenerator_TryGenerateWeaponFor",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(PawnWeaponGenerator), nameof(PawnWeaponGenerator.TryGenerateWeaponFor))]\npublic static class Postfix_PawnWeaponGenerator_TryGenerateWeaponFor {\n    public static void Postfix(Pawn pawn, PawnGenerationRequest request) {\n        if (pawn.Faction is null || pawn.Faction.IsPlayer || !pawn.RaceProps.Humanlike) return;\n\n        var weapon = pawn.equipment?.Primary;\n        var compDynamicTraits = weapon?.TryGetComp<CompDynamicTraits>();\n\n        compDynamicTraits?.RandomizeTraits();\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Postfix_PawnWeaponGenerator_TryGenerateWeaponFor.cs",
    "startLine": 7,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(PawnWeaponGenerator), nameof(PawnWeaponGenerator.TryGenerateWeaponFor))"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.PartDefOf.#cctor",
    "name": ".cctor",
    "fullName": "CWF.PartDefOf.PartDefOf()",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "static PartDefOf() {\n        DefOfHelper.EnsureInitializedInCtor(typeof(PartDefOf));\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Defs/PartDefOf.cs",
    "startLine": 18,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:RimWorld.DefOfHelper.EnsureInitializedInCtor(System.Type)"],
    "calledBy": []
  },
  {
    "id": "T:CWF.PartDefOf",
    "name": "PartDefOf",
    "fullName": "CWF.PartDefOf",
    "type": "Class",
    "baseType": null,
    "codeBody": "[DefOf]\npublic class PartDefOf {\n    public static readonly PartDef Receiver = null!;\n    public static readonly PartDef Sight = null!;\n    public static readonly PartDef Barrel = null!;\n    public static readonly PartDef Stock = null!;\n    public static readonly PartDef Muzzle = null!;\n    public static readonly PartDef Ammo = null!;\n    public static readonly PartDef Grip = null!;\n    public static readonly PartDef Trigger = null!;\n    public static readonly PartDef Magazine = null!;\n    public static readonly PartDef Underbarrel = null!;\n\n    static PartDefOf() {\n        DefOfHelper.EnsureInitializedInCtor(typeof(PartDefOf));\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Defs/PartDefOf.cs",
    "startLine": 5,
    "attributes": ["DefOf"],
    "attributeDetails": ["DefOf"],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.PartGroup",
    "name": "PartGroup",
    "fullName": "CWF.PartGroup",
    "type": "Enum",
    "baseType": null,
    "codeBody": "public enum PartGroup {\n    /// <summary>\n    /// Default value, should not be used.\n    /// </summary>\n    None = 0,\n\n    /// <summary>\n    /// The top row of the UI.\n    /// </summary>\n    Top,\n\n    /// <summary>\n    /// The bottom row of the UI.\n    /// </summary>\n    Bottom,\n\n    /// <summary>\n    /// The left column of the UI.\n    /// </summary>\n    Left,\n\n    /// <summary>\n    /// The right column of the UI.\n    /// </summary>\n    Right\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Defs/PartDef.cs",
    "startLine": 38,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.PartDef.ConfigErrors",
    "name": "ConfigErrors",
    "fullName": "CWF.PartDef.ConfigErrors()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override IEnumerable<string> ConfigErrors() {\n        foreach (var item in base.ConfigErrors()) {\n            yield return item;\n        }\n\n        if (group == PartGroup.None) {\n            yield return \"group not set\";\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Defs/PartDef.cs",
    "startLine": 24,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.Def.ConfigErrors"],
    "calledBy": []
  },
  {
    "id": "T:CWF.PartDef",
    "name": "PartDef",
    "fullName": "CWF.PartDef",
    "type": "Class",
    "baseType": "Verse.Def",
    "codeBody": "public class PartDef : Def {\n    /// <summary>\n    /// Determines the visual layout position of this part slot in the customization UI.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly PartGroup group;\n\n    /// <summary>\n    /// The sorting order of this part within its UI group.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly int order;\n\n    public override IEnumerable<string> ConfigErrors() {\n        foreach (var item in base.ConfigErrors()) {\n            yield return item;\n        }\n\n        if (group == PartGroup.None) {\n            yield return \"group not set\";\n        }\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Defs/PartDef.cs",
    "startLine": 11,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.GraphicCase",
    "name": "GraphicCase",
    "fullName": "CWF.GraphicCase",
    "type": "Class",
    "baseType": null,
    "codeBody": "[UsedImplicitly]\npublic class GraphicCase {\n    /// <summary>\n    /// The condition for applying this graphic. The graphic only applies if the weapon matches these criteria.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly WeaponMatcher? matcher;\n\n    /// <summary>\n    /// The module graphic data to use when the matcher condition is met.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly ModuleGraphicData? graphicData;\n\n    /// <summary>\n    /// If multiple GraphicCases match, the one with the highest priority is chosen.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly int priority;\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/DefModExtensions/TraitModuleExtension.cs",
    "startLine": 78,
    "attributes": ["UsedImplicitly"],
    "attributeDetails": ["UsedImplicitly"],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.TraitModuleExtension.ConfigErrors",
    "name": "ConfigErrors",
    "fullName": "CWF.TraitModuleExtension.ConfigErrors()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override IEnumerable<string> ConfigErrors() {\n        if (weaponTraitDef.defName == Def.DefaultDefName) {\n            yield return \"Required field 'weaponTraitDef' is missing in XML.\";\n        }\n\n        if (part.defName == Def.DefaultDefName) {\n            yield return \"Required field 'part' is missing in XML.\";\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/DefModExtensions/TraitModuleExtension.cs",
    "startLine": 64,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.TraitModuleExtension",
    "name": "TraitModuleExtension",
    "fullName": "CWF.TraitModuleExtension",
    "type": "Class",
    "baseType": "Verse.DefModExtension",
    "codeBody": "[UsedImplicitly]\npublic class TraitModuleExtension : DefModExtension {\n    /// <summary>\n    /// The actual trait (stat bonuses, abilities, etc.) that this module will grant to a weapon.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly WeaponTraitDef weaponTraitDef = new();\n\n    /// <summary>\n    /// The weapon part slot (e.g., Muzzle, Stock) that this module attaches to.\n    /// </summary>\n    [UsedImplicitly]\n    public PartDef part = new();\n\n    /// <summary>\n    /// A list of rules that allow this module to enable or disable other part slots on a weapon.\n    /// </summary>\n    [UsedImplicitly]\n    public List<ConditionalPartModifier>? conditionalPartModifiers;\n\n    /// <summary>\n    /// A list of specific weapon ThingDefs this module is compatible with.\n    /// </summary>\n    [UsedImplicitly]\n    public List<ThingDef>? requiredWeaponDefs;\n\n    /// <summary>\n    /// A list of weaponTags that a weapon must have for this module to be compatible.\n    /// </summary>\n    [UsedImplicitly]\n    public List<string>? requiredWeaponTags;\n\n    /// <summary>\n    /// A list of specific weapon ThingDefs this module is incompatible with.\n    /// </summary>\n    [UsedImplicitly]\n    public List<ThingDef>? excludeWeaponDefs;\n\n    /// <summary>\n    /// A list of weaponTags that will make a weapon incompatible with this module.\n    /// </summary>\n    [UsedImplicitly]\n    public List<string>? excludeWeaponTags;\n\n    /// <summary>\n    /// Defines different visual appearances for this module based on which weapon it is attached to.\n    /// </summary>\n    [UsedImplicitly]\n    public List<GraphicCase>? graphicCases;\n\n    // public Rarity rarity; // enum\n\n    public override IEnumerable<string> ConfigErrors() {\n        if (weaponTraitDef.defName == Def.DefaultDefName) {\n            yield return \"Required field 'weaponTraitDef' is missing in XML.\";\n        }\n\n        if (part.defName == Def.DefaultDefName) {\n            yield return \"Required field 'part' is missing in XML.\";\n        }\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/DefModExtensions/TraitModuleExtension.cs",
    "startLine": 12,
    "attributes": ["UsedImplicitly"],
    "attributeDetails": ["UsedImplicitly"],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.ModuleGraphicData",
    "name": "ModuleGraphicData",
    "fullName": "CWF.ModuleGraphicData",
    "type": "Class",
    "baseType": null,
    "codeBody": "[UsedImplicitly]\npublic class ModuleGraphicData {\n    /// <summary>\n    /// The file path to the module's main texture.\n    /// </summary>\n    [NoTranslate]\n    [UsedImplicitly]\n    public string? texturePath;\n\n    /// <summary>\n    /// Optional file path to an outline texture, drawn behind the main texture.\n    /// </summary>\n    [NoTranslate]\n    [UsedImplicitly]\n    public string? outlinePath;\n\n    /// <summary>\n    /// The X/Y pixel offset to apply when rendering the graphic.\n    /// </summary>\n    [UsedImplicitly]\n    public Vector2? offset;\n\n    /// <summary>\n    /// A multiplier for the size of the graphic. Defaults to 1.0.\n    /// </summary>\n    [UsedImplicitly]\n    public float? scale;\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/Types/ModuleGraphicData.cs",
    "startLine": 12,
    "attributes": ["UsedImplicitly"],
    "attributeDetails": ["UsedImplicitly"],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompProperties_AbilityProvider.#ctor",
    "name": ".ctor",
    "fullName": "CWF.CompProperties_AbilityProvider.CompProperties_AbilityProvider()",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public CompProperties_AbilityProvider() => compClass = typeof(CompAbilityProvider);",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_AbilityProvider.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": ["M:CWF.AdapterDef.AdaptWeapon(Verse.ThingDef,CWF.AdapterDef)"]
  },
  {
    "id": "T:CWF.CompProperties_AbilityProvider",
    "name": "CompProperties_AbilityProvider",
    "fullName": "CWF.CompProperties_AbilityProvider",
    "type": "Class",
    "baseType": "Verse.CompProperties",
    "codeBody": "public class CompProperties_AbilityProvider : CompProperties {\n    public CompProperties_AbilityProvider() => compClass = typeof(CompAbilityProvider);\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_AbilityProvider.cs",
    "startLine": 9,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.ViewDrawers.HeaderDrawer.Draw(UnityEngine.Rect@)",
    "name": "Draw",
    "fullName": "CWF.ViewDrawers.HeaderDrawer.Draw(in UnityEngine.Rect)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void Draw(in Rect rect) {\n        const float iconSize = 40f;\n        const float buttonSize = 32f;\n        const float gap = 8f;\n\n        // Render weapon icon\n        var iconRect = new Rect(rect.x, rect.y + (rect.height - iconSize) / 2f, iconSize, iconSize);\n        Widgets.ThingIcon(iconRect, weapon);\n\n        // Render search button\n        var searchButtonRect = new Rect(rect.xMax - buttonSize, rect.y + (rect.height - buttonSize) / 2f,\n            buttonSize, buttonSize);\n        TooltipHandler.TipRegion(searchButtonRect, \"CWF_UI_BrowseCompatibleModules\".Translate());\n        var searchVisualRect = searchButtonRect.ContractedBy(4f);\n        if (Widgets.ButtonImage(searchVisualRect, TexButton.OpenInspector)) {\n            Find.WindowStack.Add(new ModuleBrowserWindow(weapon));\n        }\n\n        // Render rename button\n        var renameButtonRect = new Rect(searchButtonRect.x - gap - buttonSize, searchButtonRect.y,\n            buttonSize, buttonSize);\n        TooltipHandler.TipRegion(renameButtonRect, \"Rename\".Translate());\n        if (Widgets.ButtonImage(renameButtonRect, TexButton.Rename)) {\n            var displayName = _compRenamable?.Nickname ?? weapon.LabelCap;\n            var inputModal = new Dialog_TextInput(\n                displayName,\n                s => {\n                    if (_compRenamable == null) return;\n\n                    if (s.Trim().NullOrEmpty() || s.Length > 20) {\n                        Messages.Message(\"NameIsInvalid\".Translate(), MessageTypeDefOf.RejectInput, false);\n                        return;\n                    }\n\n                    _compRenamable.Nickname = s.Trim();\n                },\n                \"Rename\".Translate());\n            Find.WindowStack.Add(inputModal);\n        }\n\n        // Reserve space\n        var labelRect = new Rect(iconRect.xMax + gap, rect.y,\n            renameButtonRect.x - (iconRect.xMax + gap) - gap, rect.height);\n\n        // Render name label\n        var finalDisplayName = _compRenamable?.Nickname ?? weapon.LabelCap;\n        UIKit.WithStyle(() => Widgets.Label(labelRect, finalDisplayName),\n            GameFont.Medium, anchor: TextAnchor.MiddleLeft);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/HeaderDrawer.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Widgets.ThingIcon(UnityEngine.Rect,Verse.Thing,System.Single,System.Nullable{Verse.Rot4},System.Boolean,System.Single,System.Boolean)",
      "M:Verse.TooltipHandler.TipRegion(UnityEngine.Rect,Verse.TipSignal)",
      "M:Verse.Translator.Translate",
      "M:Verse.GenUI.ContractedBy(System.Single)",
      "M:Verse.Widgets.ButtonImage(UnityEngine.Rect,UnityEngine.Texture2D,System.Boolean,System.String)",
      "M:Verse.WindowStack.Add(Verse.Window)",
      "M:Verse.GenText.NullOrEmpty",
      "M:System.String.Trim",
      "M:Verse.Messages.Message(System.String,Verse.MessageTypeDef,System.Boolean)",
      "M:CWF.UIKit.WithStyle(System.Action,Verse.GameFont,System.Nullable{UnityEngine.Color},UnityEngine.TextAnchor)",
      "M:Verse.Widgets.Label(UnityEngine.Rect,System.String)",
      "M:UnityEngine.Rect.#ctor(System.Single,System.Single,System.Single,System.Single)",
      "M:CWF.ModuleBrowserWindow.#ctor(Verse.Thing)",
      "M:CWF.Dialog_TextInput.#ctor(System.String,System.Action{System.String},System.String,System.String,System.String)"
    ],
    "calledBy": ["M:CWF.WeaponWindow.DoWindowContents(UnityEngine.Rect)"]
  },
  {
    "id": "T:CWF.ViewDrawers.HeaderDrawer",
    "name": "HeaderDrawer",
    "fullName": "CWF.ViewDrawers.HeaderDrawer",
    "type": "Class",
    "baseType": null,
    "codeBody": "public class HeaderDrawer(Thing weapon) {\n    private readonly CompRenamable? _compRenamable = weapon.TryGetComp<CompRenamable>();\n\n    public void Draw(in Rect rect) {\n        const float iconSize = 40f;\n        const float buttonSize = 32f;\n        const float gap = 8f;\n\n        // Render weapon icon\n        var iconRect = new Rect(rect.x, rect.y + (rect.height - iconSize) / 2f, iconSize, iconSize);\n        Widgets.ThingIcon(iconRect, weapon);\n\n        // Render search button\n        var searchButtonRect = new Rect(rect.xMax - buttonSize, rect.y + (rect.height - buttonSize) / 2f,\n            buttonSize, buttonSize);\n        TooltipHandler.TipRegion(searchButtonRect, \"CWF_UI_BrowseCompatibleModules\".Translate());\n        var searchVisualRect = searchButtonRect.ContractedBy(4f);\n        if (Widgets.ButtonImage(searchVisualRect, TexButton.OpenInspector)) {\n            Find.WindowStack.Add(new ModuleBrowserWindow(weapon));\n        }\n\n        // Render rename button\n        var renameButtonRect = new Rect(searchButtonRect.x - gap - buttonSize, searchButtonRect.y,\n            buttonSize, buttonSize);\n        TooltipHandler.TipRegion(renameButtonRect, \"Rename\".Translate());\n        if (Widgets.ButtonImage(renameButtonRect, TexButton.Rename)) {\n            var displayName = _compRenamable?.Nickname ?? weapon.LabelCap;\n            var inputModal = new Dialog_TextInput(\n                displayName,\n                s => {\n                    if (_compRenamable == null) return;\n\n                    if (s.Trim().NullOrEmpty() || s.Length > 20) {\n                        Messages.Message(\"NameIsInvalid\".Translate(), MessageTypeDefOf.RejectInput, false);\n                        return;\n                    }\n\n                    _compRenamable.Nickname = s.Trim();\n                },\n                \"Rename\".Translate());\n            Find.WindowStack.Add(inputModal);\n        }\n\n        // Reserve space\n        var labelRect = new Rect(iconRect.xMax + gap, rect.y,\n            renameButtonRect.x - (iconRect.xMax + gap) - gap, rect.height);\n\n        // Render name label\n        var finalDisplayName = _compRenamable?.Nickname ?? weapon.LabelCap;\n        UIKit.WithStyle(() => Widgets.Label(labelRect, finalDisplayName),\n            GameFont.Medium, anchor: TextAnchor.MiddleLeft);\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ViewDrawers/HeaderDrawer.cs",
    "startLine": 7,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.Dialog_TextInput.PreClose",
    "name": "PreClose",
    "fullName": "CWF.Dialog_TextInput.PreClose()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void PreClose() {\n        base.PreClose();\n        if (!_shouldExecuteOnClose) return;\n\n        _onConfirm.Invoke(_currentValue);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/Dialog_TextInput.cs",
    "startLine": 78,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.Window.PreClose", "M:System.Action`1.Invoke(`0)"],
    "calledBy": []
  },
  {
    "id": "M:CWF.Dialog_TextInput.OnCancelKeyPressed",
    "name": "OnCancelKeyPressed",
    "fullName": "CWF.Dialog_TextInput.OnCancelKeyPressed()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void OnCancelKeyPressed() {\n        _shouldExecuteOnClose = false;\n        base.OnCancelKeyPressed();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/Dialog_TextInput.cs",
    "startLine": 73,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.Window.OnCancelKeyPressed"],
    "calledBy": []
  },
  {
    "id": "M:CWF.Dialog_TextInput.DoWindowContents(UnityEngine.Rect)",
    "name": "DoWindowContents",
    "fullName": "CWF.Dialog_TextInput.DoWindowContents(UnityEngine.Rect)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void DoWindowContents(Rect inRect) {\n        var listing = new Listing_Standard();\n        listing.Begin(inRect);\n\n        // Render title\n        UIKit.WithStyle(() => listing.Label(_title), GameFont.Medium);\n\n        listing.Gap();\n\n        // Render input\n        GUI.SetNextControlName(\"TextInputField\");\n        _currentValue = listing.TextEntry(_currentValue); // no check internally\n        if (!_focusedField) {\n            UI.FocusControl(\"TextInputField\", this);\n            _focusedField = true;\n        }\n\n        listing.Gap();\n\n        // Footer\n        const float buttonWidth = 100f;\n        var buttonY = inRect.height - 35f;\n\n        // Cancel\n        var cancelButtonRect = new Rect(inRect.width - buttonWidth * 2 - 10f, buttonY, buttonWidth, 35f);\n        if (Widgets.ButtonText(cancelButtonRect, _cancelButtonText)) {\n            _shouldExecuteOnClose = false;\n            Close();\n        }\n\n        // Confirm\n        var confirmButtonRect = new Rect(inRect.width - buttonWidth, buttonY, buttonWidth, 35f);\n        if (Widgets.ButtonText(confirmButtonRect, _confirmButtonText)) {\n            Close();\n        }\n\n        listing.End();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/Dialog_TextInput.cs",
    "startLine": 34,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Listing_Standard.Begin(UnityEngine.Rect)",
      "M:CWF.UIKit.WithStyle(System.Action,Verse.GameFont,System.Nullable{UnityEngine.Color},UnityEngine.TextAnchor)",
      "M:Verse.Listing_Standard.Label(System.String,System.Single,System.Nullable{Verse.TipSignal})",
      "M:Verse.Listing.Gap(System.Single)",
      "M:UnityEngine.GUI.SetNextControlName(System.String)",
      "M:Verse.Listing_Standard.TextEntry(System.String,System.Int32)",
      "M:Verse.UI.FocusControl(System.String,Verse.Window)",
      "M:Verse.Widgets.ButtonText(UnityEngine.Rect,System.String,System.Boolean,System.Boolean,System.Boolean,System.Nullable{UnityEngine.TextAnchor})",
      "M:Verse.Window.Close(System.Boolean)",
      "M:Verse.Listing_Standard.End",
      "M:Verse.Listing_Standard.#ctor",
      "M:UnityEngine.Rect.#ctor(System.Single,System.Single,System.Single,System.Single)"
    ],
    "calledBy": []
  },
  {
    "id": "P:CWF.Dialog_TextInput.InitialSize",
    "name": "InitialSize",
    "fullName": "CWF.Dialog_TextInput.InitialSize",
    "type": "Property",
    "baseType": null,
    "codeBody": "public override Vector2 InitialSize => new(350f, 200f);",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/Dialog_TextInput.cs",
    "startLine": 32,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.Dialog_TextInput.#ctor(System.String,System.Action{System.String},System.String,System.String,System.String)",
    "name": ".ctor",
    "fullName": "CWF.Dialog_TextInput.Dialog_TextInput(string, System.Action<string>, string?, string?, string?)",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public Dialog_TextInput(\n        string initialValue,\n        Action<string> onConfirm,\n        string? title = null,\n        string? confirmButtonText = null,\n        string? cancelButtonText = null) {\n        _currentValue = initialValue;\n        _onConfirm = onConfirm;\n        _title = title ?? \"CWF_UI_InputTitle\".Translate();\n        _confirmButtonText = confirmButtonText ?? \"CWF_UI_Confirm\".Translate();\n        _cancelButtonText = cancelButtonText ?? \"CWF_UI_Cancel\".Translate();\n\n        forcePause = true;\n        closeOnClickedOutside = false; // modal dialog\n        absorbInputAroundWindow = true;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/Dialog_TextInput.cs",
    "startLine": 15,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.Translator.Translate"],
    "calledBy": ["M:CWF.ViewDrawers.HeaderDrawer.Draw(UnityEngine.Rect@)"]
  },
  {
    "id": "T:CWF.Dialog_TextInput",
    "name": "Dialog_TextInput",
    "fullName": "CWF.Dialog_TextInput",
    "type": "Class",
    "baseType": "Verse.Window",
    "codeBody": "public class Dialog_TextInput : Window {\n    private string _currentValue;\n    private readonly Action<string> _onConfirm;\n    private readonly string _title;\n    private readonly string _confirmButtonText;\n    private readonly string _cancelButtonText;\n    private bool _focusedField;\n    private bool _shouldExecuteOnClose = true;\n\n    public Dialog_TextInput(\n        string initialValue,\n        Action<string> onConfirm,\n        string? title = null,\n        string? confirmButtonText = null,\n        string? cancelButtonText = null) {\n        _currentValue = initialValue;\n        _onConfirm = onConfirm;\n        _title = title ?? \"CWF_UI_InputTitle\".Translate();\n        _confirmButtonText = confirmButtonText ?? \"CWF_UI_Confirm\".Translate();\n        _cancelButtonText = cancelButtonText ?? \"CWF_UI_Cancel\".Translate();\n\n        forcePause = true;\n        closeOnClickedOutside = false; // modal dialog\n        absorbInputAroundWindow = true;\n    }\n\n    public override Vector2 InitialSize => new(350f, 200f);\n\n    public override void DoWindowContents(Rect inRect) {\n        var listing = new Listing_Standard();\n        listing.Begin(inRect);\n\n        // Render title\n        UIKit.WithStyle(() => listing.Label(_title), GameFont.Medium);\n\n        listing.Gap();\n\n        // Render input\n        GUI.SetNextControlName(\"TextInputField\");\n        _currentValue = listing.TextEntry(_currentValue); // no check internally\n        if (!_focusedField) {\n            UI.FocusControl(\"TextInputField\", this);\n            _focusedField = true;\n        }\n\n        listing.Gap();\n\n        // Footer\n        const float buttonWidth = 100f;\n        var buttonY = inRect.height - 35f;\n\n        // Cancel\n        var cancelButtonRect = new Rect(inRect.width - buttonWidth * 2 - 10f, buttonY, buttonWidth, 35f);\n        if (Widgets.ButtonText(cancelButtonRect, _cancelButtonText)) {\n            _shouldExecuteOnClose = false;\n            Close();\n        }\n\n        // Confirm\n        var confirmButtonRect = new Rect(inRect.width - buttonWidth, buttonY, buttonWidth, 35f);\n        if (Widgets.ButtonText(confirmButtonRect, _confirmButtonText)) {\n            Close();\n        }\n\n        listing.End();\n    }\n\n    public override void OnCancelKeyPressed() {\n        _shouldExecuteOnClose = false;\n        base.OnCancelKeyPressed();\n    }\n\n    public override void PreClose() {\n        base.PreClose();\n        if (!_shouldExecuteOnClose) return;\n\n        _onConfirm.Invoke(_currentValue);\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/Dialog_TextInput.cs",
    "startLine": 6,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Transpiler_JobDriver_Reload_MakeNewToils.FindCustomReloadable(RimWorld.Utility.IReloadableComp,Verse.Thing)",
    "name": "FindCustomReloadable",
    "fullName": "CWF.HarmonyPatches.Transpiler_JobDriver_Reload_MakeNewToils.FindCustomReloadable(RimWorld.Utility.IReloadableComp?, Verse.Thing?)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static IReloadableComp? FindCustomReloadable(IReloadableComp? originalResult, Thing? gear) {\n        return originalResult ?? gear?.TryGetComp<CompAbilityProvider>();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_JobDriver_Reload_MakeNewToils.cs",
    "startLine": 76,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:Verse.ThingCompUtility.TryGetComp``1"],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Transpiler_JobDriver_Reload_MakeNewToils.Transpiler(System.Collections.Generic.IEnumerable{HarmonyLib.CodeInstruction},System.Reflection.Emit.ILGenerator)",
    "name": "Transpiler",
    "fullName": "CWF.HarmonyPatches.Transpiler_JobDriver_Reload_MakeNewToils.Transpiler(System.Collections.Generic.IEnumerable<HarmonyLib.CodeInstruction>, System.Reflection.Emit.ILGenerator)",
    "type": "Method",
    "baseType": null,
    "codeBody": "[HarmonyTranspiler]\n    public static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions, ILGenerator il) {\n        var codeInstructions = instructions as CodeInstruction[] ?? instructions.ToArray();\n        var codeMatcher = new CodeMatcher(codeInstructions, il);\n\n        codeMatcher.MatchStartForward(\n            new CodeMatch(instr => {\n                if (instr.opcode != OpCodes.Call) return false;\n                if (instr.operand is not MethodInfo method) return false;\n                if (method.Name != nameof(ThingCompUtility.TryGetComp) || !method.IsGenericMethod) return false;\n\n                var genericArgs = method.GetGenericArguments();\n                if (genericArgs.Length != 1) return false;\n\n                return genericArgs[0].Name == \"CompEquippableAbilityReloadable\";\n            })\n        );\n\n        if (codeMatcher.IsInvalid) {\n            Log.Error(\"[CWF] Transpiler in MoveNext failed: \" +\n                      \"Could not find the call to TryGetComp<CompEquippableAbilityReloadable>.\");\n            return codeInstructions;\n        }\n\n        codeMatcher.Advance(1);\n\n        // this maybe unnecessary\n        var stateMachineType = AccessTools\n            .FirstInner(typeof(JobDriver_Reload), t => t.Name.Contains(\"MakeNewToils\"));\n        if (stateMachineType is null) {\n            Log.Error(\"[CWF] Transpiler in MoveNext failed: Could not re-find the state machine type.\");\n            return codeInstructions;\n        }\n\n        var thisField = AccessTools.Field(stateMachineType, \"<>4__this\");\n        if (thisField is null) {\n            Log.Error(\"[CWF] Transpiler in MoveNext failed: Could not find the '<>4__this' field.\");\n            return codeInstructions;\n        }\n\n        codeMatcher.Insert(\n            new CodeInstruction(OpCodes.Ldarg_0),\n            new CodeInstruction(OpCodes.Ldfld, thisField),\n            new CodeInstruction(OpCodes.Call, AccessTools.PropertyGetter(typeof(JobDriver_Reload), \"Gear\")),\n            new CodeInstruction(OpCodes.Call,\n                AccessTools.Method(typeof(Transpiler_JobDriver_Reload_MakeNewToils), nameof(FindCustomReloadable)))\n        );\n\n        return codeMatcher.InstructionEnumeration();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_JobDriver_Reload_MakeNewToils.cs",
    "startLine": 25,
    "attributes": ["HarmonyTranspiler"],
    "attributeDetails": ["HarmonyTranspiler"],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.ToArray``1",
      "M:HarmonyLib.CodeMatcher.MatchStartForward(HarmonyLib.CodeMatch[])",
      "M:System.Reflection.MethodInfo.GetGenericArguments",
      "M:Verse.Log.Error(System.String)",
      "M:HarmonyLib.CodeMatcher.Advance(System.Int32)",
      "M:HarmonyLib.AccessTools.FirstInner(System.Type,System.Func{System.Type,System.Boolean})",
      "M:System.String.Contains(System.String)",
      "M:HarmonyLib.AccessTools.Field(System.Type,System.String)",
      "M:HarmonyLib.CodeMatcher.Insert(HarmonyLib.CodeInstruction[])",
      "M:HarmonyLib.AccessTools.PropertyGetter(System.Type,System.String)",
      "M:HarmonyLib.AccessTools.Method(System.Type,System.String,System.Type[],System.Type[])",
      "M:HarmonyLib.CodeMatcher.InstructionEnumeration",
      "M:HarmonyLib.CodeMatcher.#ctor(System.Collections.Generic.IEnumerable{HarmonyLib.CodeInstruction},System.Reflection.Emit.ILGenerator)",
      "M:HarmonyLib.CodeMatch.#ctor(System.Func{HarmonyLib.CodeInstruction,System.Boolean},System.String)",
      "M:HarmonyLib.CodeInstruction.#ctor(System.Reflection.Emit.OpCode,System.Object)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Transpiler_JobDriver_Reload_MakeNewToils.TargetMethod",
    "name": "TargetMethod",
    "fullName": "CWF.HarmonyPatches.Transpiler_JobDriver_Reload_MakeNewToils.TargetMethod()",
    "type": "Method",
    "baseType": null,
    "codeBody": "[HarmonyTargetMethod]\n    public static MethodBase? TargetMethod() {\n        var stateMachineType = AccessTools\n            .FirstInner(typeof(JobDriver_Reload), t => t.Name.Contains(\"MakeNewToils\"));\n\n        if (stateMachineType is not null) {\n            return AccessTools.Method(stateMachineType, \"MoveNext\");\n        }\n\n        Log.Error(\"[CWF] Could not find the state machine type for JobDriver_Reload.MakeNewToils.\");\n        return null;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_JobDriver_Reload_MakeNewToils.cs",
    "startLine": 12,
    "attributes": ["HarmonyTargetMethod"],
    "attributeDetails": ["HarmonyTargetMethod"],
    "implementedInterfaces": [],
    "calls": [
      "M:HarmonyLib.AccessTools.FirstInner(System.Type,System.Func{System.Type,System.Boolean})",
      "M:System.String.Contains(System.String)",
      "M:HarmonyLib.AccessTools.Method(System.Type,System.String,System.Type[],System.Type[])",
      "M:Verse.Log.Error(System.String)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Transpiler_JobDriver_Reload_MakeNewToils",
    "name": "Transpiler_JobDriver_Reload_MakeNewToils",
    "fullName": "CWF.HarmonyPatches.Transpiler_JobDriver_Reload_MakeNewToils",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch]\npublic static class Transpiler_JobDriver_Reload_MakeNewToils {\n    [HarmonyTargetMethod]\n    public static MethodBase? TargetMethod() {\n        var stateMachineType = AccessTools\n            .FirstInner(typeof(JobDriver_Reload), t => t.Name.Contains(\"MakeNewToils\"));\n\n        if (stateMachineType is not null) {\n            return AccessTools.Method(stateMachineType, \"MoveNext\");\n        }\n\n        Log.Error(\"[CWF] Could not find the state machine type for JobDriver_Reload.MakeNewToils.\");\n        return null;\n    }\n\n    [HarmonyTranspiler]\n    public static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions, ILGenerator il) {\n        var codeInstructions = instructions as CodeInstruction[] ?? instructions.ToArray();\n        var codeMatcher = new CodeMatcher(codeInstructions, il);\n\n        codeMatcher.MatchStartForward(\n            new CodeMatch(instr => {\n                if (instr.opcode != OpCodes.Call) return false;\n                if (instr.operand is not MethodInfo method) return false;\n                if (method.Name != nameof(ThingCompUtility.TryGetComp) || !method.IsGenericMethod) return false;\n\n                var genericArgs = method.GetGenericArguments();\n                if (genericArgs.Length != 1) return false;\n\n                return genericArgs[0].Name == \"CompEquippableAbilityReloadable\";\n            })\n        );\n\n        if (codeMatcher.IsInvalid) {\n            Log.Error(\"[CWF] Transpiler in MoveNext failed: \" +\n                      \"Could not find the call to TryGetComp<CompEquippableAbilityReloadable>.\");\n            return codeInstructions;\n        }\n\n        codeMatcher.Advance(1);\n\n        // this maybe unnecessary\n        var stateMachineType = AccessTools\n            .FirstInner(typeof(JobDriver_Reload), t => t.Name.Contains(\"MakeNewToils\"));\n        if (stateMachineType is null) {\n            Log.Error(\"[CWF] Transpiler in MoveNext failed: Could not re-find the state machine type.\");\n            return codeInstructions;\n        }\n\n        var thisField = AccessTools.Field(stateMachineType, \"<>4__this\");\n        if (thisField is null) {\n            Log.Error(\"[CWF] Transpiler in MoveNext failed: Could not find the '<>4__this' field.\");\n            return codeInstructions;\n        }\n\n        codeMatcher.Insert(\n            new CodeInstruction(OpCodes.Ldarg_0),\n            new CodeInstruction(OpCodes.Ldfld, thisField),\n            new CodeInstruction(OpCodes.Call, AccessTools.PropertyGetter(typeof(JobDriver_Reload), \"Gear\")),\n            new CodeInstruction(OpCodes.Call,\n                AccessTools.Method(typeof(Transpiler_JobDriver_Reload_MakeNewToils), nameof(FindCustomReloadable)))\n        );\n\n        return codeMatcher.InstructionEnumeration();\n    }\n\n    public static IReloadableComp? FindCustomReloadable(IReloadableComp? originalResult, Thing? gear) {\n        return originalResult ?? gear?.TryGetComp<CompAbilityProvider>();\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_JobDriver_Reload_MakeNewToils.cs",
    "startLine": 10,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": ["HarmonyPatch"],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.WeaponMatcher.IsMatch(Verse.ThingDef)",
    "name": "IsMatch",
    "fullName": "CWF.WeaponMatcher.IsMatch(Verse.ThingDef)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public bool IsMatch(ThingDef weaponDef) {\n        if (weaponDefs.Contains(weaponDef)) return true;\n\n        if (weaponTags.Empty() || weaponDef.weaponTags.NullOrEmpty()) return false;\n\n        return weaponTags.Any(tag => weaponDef.weaponTags.Contains(tag));\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/Types/WeaponMatcher.cs",
    "startLine": 26,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Collections.Generic.List`1.Contains(`0)",
      "M:Verse.GenCollection.Empty``1",
      "M:Verse.GenList.NullOrEmpty``1",
      "M:Verse.GenCollection.Any``1(System.Predicate{``0})"
    ],
    "calledBy": [
      "M:CWF.Controllers.InteractionController.CalculateFutureAvailableParts(System.Collections.Generic.IEnumerable{RimWorld.WeaponTraitDef})",
      "M:CWF.Controllers.InteractionController.AnalyzeInstallConflict(Verse.ThingDef)",
      "M:CWF.CompDynamicGraphic.GetGraphicDataFor(RimWorld.WeaponTraitDef)",
      "M:CWF.CompDynamicTraits.RecalculateAvailableParts"
    ]
  },
  {
    "id": "T:CWF.WeaponMatcher",
    "name": "WeaponMatcher",
    "fullName": "CWF.WeaponMatcher",
    "type": "Class",
    "baseType": null,
    "codeBody": "[UsedImplicitly]\npublic class WeaponMatcher {\n    /// <summary>\n    /// A list of specific weapon ThingDefs to match against.\n    /// </summary>\n    [UsedImplicitly]\n    public List<ThingDef> weaponDefs = [];\n\n    /// <summary>\n    /// A list of weaponTags to match against.\n    /// </summary>\n    [UsedImplicitly]\n    public List<string> weaponTags = [];\n\n    public bool IsMatch(ThingDef weaponDef) {\n        if (weaponDefs.Contains(weaponDef)) return true;\n\n        if (weaponTags.Empty() || weaponDef.weaponTags.NullOrEmpty()) return false;\n\n        return weaponTags.Any(tag => weaponDef.weaponTags.Contains(tag));\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/Types/WeaponMatcher.cs",
    "startLine": 12,
    "attributes": ["UsedImplicitly"],
    "attributeDetails": ["UsedImplicitly"],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.ConditionalPartModifier",
    "name": "ConditionalPartModifier",
    "fullName": "CWF.ConditionalPartModifier",
    "type": "Class",
    "baseType": null,
    "codeBody": "[UsedImplicitly]\npublic class ConditionalPartModifier {\n    /// <summary>\n    /// The condition for applying this modifier. The rule only runs if the weapon matches these criteria.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly WeaponMatcher? matcher;\n\n    /// <summary>\n    /// A list of part slots to enable on the weapon when this rule is met.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly List<PartDef> enablesParts = [];\n\n    /// <summary>\n    /// A list of part slots to disable on the weapon when this rule is met.\n    /// </summary>\n    [UsedImplicitly]\n    public readonly List<PartDef> disablesParts = [];\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/Types/ConditionalPartModifier.cs",
    "startLine": 10,
    "attributes": ["UsedImplicitly"],
    "attributeDetails": ["UsedImplicitly"],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompProperties_Renamable.#ctor",
    "name": ".ctor",
    "fullName": "CWF.CompProperties_Renamable.CompProperties_Renamable()",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public CompProperties_Renamable() => compClass = typeof(CompRenamable);",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_Renamable.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": ["M:CWF.AdapterDef.AdaptWeapon(Verse.ThingDef,CWF.AdapterDef)"]
  },
  {
    "id": "T:CWF.CompProperties_Renamable",
    "name": "CompProperties_Renamable",
    "fullName": "CWF.CompProperties_Renamable",
    "type": "Class",
    "baseType": "Verse.CompProperties",
    "codeBody": "public class CompProperties_Renamable : CompProperties {\n    public CompProperties_Renamable() => compClass = typeof(CompRenamable);\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_Renamable.cs",
    "startLine": 9,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.ModuleBrowserWindow.DrawRightColumn(UnityEngine.Rect@)",
    "name": "DrawRightColumn",
    "fullName": "CWF.ModuleBrowserWindow.DrawRightColumn(in UnityEngine.Rect)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void DrawRightColumn(in Rect rect) {\n        var listing = new Listing_Standard();\n        listing.Begin(rect);\n\n        const float padding = 8f;\n        const float titleHeight = 32f;\n        var titleRect = listing.GetRect(titleHeight);\n        var paddedTitleRect = new Rect(titleRect.x + padding, titleRect.y, titleRect.width - padding, titleRect.height);\n\n        UIKit.WithStyle(() => Widgets.Label(paddedTitleRect, \"CWF_UI_CompatibleModules\".Translate()), GameFont.Medium);\n\n        var modulesToShow = _selectedPart switch {\n            null => _groupedModules.Values.SelectMany(list => list).ToList(),\n            _ => _groupedModules.GetValueOrDefault(_selectedPart) ?? []\n        };\n\n        if (modulesToShow.Empty()) {\n            var noModuleLabelRect = listing.GetRect(Text.LineHeight);\n            noModuleLabelRect.x += padding;\n            Widgets.Label(noModuleLabelRect, \"CWF_UI_NoCompatibleModules\".Translate());\n            listing.End();\n            return;\n        }\n\n        const float rowHeight = 32f;\n\n        var viewHeight = rect.height - listing.CurHeight;\n        var viewRect = new Rect(0, listing.CurHeight, rect.width, viewHeight);\n\n        var contentHeight = modulesToShow.Count * rowHeight;\n        var contentRect = new Rect(0, 0, viewRect.width - 16f, contentHeight);\n\n        Widgets.BeginScrollView(viewRect, ref _rightColumnScrollPosition, contentRect);\n\n        var currentY = 0f;\n\n        foreach (var moduleDef in modulesToShow.OrderBy(m => m.LabelCap.ToString())) {\n            var rowRect = new Rect(contentRect.x, currentY, contentRect.width, rowHeight);\n            Widgets.DrawHighlightIfMouseover(rowRect);\n            var traitDef = moduleDef.GetModExtension<TraitModuleExtension>().weaponTraitDef;\n            var sb = new StringBuilder();\n            sb.AppendLine(moduleDef.description);\n            sb.AppendInNewLine(traitDef.GetTraitEffect());\n            TooltipHandler.TipRegion(rowRect, sb.ToString());\n\n            // todo: modified calculation\n            var labelRect = new Rect(rowRect.x + padding, rowRect.y, rowRect.width - 100f, rowRect.height);\n            UIKit.WithStyle(() => Widgets.Label(labelRect, moduleDef.LabelCap), anchor: TextAnchor.MiddleLeft);\n\n            var infoButtonRect = new Rect(rowRect.xMax - 32f, rowRect.y + (rowRect.height - 32f) / 2, rowHeight,\n                rowHeight);\n            if (Widgets.ButtonImage(infoButtonRect.ContractedBy(4f), TexButton.Info)) {\n                Find.WindowStack.Add(new Dialog_InfoCard(moduleDef));\n            }\n\n            currentY += rowHeight;\n        }\n\n        Widgets.EndScrollView();\n        listing.End();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ModuleBrowserWindow.cs",
    "startLine": 84,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Listing_Standard.Begin(UnityEngine.Rect)",
      "M:Verse.Listing.GetRect(System.Single,System.Single)",
      "M:CWF.UIKit.WithStyle(System.Action,Verse.GameFont,System.Nullable{UnityEngine.Color},UnityEngine.TextAnchor)",
      "M:Verse.Widgets.Label(UnityEngine.Rect,Verse.TaggedString)",
      "M:Verse.Translator.Translate",
      "M:System.Linq.Enumerable.ToList``1",
      "M:System.Linq.Enumerable.SelectMany``2(System.Func{``0,System.Collections.Generic.IEnumerable{``1}})",
      "M:System.Collections.Generic.CollectionExtensions.GetValueOrDefault``2(``0)",
      "M:Verse.GenCollection.Empty``1",
      "M:Verse.Listing_Standard.End",
      "M:Verse.Widgets.BeginScrollView(UnityEngine.Rect,UnityEngine.Vector2@,UnityEngine.Rect,System.Boolean)",
      "M:System.Linq.Enumerable.OrderBy``2(System.Func{``0,``1})",
      "M:Verse.TaggedString.ToString",
      "M:Verse.Widgets.DrawHighlightIfMouseover(UnityEngine.Rect)",
      "M:Verse.Def.GetModExtension``1",
      "M:System.Text.StringBuilder.AppendLine(System.String)",
      "M:Verse.GenText.AppendInNewLine(System.String)",
      "M:CWF.ModuleDatabase.GetTraitEffect",
      "M:Verse.TooltipHandler.TipRegion(UnityEngine.Rect,Verse.TipSignal)",
      "M:System.Text.StringBuilder.ToString",
      "M:Verse.Widgets.ButtonImage(UnityEngine.Rect,UnityEngine.Texture2D,System.Boolean,System.String)",
      "M:Verse.GenUI.ContractedBy(System.Single)",
      "M:Verse.WindowStack.Add(Verse.Window)",
      "M:Verse.Widgets.EndScrollView",
      "M:Verse.Listing_Standard.#ctor",
      "M:UnityEngine.Rect.#ctor(System.Single,System.Single,System.Single,System.Single)",
      "M:System.Text.StringBuilder.#ctor",
      "M:Verse.Dialog_InfoCard.#ctor(Verse.Def,RimWorld.Precept_ThingStyle)"
    ],
    "calledBy": ["M:CWF.ModuleBrowserWindow.DoWindowContents(UnityEngine.Rect)"]
  },
  {
    "id": "M:CWF.ModuleBrowserWindow.DrawLeftColumn(UnityEngine.Rect@)",
    "name": "DrawLeftColumn",
    "fullName": "CWF.ModuleBrowserWindow.DrawLeftColumn(in UnityEngine.Rect)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private void DrawLeftColumn(in Rect rect) {\n        const float itemGap = 8f;\n        var listing = new Listing_Standard();\n\n        listing.Begin(rect);\n\n        UIKit.WithStyle(() => listing.Label(\"CWF_UI_Parts\".Translate()), GameFont.Medium);\n\n        listing.Gap(itemGap);\n\n        if (listing.RadioButton(\"CWF_UI_All\".Translate(), _selectedPart == null)) {\n            _selectedPart = null;\n        }\n\n        listing.Gap(itemGap);\n\n        if (_groupedModules.NullOrEmpty()) {\n            listing.End();\n            return;\n        }\n\n        foreach (var part in _groupedModules.Keys) {\n            if (listing.RadioButton(part.LabelCap, _selectedPart == part)) {\n                _selectedPart = part;\n            }\n\n            listing.Gap(itemGap);\n        }\n\n        listing.End();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ModuleBrowserWindow.cs",
    "startLine": 52,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.Listing_Standard.Begin(UnityEngine.Rect)",
      "M:CWF.UIKit.WithStyle(System.Action,Verse.GameFont,System.Nullable{UnityEngine.Color},UnityEngine.TextAnchor)",
      "M:Verse.Listing_Standard.Label(Verse.TaggedString,System.Single,System.String)",
      "M:Verse.Translator.Translate",
      "M:Verse.Listing.Gap(System.Single)",
      "M:Verse.Listing_Standard.RadioButton(System.String,System.Boolean,System.Single,System.String,System.Nullable{System.Single})",
      "M:Verse.GenDictionary.NullOrEmpty``2",
      "M:Verse.Listing_Standard.End",
      "M:Verse.Listing_Standard.#ctor"
    ],
    "calledBy": ["M:CWF.ModuleBrowserWindow.DoWindowContents(UnityEngine.Rect)"]
  },
  {
    "id": "M:CWF.ModuleBrowserWindow.DoWindowContents(UnityEngine.Rect)",
    "name": "DoWindowContents",
    "fullName": "CWF.ModuleBrowserWindow.DoWindowContents(UnityEngine.Rect)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void DoWindowContents(Rect inRect) {\n        const float leftColumnWidth = 128f;\n        const float columnGap = 16f;\n\n        var leftRect = new Rect(inRect.x, inRect.y, leftColumnWidth, inRect.height);\n        var rightRect = new Rect(leftRect.xMax + columnGap, inRect.y,\n            inRect.width - leftColumnWidth - columnGap, inRect.height);\n\n        DrawLeftColumn(leftRect);\n        DrawRightColumn(rightRect);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ModuleBrowserWindow.cs",
    "startLine": 40,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:CWF.ModuleBrowserWindow.DrawLeftColumn(UnityEngine.Rect@)",
      "M:CWF.ModuleBrowserWindow.DrawRightColumn(UnityEngine.Rect@)",
      "M:UnityEngine.Rect.#ctor(System.Single,System.Single,System.Single,System.Single)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.ModuleBrowserWindow.#ctor(Verse.Thing)",
    "name": ".ctor",
    "fullName": "CWF.ModuleBrowserWindow.ModuleBrowserWindow(Verse.Thing)",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public ModuleBrowserWindow(Thing weapon) {\n        doCloseX = true;\n        closeOnClickedOutside = false;\n        draggable = true;\n        resizeable = true;\n        absorbInputAroundWindow = true;\n        forcePause = true;\n\n        var compatibleModules = ModuleDatabase.AllModuleDefs\n            .Where(moduleDef => moduleDef.IsCompatibleWith(weapon.def));\n\n        foreach (var moduleDef in compatibleModules) {\n            var part = moduleDef.GetModExtension<TraitModuleExtension>().part;\n\n            if (!_groupedModules.ContainsKey(part)) {\n                _groupedModules[part] = [];\n            }\n\n            _groupedModules[part].Add(moduleDef);\n        }\n\n        _groupedModules = _groupedModules\n            .OrderBy(kvp => kvp.Key.LabelCap.ToString())\n            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ModuleBrowserWindow.cs",
    "startLine": 14,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})",
      "M:CWF.ModuleDatabase.IsCompatibleWith(Verse.ThingDef)",
      "M:Verse.Def.GetModExtension``1",
      "M:System.Collections.Generic.Dictionary`2.ContainsKey(`0)",
      "M:System.Collections.Generic.List`1.Add(`0)",
      "M:System.Linq.Enumerable.ToDictionary``3(System.Func{``0,``1},System.Func{``0,``2})",
      "M:System.Linq.Enumerable.OrderBy``2(System.Func{``0,``1})",
      "M:Verse.TaggedString.ToString"
    ],
    "calledBy": ["M:CWF.ViewDrawers.HeaderDrawer.Draw(UnityEngine.Rect@)"]
  },
  {
    "id": "P:CWF.ModuleBrowserWindow.InitialSize",
    "name": "InitialSize",
    "fullName": "CWF.ModuleBrowserWindow.InitialSize",
    "type": "Property",
    "baseType": null,
    "codeBody": "public override Vector2 InitialSize => new(550f, 420f);",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ModuleBrowserWindow.cs",
    "startLine": 12,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.ModuleBrowserWindow",
    "name": "ModuleBrowserWindow",
    "fullName": "CWF.ModuleBrowserWindow",
    "type": "Class",
    "baseType": "Verse.Window",
    "codeBody": "public class ModuleBrowserWindow : Window {\n    private readonly Dictionary<PartDef, List<ThingDef>> _groupedModules = new();\n    private PartDef? _selectedPart;\n    private Vector2 _rightColumnScrollPosition = Vector2.zero;\n\n    public override Vector2 InitialSize => new(550f, 420f);\n\n    public ModuleBrowserWindow(Thing weapon) {\n        doCloseX = true;\n        closeOnClickedOutside = false;\n        draggable = true;\n        resizeable = true;\n        absorbInputAroundWindow = true;\n        forcePause = true;\n\n        var compatibleModules = ModuleDatabase.AllModuleDefs\n            .Where(moduleDef => moduleDef.IsCompatibleWith(weapon.def));\n\n        foreach (var moduleDef in compatibleModules) {\n            var part = moduleDef.GetModExtension<TraitModuleExtension>().part;\n\n            if (!_groupedModules.ContainsKey(part)) {\n                _groupedModules[part] = [];\n            }\n\n            _groupedModules[part].Add(moduleDef);\n        }\n\n        _groupedModules = _groupedModules\n            .OrderBy(kvp => kvp.Key.LabelCap.ToString())\n            .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);\n    }\n\n    public override void DoWindowContents(Rect inRect) {\n        const float leftColumnWidth = 128f;\n        const float columnGap = 16f;\n\n        var leftRect = new Rect(inRect.x, inRect.y, leftColumnWidth, inRect.height);\n        var rightRect = new Rect(leftRect.xMax + columnGap, inRect.y,\n            inRect.width - leftColumnWidth - columnGap, inRect.height);\n\n        DrawLeftColumn(leftRect);\n        DrawRightColumn(rightRect);\n    }\n\n    private void DrawLeftColumn(in Rect rect) {\n        const float itemGap = 8f;\n        var listing = new Listing_Standard();\n\n        listing.Begin(rect);\n\n        UIKit.WithStyle(() => listing.Label(\"CWF_UI_Parts\".Translate()), GameFont.Medium);\n\n        listing.Gap(itemGap);\n\n        if (listing.RadioButton(\"CWF_UI_All\".Translate(), _selectedPart == null)) {\n            _selectedPart = null;\n        }\n\n        listing.Gap(itemGap);\n\n        if (_groupedModules.NullOrEmpty()) {\n            listing.End();\n            return;\n        }\n\n        foreach (var part in _groupedModules.Keys) {\n            if (listing.RadioButton(part.LabelCap, _selectedPart == part)) {\n                _selectedPart = part;\n            }\n\n            listing.Gap(itemGap);\n        }\n\n        listing.End();\n    }\n\n    private void DrawRightColumn(in Rect rect) {\n        var listing = new Listing_Standard();\n        listing.Begin(rect);\n\n        const float padding = 8f;\n        const float titleHeight = 32f;\n        var titleRect = listing.GetRect(titleHeight);\n        var paddedTitleRect = new Rect(titleRect.x + padding, titleRect.y, titleRect.width - padding, titleRect.height);\n\n        UIKit.WithStyle(() => Widgets.Label(paddedTitleRect, \"CWF_UI_CompatibleModules\".Translate()), GameFont.Medium);\n\n        var modulesToShow = _selectedPart switch {\n            null => _groupedModules.Values.SelectMany(list => list).ToList(),\n            _ => _groupedModules.GetValueOrDefault(_selectedPart) ?? []\n        };\n\n        if (modulesToShow.Empty()) {\n            var noModuleLabelRect = listing.GetRect(Text.LineHeight);\n            noModuleLabelRect.x += padding;\n            Widgets.Label(noModuleLabelRect, \"CWF_UI_NoCompatibleModules\".Translate());\n            listing.End();\n            return;\n        }\n\n        const float rowHeight = 32f;\n\n        var viewHeight = rect.height - listing.CurHeight;\n        var viewRect = new Rect(0, listing.CurHeight, rect.width, viewHeight);\n\n        var contentHeight = modulesToShow.Count * rowHeight;\n        var contentRect = new Rect(0, 0, viewRect.width - 16f, contentHeight);\n\n        Widgets.BeginScrollView(viewRect, ref _rightColumnScrollPosition, contentRect);\n\n        var currentY = 0f;\n\n        foreach (var moduleDef in modulesToShow.OrderBy(m => m.LabelCap.ToString())) {\n            var rowRect = new Rect(contentRect.x, currentY, contentRect.width, rowHeight);\n            Widgets.DrawHighlightIfMouseover(rowRect);\n            var traitDef = moduleDef.GetModExtension<TraitModuleExtension>().weaponTraitDef;\n            var sb = new StringBuilder();\n            sb.AppendLine(moduleDef.description);\n            sb.AppendInNewLine(traitDef.GetTraitEffect());\n            TooltipHandler.TipRegion(rowRect, sb.ToString());\n\n            // todo: modified calculation\n            var labelRect = new Rect(rowRect.x + padding, rowRect.y, rowRect.width - 100f, rowRect.height);\n            UIKit.WithStyle(() => Widgets.Label(labelRect, moduleDef.LabelCap), anchor: TextAnchor.MiddleLeft);\n\n            var infoButtonRect = new Rect(rowRect.xMax - 32f, rowRect.y + (rowRect.height - 32f) / 2, rowHeight,\n                rowHeight);\n            if (Widgets.ButtonImage(infoButtonRect.ContractedBy(4f), TexButton.Info)) {\n                Find.WindowStack.Add(new Dialog_InfoCard(moduleDef));\n            }\n\n            currentY += rowHeight;\n        }\n\n        Widgets.EndScrollView();\n        listing.End();\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Windows/ModuleBrowserWindow.cs",
    "startLine": 7,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompTraitModule.CompFloatMenuOptions(Verse.Pawn)",
    "name": "CompFloatMenuOptions",
    "fullName": "CWF.CompTraitModule.CompFloatMenuOptions(Verse.Pawn)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override IEnumerable<FloatMenuOption> CompFloatMenuOptions(Pawn selPawn) {\n        foreach (var option in base.CompFloatMenuOptions(selPawn)) {\n            yield return option;\n        }\n\n        if (parent.IsForbidden(selPawn) || !selPawn.health.capacities.CapableOf(PawnCapacityDefOf.Manipulation)) {\n            yield break;\n        }\n\n        if (!selPawn.CanReserveAndReach(parent, PathEndMode.ClosestTouch, Danger.Deadly)) {\n            yield return new FloatMenuOption(\"CannotReach\".Translate(parent.LabelCap), null);\n            yield break;\n        }\n\n        yield return new FloatMenuOption(\n            \"CWF_UI_PickUp\".Translate(parent.Named(\"MODULE\")),\n            () => {\n                var job = JobMaker.MakeJob(JobDefOf.TakeInventory, parent);\n                job.count = 1;\n                selPawn.jobs.TryTakeOrderedJob(job, JobTag.Misc);\n            }\n        );\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompTraitModule.cs",
    "startLine": 8,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingComp.CompFloatMenuOptions(Verse.Pawn)",
      "M:RimWorld.ForbidUtility.IsForbidden(Verse.Pawn)",
      "M:Verse.PawnCapacitiesHandler.CapableOf(Verse.PawnCapacityDef)",
      "M:Verse.AI.ReservationUtility.CanReserveAndReach(Verse.LocalTargetInfo,Verse.AI.PathEndMode,Verse.Danger,System.Int32,System.Int32,Verse.ReservationLayerDef,System.Boolean)",
      "M:Verse.TranslatorFormattedStringExtensions.Translate(Verse.NamedArgument)",
      "M:Verse.NamedArgumentUtility.Named(System.String)",
      "M:Verse.JobMaker.MakeJob(Verse.JobDef,Verse.LocalTargetInfo)",
      "M:Verse.AI.Pawn_JobTracker.TryTakeOrderedJob(Verse.AI.Job,System.Nullable{Verse.AI.JobTag},System.Boolean)",
      "M:Verse.FloatMenuOption.#ctor(System.String,System.Action,Verse.MenuOptionPriority,System.Action{UnityEngine.Rect},Verse.Thing,System.Single,System.Func{UnityEngine.Rect,System.Boolean},RimWorld.Planet.WorldObject,System.Boolean,System.Int32)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.CompTraitModule",
    "name": "CompTraitModule",
    "fullName": "CWF.CompTraitModule",
    "type": "Class",
    "baseType": "Verse.ThingComp",
    "codeBody": "public class CompTraitModule : ThingComp {\n    public override IEnumerable<FloatMenuOption> CompFloatMenuOptions(Pawn selPawn) {\n        foreach (var option in base.CompFloatMenuOptions(selPawn)) {\n            yield return option;\n        }\n\n        if (parent.IsForbidden(selPawn) || !selPawn.health.capacities.CapableOf(PawnCapacityDefOf.Manipulation)) {\n            yield break;\n        }\n\n        if (!selPawn.CanReserveAndReach(parent, PathEndMode.ClosestTouch, Danger.Deadly)) {\n            yield return new FloatMenuOption(\"CannotReach\".Translate(parent.LabelCap), null);\n            yield break;\n        }\n\n        yield return new FloatMenuOption(\n            \"CWF_UI_PickUp\".Translate(parent.Named(\"MODULE\")),\n            () => {\n                var job = JobMaker.MakeJob(JobDefOf.TakeInventory, parent);\n                job.count = 1;\n                selPawn.jobs.TryTakeOrderedJob(job, JobTag.Misc);\n            }\n        );\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompTraitModule.cs",
    "startLine": 7,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompRenamable.PostExposeData",
    "name": "PostExposeData",
    "fullName": "CWF.CompRenamable.PostExposeData()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override void PostExposeData() {\n        base.PostExposeData();\n        Scribe_Values.Look(ref _nickname, \"nickname\");\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompRenamable.cs",
    "startLine": 25,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingComp.PostExposeData",
      "M:Verse.Scribe_Values.Look``1(``0@,System.String,``0,System.Boolean)"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompRenamable.TransformLabel(System.String)",
    "name": "TransformLabel",
    "fullName": "CWF.CompRenamable.TransformLabel(string)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public override string TransformLabel(string label) {\n        return !Nickname.IsNullOrEmpty() ? Nickname : label;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompRenamable.cs",
    "startLine": 21,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": ["M:CWF.Extensions.Extensions.IsNullOrEmpty"],
    "calledBy": []
  },
  {
    "id": "P:CWF.CompRenamable.Nickname",
    "name": "Nickname",
    "fullName": "CWF.CompRenamable.Nickname",
    "type": "Property",
    "baseType": null,
    "codeBody": "public string? Nickname {\n        get => _nickname;\n        set {\n            if (!value.NullOrEmpty()) _nickname = value;\n\n            if (parent.TryGetComp<CompArt>(out var compArt)) {\n                compArt.Title = value;\n            }\n        }\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompRenamable.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.GenText.NullOrEmpty",
      "M:Verse.ThingCompUtility.TryGetComp``1(``0@)"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.CompRenamable",
    "name": "CompRenamable",
    "fullName": "CWF.CompRenamable",
    "type": "Class",
    "baseType": "Verse.ThingComp",
    "codeBody": "public class CompRenamable : ThingComp {\n    private string? _nickname;\n\n    public string? Nickname {\n        get => _nickname;\n        set {\n            if (!value.NullOrEmpty()) _nickname = value;\n\n            if (parent.TryGetComp<CompArt>(out var compArt)) {\n                compArt.Title = value;\n            }\n        }\n    }\n\n    public override string TransformLabel(string label) {\n        return !Nickname.IsNullOrEmpty() ? Nickname : label;\n    }\n\n    public override void PostExposeData() {\n        base.PostExposeData();\n        Scribe_Values.Look(ref _nickname, \"nickname\");\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/ThingComps/CompRenamable.cs",
    "startLine": 7,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Transpiler_Verb_TicksBetweenBurstShots.ApplyAllMultipliers(System.Single,Verse.Verb)",
    "name": "ApplyAllMultipliers",
    "fullName": "CWF.HarmonyPatches.Transpiler_Verb_TicksBetweenBurstShots.ApplyAllMultipliers(float, Verse.Verb)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private static float ApplyAllMultipliers(float originalTicks, Verb verb) {\n        var ticks = originalTicks;\n        var equipment = verb.EquipmentSource;\n\n        if (equipment == null) return ticks;\n\n        if (equipment.TryGetComp<CompUniqueWeapon>(out var compUniqueWeapon)) {\n            ticks = compUniqueWeapon.TraitsListForReading\n                .Where(trait => trait.burstShotSpeedMultiplier != 0)\n                .Aggregate(ticks, (current, trait) => current / trait.burstShotSpeedMultiplier);\n        }\n\n        if (equipment.TryGetComp<CompDynamicTraits>(out var compDynamicTraits)) {\n            ticks = compDynamicTraits.Traits\n                .Where(trait => trait.burstShotSpeedMultiplier != 0)\n                .Aggregate(ticks, (current, trait) => current / trait.burstShotSpeedMultiplier);\n        }\n\n        return ticks;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_Verb_TicksBetweenBurstShots.cs",
    "startLine": 46,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingCompUtility.TryGetComp``1(``0@)",
      "M:System.Linq.Enumerable.Aggregate``2(``1,System.Func{``1,``0,``1})",
      "M:System.Linq.Enumerable.Where``1(System.Func{``0,System.Boolean})"
    ],
    "calledBy": []
  },
  {
    "id": "M:CWF.HarmonyPatches.Transpiler_Verb_TicksBetweenBurstShots.Transpiler(System.Collections.Generic.IEnumerable{HarmonyLib.CodeInstruction})",
    "name": "Transpiler",
    "fullName": "CWF.HarmonyPatches.Transpiler_Verb_TicksBetweenBurstShots.Transpiler(System.Collections.Generic.IEnumerable<HarmonyLib.CodeInstruction>)",
    "type": "Method",
    "baseType": null,
    "codeBody": "public static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions) {\n        var codes = new List<CodeInstruction>(instructions);\n\n        var loopStartIndex = codes.FindIndex(code => code.opcode == OpCodes.Stloc_0) + 1;\n\n        var loopEndIndex = -1;\n        for (var i = loopStartIndex; i < codes.Count; i++) {\n            if (codes[i].opcode == OpCodes.Ldarg_0 &&\n                codes[i + 1].opcode == OpCodes.Ldloc_0 &&\n                codes[i + 2].opcode == OpCodes.Call &&\n                codes[i + 2].operand.ToString().Contains(\"RoundToInt\")) {\n                loopEndIndex = i;\n                break;\n            }\n        }\n\n        if (loopStartIndex > 0 && loopEndIndex != -1) {\n            codes.RemoveRange(loopStartIndex, loopEndIndex - loopStartIndex);\n\n            var newInstructions = new List<CodeInstruction> {\n                new(OpCodes.Ldloc_0),\n                new(OpCodes.Ldarg_0),\n                CodeInstruction.Call(typeof(Transpiler_Verb_TicksBetweenBurstShots), nameof(ApplyAllMultipliers)),\n                new(OpCodes.Stloc_0)\n            };\n\n            codes.InsertRange(loopStartIndex, newInstructions);\n        }\n        else {\n            Log.Error(\n                \"[CWF] Transpiler for Verb.get_TicksBetweenBurstShots failed. The mod may not function correctly with this version of RimWorld.\");\n        }\n\n        return codes.AsEnumerable();\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_Verb_TicksBetweenBurstShots.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:System.Collections.Generic.List`1.FindIndex(System.Predicate{`0})",
      "M:System.String.Contains(System.String)",
      "M:System.Object.ToString",
      "M:System.Collections.Generic.List`1.RemoveRange(System.Int32,System.Int32)",
      "M:HarmonyLib.CodeInstruction.Call(System.Type,System.String,System.Type[],System.Type[])",
      "M:System.Collections.Generic.List`1.InsertRange(System.Int32,System.Collections.Generic.IEnumerable{`0})",
      "M:Verse.Log.Error(System.String)",
      "M:System.Linq.Enumerable.AsEnumerable``1",
      "M:System.Collections.Generic.List`1.#ctor(System.Collections.Generic.IEnumerable{`0})",
      "M:System.Collections.Generic.List`1.#ctor"
    ],
    "calledBy": []
  },
  {
    "id": "T:CWF.HarmonyPatches.Transpiler_Verb_TicksBetweenBurstShots",
    "name": "Transpiler_Verb_TicksBetweenBurstShots",
    "fullName": "CWF.HarmonyPatches.Transpiler_Verb_TicksBetweenBurstShots",
    "type": "Class",
    "baseType": null,
    "codeBody": "[HarmonyPatch(typeof(Verb), \"get_TicksBetweenBurstShots\")]\npublic static class Transpiler_Verb_TicksBetweenBurstShots {\n    public static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions) {\n        var codes = new List<CodeInstruction>(instructions);\n\n        var loopStartIndex = codes.FindIndex(code => code.opcode == OpCodes.Stloc_0) + 1;\n\n        var loopEndIndex = -1;\n        for (var i = loopStartIndex; i < codes.Count; i++) {\n            if (codes[i].opcode == OpCodes.Ldarg_0 &&\n                codes[i + 1].opcode == OpCodes.Ldloc_0 &&\n                codes[i + 2].opcode == OpCodes.Call &&\n                codes[i + 2].operand.ToString().Contains(\"RoundToInt\")) {\n                loopEndIndex = i;\n                break;\n            }\n        }\n\n        if (loopStartIndex > 0 && loopEndIndex != -1) {\n            codes.RemoveRange(loopStartIndex, loopEndIndex - loopStartIndex);\n\n            var newInstructions = new List<CodeInstruction> {\n                new(OpCodes.Ldloc_0),\n                new(OpCodes.Ldarg_0),\n                CodeInstruction.Call(typeof(Transpiler_Verb_TicksBetweenBurstShots), nameof(ApplyAllMultipliers)),\n                new(OpCodes.Stloc_0)\n            };\n\n            codes.InsertRange(loopStartIndex, newInstructions);\n        }\n        else {\n            Log.Error(\n                \"[CWF] Transpiler for Verb.get_TicksBetweenBurstShots failed. The mod may not function correctly with this version of RimWorld.\");\n        }\n\n        return codes.AsEnumerable();\n    }\n\n    private static float ApplyAllMultipliers(float originalTicks, Verb verb) {\n        var ticks = originalTicks;\n        var equipment = verb.EquipmentSource;\n\n        if (equipment == null) return ticks;\n\n        if (equipment.TryGetComp<CompUniqueWeapon>(out var compUniqueWeapon)) {\n            ticks = compUniqueWeapon.TraitsListForReading\n                .Where(trait => trait.burstShotSpeedMultiplier != 0)\n                .Aggregate(ticks, (current, trait) => current / trait.burstShotSpeedMultiplier);\n        }\n\n        if (equipment.TryGetComp<CompDynamicTraits>(out var compDynamicTraits)) {\n            ticks = compDynamicTraits.Traits\n                .Where(trait => trait.burstShotSpeedMultiplier != 0)\n                .Aggregate(ticks, (current, trait) => current / trait.burstShotSpeedMultiplier);\n        }\n\n        return ticks;\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/HarmonyPatches/Transpiler_Verb_TicksBetweenBurstShots.cs",
    "startLine": 8,
    "attributes": ["HarmonyPatch"],
    "attributeDetails": [
      "HarmonyPatch(typeof(Verb), \"get_TicksBetweenBurstShots\")"
    ],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.Spec.#ctor(System.Single,System.Boolean)",
    "name": ".ctor",
    "fullName": "CWF.Spec.Spec(float, bool)",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "internal Spec(float raw, bool isLowerValueBetter = false) {\n        Raw = raw;\n        IsLowerValueBetter = isLowerValueBetter;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/SpecDatabase.cs",
    "startLine": 137,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": ["M:CWF.SpecDatabase.#ctor(Verse.Thing)"]
  },
  {
    "id": "P:CWF.Spec.IsLowerValueBetter",
    "name": "IsLowerValueBetter",
    "fullName": "CWF.Spec.IsLowerValueBetter",
    "type": "Property",
    "baseType": null,
    "codeBody": "public bool IsLowerValueBetter { get; }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/SpecDatabase.cs",
    "startLine": 135,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.Spec",
    "name": "Spec",
    "fullName": "CWF.Spec",
    "type": "Struct",
    "baseType": null,
    "codeBody": "internal struct Spec {\n    public readonly float Raw;\n    public float Dynamic = 0f;\n    public bool IsLowerValueBetter { get; }\n\n    internal Spec(float raw, bool isLowerValueBetter = false) {\n        Raw = raw;\n        IsLowerValueBetter = isLowerValueBetter;\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/SpecDatabase.cs",
    "startLine": 132,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.SpecDatabase.GetComputedStoppingPower",
    "name": "GetComputedStoppingPower",
    "fullName": "CWF.SpecDatabase.GetComputedStoppingPower()",
    "type": "Method",
    "baseType": null,
    "codeBody": "private float GetComputedStoppingPower() {\n        var basePower = _weapon.def.Verbs\n            .FirstOrFallback()?.defaultProjectile?.projectile.stoppingPower ?? 0.5f;\n\n        // CompUniqueWeapon\n        if (_weapon.TryGetComp<CompUniqueWeapon>(out var compUniqueWeapon)) {\n            basePower += compUniqueWeapon.TraitsListForReading.Sum(trait => trait.additionalStoppingPower);\n        }\n\n        // CompDynamicTraits\n        var additional = _compDynamicTraits?.Traits.Sum(traitDef => traitDef.additionalStoppingPower) ?? 0;\n\n        return basePower + additional;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/SpecDatabase.cs",
    "startLine": 116,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.GenCollection.FirstOrFallback``1(``0)",
      "M:Verse.ThingCompUtility.TryGetComp``1(``0@)",
      "M:System.Linq.Enumerable.Sum``1(System.Func{``0,System.Single})"
    ],
    "calledBy": ["M:CWF.SpecDatabase.Recalculate"]
  },
  {
    "id": "M:CWF.SpecDatabase.CalculateDps(CWF.SpecDatabase.Mode)",
    "name": "CalculateDps",
    "fullName": "CWF.SpecDatabase.CalculateDps(CWF.SpecDatabase.Mode)",
    "type": "Method",
    "baseType": null,
    "codeBody": "private float CalculateDps(Mode mode) {\n        var damage = mode == Mode.Raw ? Damage.Raw : Damage.Dynamic;\n        var burstCount = mode == Mode.Raw ? BurstShotCount.Raw : BurstShotCount.Dynamic;\n        var ticksBetweenShots = mode == Mode.Raw\n            ? _ticksBetweenBurstShots.Raw\n            : _ticksBetweenBurstShots.Dynamic;\n        var warmup = mode == Mode.Raw ? WarmupTime.Raw : WarmupTime.Dynamic;\n        var cooldown = mode == Mode.Raw ? Cooldown.Raw : Cooldown.Dynamic;\n\n        var totalDamage = damage * burstCount;\n        var totalBurstSec = ticksBetweenShots * (burstCount - 1) / 60f;\n        var totalCycleSec = warmup + cooldown + totalBurstSec;\n        return totalCycleSec <= 0 ? 0f : totalDamage / totalCycleSec;\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/SpecDatabase.cs",
    "startLine": 101,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": [
      "M:CWF.SpecDatabase.Recalculate",
      "M:CWF.SpecDatabase.#ctor(Verse.Thing)"
    ]
  },
  {
    "id": "M:CWF.SpecDatabase.Recalculate",
    "name": "Recalculate",
    "fullName": "CWF.SpecDatabase.Recalculate()",
    "type": "Method",
    "baseType": null,
    "codeBody": "public void Recalculate() {\n        // === Stat ===\n        Mass.Dynamic = _weapon.GetStatValue(StatDefOf.Mass);\n        MarketValue.Dynamic = _weapon.GetStatValue(StatDefOf.MarketValue);\n        Cooldown.Dynamic = _weapon.GetStatValue(StatDefOf.RangedWeapon_Cooldown);\n        AccuracyTouch.Dynamic = _weapon.GetStatValue(StatDefOf.AccuracyTouch);\n        AccuracyShort.Dynamic = _weapon.GetStatValue(StatDefOf.AccuracyShort);\n        AccuracyMedium.Dynamic = _weapon.GetStatValue(StatDefOf.AccuracyMedium);\n        AccuracyLong.Dynamic = _weapon.GetStatValue(StatDefOf.AccuracyLong);\n\n        // === Verb ===\n        var weaponVerb = _weapon.TryGetComp<CompEquippableAbilityReloadable>()?.PrimaryVerb\n                         ?? _weapon.TryGetComp<CompEquippable>()?.PrimaryVerb;\n\n        Range.Dynamic = Range.Raw * _weapon.GetStatValue(StatDefOf.RangedWeapon_RangeMultiplier);\n        WarmupTime.Dynamic = WarmupTime.Raw * _weapon.GetStatValue(StatDefOf.RangedWeapon_WarmupMultiplier);\n        BurstShotCount.Dynamic = weaponVerb?.BurstShotCount ?? -1; // harmony patched\n        _ticksBetweenBurstShots.Dynamic = weaponVerb?.TicksBetweenBurstShots ?? -1; // harmony patched\n\n        // === Projectile ===\n        var weaponDefProjectile = _weapon.def.Verbs.FirstOrFallback()?.defaultProjectile?.projectile;\n        if (weaponDefProjectile != null) {\n            Damage.Dynamic = weaponDefProjectile.GetDamageAmount(_weapon);\n            ArmorPenetration.Dynamic = weaponDefProjectile.GetArmorPenetration(_weapon);\n            StoppingPower.Dynamic = GetComputedStoppingPower(); // harmony patched\n        }\n\n        Dps.Dynamic = CalculateDps(Mode.Dynamic);\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/SpecDatabase.cs",
    "startLine": 70,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:RimWorld.StatExtension.GetStatValue(RimWorld.StatDef,System.Boolean,System.Int32)",
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:Verse.GenCollection.FirstOrFallback``1(``0)",
      "M:Verse.ProjectileProperties.GetDamageAmount(Verse.Thing,System.Text.StringBuilder)",
      "M:Verse.ProjectileProperties.GetArmorPenetration(Verse.Thing,System.Text.StringBuilder)",
      "M:CWF.SpecDatabase.GetComputedStoppingPower",
      "M:CWF.SpecDatabase.CalculateDps(CWF.SpecDatabase.Mode)"
    ],
    "calledBy": ["M:CWF.SpecDatabase.#ctor(Verse.Thing)"]
  },
  {
    "id": "M:CWF.SpecDatabase.#ctor(Verse.Thing)",
    "name": ".ctor",
    "fullName": "CWF.SpecDatabase.SpecDatabase(Verse.Thing)",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public SpecDatabase(Thing weapon) {\n        _weapon = weapon;\n        _compDynamicTraits = _weapon.TryGetComp<CompDynamicTraits>();\n\n        // Raw values\n        // === Stat ===\n        var weaponDef = weapon.def;\n        Mass = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.Mass), true);\n        MarketValue = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.MarketValue));\n        Cooldown = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.RangedWeapon_Cooldown), true);\n        AccuracyTouch = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.AccuracyTouch));\n        AccuracyShort = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.AccuracyShort));\n        AccuracyMedium = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.AccuracyMedium));\n        AccuracyLong = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.AccuracyLong));\n\n        // === Verb ===\n        var weaponDefVerb = weaponDef.Verbs.FirstOrFallback();\n        if (weaponDefVerb != null) {\n            Range = new Spec(weaponDefVerb.range);\n            WarmupTime = new Spec(weaponDefVerb.warmupTime, true);\n            BurstShotCount = new Spec(weaponDefVerb.burstShotCount);\n            _ticksBetweenBurstShots = new Spec(weaponDefVerb.ticksBetweenBurstShots);\n\n            // === Projectile ===\n            var weaponDefProjectile = weaponDefVerb.defaultProjectile?.projectile;\n            if (weaponDefProjectile != null) {\n                Damage = new Spec(weaponDefProjectile.GetDamageAmount(weaponDef, weapon.Stuff));\n                ArmorPenetration = new Spec(weaponDefProjectile.GetArmorPenetration());\n                StoppingPower = new Spec(weaponDefProjectile.stoppingPower);\n            }\n        }\n\n        Dps = new Spec(CalculateDps(Mode.Raw));\n\n        Recalculate(); // init calc\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/SpecDatabase.cs",
    "startLine": 33,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [
      "M:Verse.ThingCompUtility.TryGetComp``1",
      "M:RimWorld.StatExtension.GetStatValueAbstract(RimWorld.StatDef,Verse.ThingDef)",
      "M:Verse.GenCollection.FirstOrFallback``1(``0)",
      "M:Verse.ProjectileProperties.GetDamageAmount(Verse.ThingDef,Verse.ThingDef,System.Text.StringBuilder)",
      "M:Verse.ProjectileProperties.GetArmorPenetration(Verse.Thing,System.Text.StringBuilder)",
      "M:CWF.SpecDatabase.CalculateDps(CWF.SpecDatabase.Mode)",
      "M:CWF.SpecDatabase.Recalculate",
      "M:CWF.Spec.#ctor(System.Single,System.Boolean)"
    ],
    "calledBy": ["M:CWF.WeaponWindow.#ctor(Verse.Thing)"]
  },
  {
    "id": "P:CWF.SpecDatabase.IsMeleeWeapon",
    "name": "IsMeleeWeapon",
    "fullName": "CWF.SpecDatabase.IsMeleeWeapon",
    "type": "Property",
    "baseType": null,
    "codeBody": "public bool IsMeleeWeapon => _weapon.def.IsMeleeWeapon;",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/SpecDatabase.cs",
    "startLine": 31,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.SpecDatabase.Mode",
    "name": "Mode",
    "fullName": "CWF.SpecDatabase.Mode",
    "type": "Enum",
    "baseType": null,
    "codeBody": "private enum Mode {\n        Raw,\n        Dynamic\n    }",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/SpecDatabase.cs",
    "startLine": 26,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.SpecDatabase",
    "name": "SpecDatabase",
    "fullName": "CWF.SpecDatabase",
    "type": "Class",
    "baseType": null,
    "codeBody": "public class SpecDatabase {\n    internal Spec Range;\n    internal Spec BurstShotCount;\n    internal Spec WarmupTime;\n    internal Spec Cooldown;\n    internal Spec Damage;\n    internal Spec ArmorPenetration;\n    internal Spec StoppingPower;\n    internal Spec AccuracyTouch;\n    internal Spec AccuracyShort;\n    internal Spec AccuracyMedium;\n    internal Spec AccuracyLong;\n    internal Spec Mass;\n    internal Spec MarketValue;\n    internal Spec Dps;\n    private Spec _ticksBetweenBurstShots;\n\n    private readonly Thing _weapon;\n    private readonly CompDynamicTraits? _compDynamicTraits;\n\n    private enum Mode {\n        Raw,\n        Dynamic\n    }\n\n    public bool IsMeleeWeapon => _weapon.def.IsMeleeWeapon;\n\n    public SpecDatabase(Thing weapon) {\n        _weapon = weapon;\n        _compDynamicTraits = _weapon.TryGetComp<CompDynamicTraits>();\n\n        // Raw values\n        // === Stat ===\n        var weaponDef = weapon.def;\n        Mass = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.Mass), true);\n        MarketValue = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.MarketValue));\n        Cooldown = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.RangedWeapon_Cooldown), true);\n        AccuracyTouch = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.AccuracyTouch));\n        AccuracyShort = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.AccuracyShort));\n        AccuracyMedium = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.AccuracyMedium));\n        AccuracyLong = new Spec(weaponDef.GetStatValueAbstract(StatDefOf.AccuracyLong));\n\n        // === Verb ===\n        var weaponDefVerb = weaponDef.Verbs.FirstOrFallback();\n        if (weaponDefVerb != null) {\n            Range = new Spec(weaponDefVerb.range);\n            WarmupTime = new Spec(weaponDefVerb.warmupTime, true);\n            BurstShotCount = new Spec(weaponDefVerb.burstShotCount);\n            _ticksBetweenBurstShots = new Spec(weaponDefVerb.ticksBetweenBurstShots);\n\n            // === Projectile ===\n            var weaponDefProjectile = weaponDefVerb.defaultProjectile?.projectile;\n            if (weaponDefProjectile != null) {\n                Damage = new Spec(weaponDefProjectile.GetDamageAmount(weaponDef, weapon.Stuff));\n                ArmorPenetration = new Spec(weaponDefProjectile.GetArmorPenetration());\n                StoppingPower = new Spec(weaponDefProjectile.stoppingPower);\n            }\n        }\n\n        Dps = new Spec(CalculateDps(Mode.Raw));\n\n        Recalculate(); // init calc\n    }\n\n    public void Recalculate() {\n        // === Stat ===\n        Mass.Dynamic = _weapon.GetStatValue(StatDefOf.Mass);\n        MarketValue.Dynamic = _weapon.GetStatValue(StatDefOf.MarketValue);\n        Cooldown.Dynamic = _weapon.GetStatValue(StatDefOf.RangedWeapon_Cooldown);\n        AccuracyTouch.Dynamic = _weapon.GetStatValue(StatDefOf.AccuracyTouch);\n        AccuracyShort.Dynamic = _weapon.GetStatValue(StatDefOf.AccuracyShort);\n        AccuracyMedium.Dynamic = _weapon.GetStatValue(StatDefOf.AccuracyMedium);\n        AccuracyLong.Dynamic = _weapon.GetStatValue(StatDefOf.AccuracyLong);\n\n        // === Verb ===\n        var weaponVerb = _weapon.TryGetComp<CompEquippableAbilityReloadable>()?.PrimaryVerb\n                         ?? _weapon.TryGetComp<CompEquippable>()?.PrimaryVerb;\n\n        Range.Dynamic = Range.Raw * _weapon.GetStatValue(StatDefOf.RangedWeapon_RangeMultiplier);\n        WarmupTime.Dynamic = WarmupTime.Raw * _weapon.GetStatValue(StatDefOf.RangedWeapon_WarmupMultiplier);\n        BurstShotCount.Dynamic = weaponVerb?.BurstShotCount ?? -1; // harmony patched\n        _ticksBetweenBurstShots.Dynamic = weaponVerb?.TicksBetweenBurstShots ?? -1; // harmony patched\n\n        // === Projectile ===\n        var weaponDefProjectile = _weapon.def.Verbs.FirstOrFallback()?.defaultProjectile?.projectile;\n        if (weaponDefProjectile != null) {\n            Damage.Dynamic = weaponDefProjectile.GetDamageAmount(_weapon);\n            ArmorPenetration.Dynamic = weaponDefProjectile.GetArmorPenetration(_weapon);\n            StoppingPower.Dynamic = GetComputedStoppingPower(); // harmony patched\n        }\n\n        Dps.Dynamic = CalculateDps(Mode.Dynamic);\n    }\n\n    // === Helper ===\n    private float CalculateDps(Mode mode) {\n        var damage = mode == Mode.Raw ? Damage.Raw : Damage.Dynamic;\n        var burstCount = mode == Mode.Raw ? BurstShotCount.Raw : BurstShotCount.Dynamic;\n        var ticksBetweenShots = mode == Mode.Raw\n            ? _ticksBetweenBurstShots.Raw\n            : _ticksBetweenBurstShots.Dynamic;\n        var warmup = mode == Mode.Raw ? WarmupTime.Raw : WarmupTime.Dynamic;\n        var cooldown = mode == Mode.Raw ? Cooldown.Raw : Cooldown.Dynamic;\n\n        var totalDamage = damage * burstCount;\n        var totalBurstSec = ticksBetweenShots * (burstCount - 1) / 60f;\n        var totalCycleSec = warmup + cooldown + totalBurstSec;\n        return totalCycleSec <= 0 ? 0f : totalDamage / totalCycleSec;\n    }\n\n    private float GetComputedStoppingPower() {\n        var basePower = _weapon.def.Verbs\n            .FirstOrFallback()?.defaultProjectile?.projectile.stoppingPower ?? 0.5f;\n\n        // CompUniqueWeapon\n        if (_weapon.TryGetComp<CompUniqueWeapon>(out var compUniqueWeapon)) {\n            basePower += compUniqueWeapon.TraitsListForReading.Sum(trait => trait.additionalStoppingPower);\n        }\n\n        // CompDynamicTraits\n        var additional = _compDynamicTraits?.Traits.Sum(traitDef => traitDef.additionalStoppingPower) ?? 0;\n\n        return basePower + additional;\n    }\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/Data/SpecDatabase.cs",
    "startLine": 6,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "M:CWF.CompProperties_TraitModule.#ctor",
    "name": ".ctor",
    "fullName": "CWF.CompProperties_TraitModule.CompProperties_TraitModule()",
    "type": "Constructor",
    "baseType": null,
    "codeBody": "public CompProperties_TraitModule() => compClass = typeof(CompTraitModule);",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_TraitModule.cs",
    "startLine": 10,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  },
  {
    "id": "T:CWF.CompProperties_TraitModule",
    "name": "CompProperties_TraitModule",
    "fullName": "CWF.CompProperties_TraitModule",
    "type": "Class",
    "baseType": "Verse.CompProperties",
    "codeBody": "public class CompProperties_TraitModule : CompProperties {\n    public CompProperties_TraitModule() => compClass = typeof(CompTraitModule);\n}",
    "filePath": "/Users/lizhen/Documents/Code/CWF/CompProperties/CompProperties_TraitModule.cs",
    "startLine": 9,
    "attributes": [],
    "attributeDetails": [],
    "implementedInterfaces": [],
    "calls": [],
    "calledBy": []
  }
]
